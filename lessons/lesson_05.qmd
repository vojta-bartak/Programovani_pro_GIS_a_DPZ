---
title: "Lekce 5: Tvorba jednoduchÃ©ho algoritmu"
subtitle: "Python pro GIS - AlgoritmickÃ© myÅ¡lenÃ­"
author: "VojtÄ›ch BartÃ¡k, FÅ½P ÄŒZU Praha"
date: today
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    theme: cosmo
  pdf:       
    toc: true
    toc-depth: 3
    number-sections: true
editor: 
  markdown: 
    wrap: 72
---

\newpage

# CÃ­le lekce

Po absolvovÃ¡nÃ­ tÃ©to lekce budete umÄ›t:

-   Pracovat s Å™ezy seznamÅ¯ (slicing)
-   PouÅ¾Ã­vat pokroÄilÃ© metody seznamÅ¯
-   Implementovat algoritmus pro hledÃ¡nÃ­ minima a maxima
-   Navrhnout a implementovat tÅ™Ã­dÃ­cÃ­ algoritmus (Bubble Sort, Selection
    Sort)
-   Pracovat s vnoÅ™enÃ½mi cykly
-   Propojit vnoÅ™enÃ© cykly s vnoÅ™enÃ½mi modely z Model Builderu

**ÄŒasovÃ¡ dotace:** 90 minut

------------------------------------------------------------------------

# Rekapitulace a rozÅ¡Ã­Å™enÃ­ seznamÅ¯

## RychlÃ¡ rekapitulace z minula

``` python
# Co uÅ¾ umÃ­me ze seznamÅ¯:
cisla = [1, 2, 3, 4, 5]

cisla[0]           # 1 - prvnÃ­ prvek (index 0!)
cisla[-1]          # 5 - poslednÃ­ prvek
len(cisla)         # 5 - dÃ©lka seznamu
cisla.append(6)    # PÅ™idÃ¡nÃ­ prvku na konec
cisla[3] = 2       # zmÄ›na ÄtvrtÃ©ho prvku
```

## Slicing (Å™ezy) - novÃ¡ technika

**Slicing** umoÅ¾Åˆuje vybrat ÄÃ¡st seznamu:

### ZÃ¡kladnÃ­ syntaxe: `seznam[start:stop]`

``` python
cisla = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

cisla[2:5]     # [2, 3, 4] - od indexu 2 do 5 (bez 5!)
cisla[:3]      # [0, 1, 2] - od zaÄÃ¡tku do indexu 3
cisla[7:]      # [7, 8, 9] - od indexu 7 do konce
cisla[-3:]     # [7, 8, 9] - poslednÃ­ 3 prvky
```

::: callout-tip
## Zapamatujte si

-   `start` je **vÄetnÄ›** (from)
-   `stop` je **bez** (to, but not including)
-   `cisla[2:5]` znamenÃ¡: "od indexu 2 aÅ¾ po (ale bez) index 5"
:::

### Slicing s krokem: `seznam[start:stop:step]`

``` python
cisla = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

cisla[::2]     # [0, 2, 4, 6, 8] - kaÅ¾dÃ½ druhÃ½
cisla[1::2]    # [1, 3, 5, 7, 9] - kaÅ¾dÃ½ druhÃ½, ale od indexu 1
cisla[::3]     # [0, 3, 6, 9] - kaÅ¾dÃ½ tÅ™etÃ­
cisla[::-1]    # [9, 8, 7, ..., 0] - OTOÄŒENÃ seznamu!
```

### PraktickÃ© pÅ™Ã­klady

``` python
text = "Python"
text[::-1]     # "nohtyP" - otoÄenÃ½ string

# PrvnÃ­ polovina seznamu
polovina = len(cisla) // 2
prvni_cast = cisla[:polovina]

# DruhÃ¡ polovina
druha_cast = cisla[polovina:]
```

## UÅ¾iteÄnÃ© metody seznamÅ¯

### extend() - pÅ™ipojenÃ­ vÃ­ce prvkÅ¯

``` python
a = [1, 2, 3]
a.extend([4, 5, 6])    # [1, 2, 3, 4, 5, 6]

# AlternativnÄ›:
a = a + [4, 5, 6]      # TotÃ©Å¾, ale vytvoÅ™Ã­ novÃ½ seznam
```

### insert() - vloÅ¾enÃ­ na konkrÃ©tnÃ­ pozici

``` python
cisla = [1, 2, 4, 5]
cisla.insert(2, 3)     # [1, 2, 3, 4, 5] - vloÅ¾it 3 na index 2
```

### remove() - odstranÄ›nÃ­ prvnÃ­ho vÃ½skytu hodnoty

``` python
cisla = [1, 2, 3, 2, 4]
cisla.remove(2)        # [1, 3, 2, 4] - odstranÃ­ prvnÃ­ vÃ½skyt 2
```

### index() - vracÃ­ index prvnÃ­ho vÃ½skytu hodnoty

``` python
cisla = [1, 2, 3, 2, 4]
cisla.index(2)        # vracÃ­ 1
```

### pop() - odstranÄ›nÃ­ a vrÃ¡cenÃ­ prvku

``` python
cisla = [1, 2, 3, 4, 5]
posledni = cisla.pop()     # posledni = 5, cisla = [1,2,3,4]
druhy = cisla.pop(1)       # druhy = 2, cisla = [1,3,4]
```

### reverse() - otoÄenÃ­ seznamu

``` python
cisla = [1, 2, 3, 4, 5]
cisla.reverse()        # [5, 4, 3, 2, 1] - mÄ›nÃ­ pÅ¯vodnÃ­ seznam!

# AlternativnÄ› (vytvoÅ™Ã­ novÃ½):
otoceny = cisla[::-1]
```

### sort() - seÅ™azenÃ­

``` python
cisla = [5, 2, 8, 1, 9]
cisla.sort()           # [1, 2, 5, 8, 9] - vzestupnÄ›

cisla.sort(reverse=True)  # [9, 8, 5, 2, 1] - sestupnÄ›

# AlternativnÄ› (vytvoÅ™Ã­ novÃ½):
serazeny = sorted(cisla)
```

## CviÄenÃ­ 1: PrÃ¡ce se seznamem

``` python
cisla = [10, 25, 3, 47, 8, 19, 33, 5]

# 1. VypiÅ¡te prvnÃ­ tÅ™i ÄÃ­sla
# 2. VypiÅ¡te poslednÃ­ dvÄ› ÄÃ­sla
# 3. VypiÅ¡te kaÅ¾dÃ© druhÃ© ÄÃ­slo
# 4. OtoÄte seznam a vypiÅ¡te ho
# 5. SeÅ™aÄte seznam vzestupnÄ›
```

------------------------------------------------------------------------

# HledÃ¡nÃ­ minima a maxima

::: callout-tip
## ProÄ zaÄÃ­nÃ¡me s minimem/maximem?

Tento algoritmus se **pÅ™Ã­mo pouÅ¾ije** pÅ™i tÅ™Ã­dÄ›nÃ­! Je to perfektnÃ­
pÅ™Ã­prava na Selection Sort.
:::

## Motivace

**Ãškol:** MÃ¡te seznam ÄÃ­sel `[5, 2, 8, 1, 9, 3]`. NajdÄ›te nejmenÅ¡Ã­
ÄÃ­slo.

**OtÃ¡zka pro studenty:** Jak byste to udÄ›lali ruÄnÄ›?

VÄ›tÅ¡ina Å™ekne: *"Projdu vÅ¡echna ÄÃ­sla a pamatuji si, jakÃ© bylo dosud
nejmenÅ¡Ã­."*

## Algoritmus krok za krokem

```         
Seznam: [5, 2, 8, 1, 9, 3]

1. ZaÄnu, minimum = 5 (prvnÃ­ ÄÃ­slo)
2. DalÅ¡Ã­ je 2 â†’ 2 < 5? Ano â†’ novÃ© minimum = 2
3. DalÅ¡Ã­ je 8 â†’ 8 < 2? Ne
4. DalÅ¡Ã­ je 1 â†’ 1 < 2? Ano â†’ novÃ© minimum = 1
5. DalÅ¡Ã­ je 9 â†’ 9 < 1? Ne
6. DalÅ¡Ã­ je 3 â†’ 3 < 1? Ne
7. Konec â†’ minimum = 1
```

## Implementace - spoleÄnÄ›

``` python
cisla = [5, 2, 8, 1, 9, 3]

# ZaÄnu s prvnÃ­m ÄÃ­slem jako minimem
minimum = cisla[0]

# Projdu zbytek seznamu
for cislo in cisla:
    if cislo < minimum:
        minimum = cislo

print(f"NejmenÅ¡Ã­ ÄÃ­slo: {minimum}")
# NejmenÅ¡Ã­ ÄÃ­slo: 1
```

::: callout-note
## ProÄ `minimum = cisla[0]`?

Mohli bychom zaÄÃ­t s velkÃ½m ÄÃ­slem (napÅ™. `minimum = 999999`), ale to
nenÃ­ elegantnÃ­. LepÅ¡Ã­ je zaÄÃ­t s prvnÃ­m ÄÃ­slem v seznamu - vÃ­me, Å¾e
minimum nemÅ¯Å¾e bÃ½t vÄ›tÅ¡Ã­ neÅ¾ prvnÃ­ prvek!
:::

## Maximum - obdobnÄ›

``` python
cisla = [5, 2, 8, 1, 9, 3]
maximum = cisla[0]

for cislo in cisla:
    if cislo > maximum:
        maximum = cislo

print(f"NejvÄ›tÅ¡Ã­ ÄÃ­slo: {maximum}")
# NejvÄ›tÅ¡Ã­ ÄÃ­slo: 9
```

## HledÃ¡nÃ­ indexu minima

**DÅ¯leÅ¾itÃ© pro tÅ™Ã­dÄ›nÃ­!** ÄŒasto potÅ™ebujeme nejen hodnotu minima, ale i
jeho **pozici** v seznamu.

``` python
cisla = [5, 2, 8, 1, 9, 3]

# ZaÄnu s indexem 0
min_index = 0

# Projdu vÅ¡echny indexy
for i in range(len(cisla)):
    if cisla[i] < cisla[min_index]:
        min_index = i

print(f"Index nejmenÅ¡Ã­ho ÄÃ­sla: {min_index}")
print(f"Hodnota: {cisla[min_index]}")
# Index nejmenÅ¡Ã­ho ÄÃ­sla: 3
# Hodnota: 1
```

::: callout-important
## ProÄ potÅ™ebujeme index?

PÅ™i tÅ™Ã­dÄ›nÃ­ budeme chtÃ­t **prohodit** pozice prvkÅ¯. K tomu potÅ™ebujeme
vÄ›dÄ›t, **kde** se minimum nachÃ¡zÃ­!
:::

------------------------------------------------------------------------

# TÅ™Ã­dÄ›nÃ­

## Motivace

**Ãškol:** SeÅ™aÄte seznam `[5, 2, 8, 1, 9]` vzestupnÄ›.

**OtÃ¡zka:** Jak byste to udÄ›lali na papÃ­Å™e?

::: callout-note
## Brainstorming (5 minut)

Diskutujte se spoluÅ¾Ã¡ky: - Jak byste Å™adili ÄÃ­sla ruÄnÄ›? - JakÃ© kroky
byste opakovali? - MÅ¯Å¾ete to popsat slovnÄ›?

**VÄ›tÅ¡ina lidÃ­ pÅ™ijde na jeden z tÄ›chto pÅ™Ã­stupÅ¯:** 1. **"Najdu
nejmenÅ¡Ã­, dÃ¡m ho stranou, opakuji"** â†’ Selection Sort 2. **"PorovnÃ¡vÃ¡m
sousedy, kdyÅ¾ je Å¡patnÃ© poÅ™adÃ­, prohodÃ­m, opakuji DOKUD prohazuji"** â†’
Bubble Sort
:::

------------------------------------------------------------------------

## Bubble Sort (bublinovÃ© tÅ™Ã­dÄ›nÃ­)

### Princip

ProchÃ¡zÃ­me seznam a **porovnÃ¡vÃ¡me dvojice sousednÃ­ch prvkÅ¯**. Pokud jsou
ve Å¡patnÃ©m poÅ™adÃ­, prohodÃ­me je. **Opakujeme DOKUD jsme nÄ›co
prohazovali.**

### Vizualizace na pÅ™Ã­kladu `[5, 2, 8, 1, 9]`

**PrvnÃ­ prÅ¯chod:**

```         
[5, 2, 8, 1, 9]  â†’ 5 > 2? Ano, prohoÄ
[2, 5, 8, 1, 9]  â†’ 5 > 8? Ne
[2, 5, 8, 1, 9]  â†’ 8 > 1? Ano, prohoÄ  
[2, 5, 1, 8, 9]  â†’ 8 > 9? Ne
[2, 5, 1, 8, 9]  â† Prohodili jsme â†’ pokraÄujeme!
```

**DruhÃ½ prÅ¯chod:**

```         
[2, 5, 1, 8, 9]  â†’ 2 > 5? Ne
[2, 5, 1, 8, 9]  â†’ 5 > 1? Ano, prohoÄ
[2, 1, 5, 8, 9]  â†’ 5 > 8? Ne
[2, 1, 5, 8, 9]  â†’ 8 > 9? Ne
[2, 1, 5, 8, 9]  â† Prohodili jsme â†’ pokraÄujeme!
```

**TÅ™etÃ­ prÅ¯chod:**

```         
[2, 1, 5, 8, 9]  â†’ 2 > 1? Ano, prohoÄ
[1, 2, 5, 8, 9]  â†’ 2 > 5? Ne
[1, 2, 5, 8, 9]  â†’ 5 > 8? Ne
[1, 2, 5, 8, 9]  â†’ 8 > 9? Ne
[1, 2, 5, 8, 9]  â† Prohodili jsme â†’ pokraÄujeme!
```

**ÄŒtvrtÃ½ prÅ¯chod:**

```         
[1, 2, 5, 8, 9]  â†’ 1 > 2? Ne
[1, 2, 5, 8, 9]  â†’ 2 > 5? Ne
[1, 2, 5, 8, 9]  â†’ 5 > 8? Ne
[1, 2, 5, 8, 9]  â†’ 8 > 9? Ne
[1, 2, 5, 8, 9]  â† Nic se neprohodilo â†’ HOTOVO!
```

### Implementace - spoleÄnÄ›

``` python
seznam = [5, 2, 8, 1, 9]
print(f"PÅ¯vodnÃ­ seznam: {seznam}")

# KlÃ­ÄovÃ¡ myÅ¡lenka: "Opakuj DOKUD prohazujeÅ¡"
serazeno = False

while not serazeno:
    # PÅ™edpoklÃ¡dÃ¡m, Å¾e seznam JE seÅ™azenÃ½
    serazeno = True
    
    # Projdu vÅ¡echny sousednÃ­ dvojice
    for i in range(len(seznam) - 1):
        # PorovnÃ¡m sousedy
        if seznam[i] > seznam[i + 1]:
            # Å patnÃ© poÅ™adÃ­ â†’ prohozenÃ­
            seznam[i], seznam[i + 1] = seznam[i + 1], seznam[i]
            # NÄ›co jsem prohodil â†’ NENÃ seÅ™azeno!
            serazeno = False

print(f"SeÅ™azenÃ½ seznam: {seznam}")
# [1, 2, 5, 8, 9]
```

::: callout-tip
## Jak to funguje?

1.  **`serazeno = False`**: Na zaÄÃ¡tku pÅ™edpoklÃ¡dÃ¡me, Å¾e seznam nenÃ­
    seÅ™azenÃ½
2.  **`while not serazeno:`**: Opakuj, DOKUD nenÃ­ seÅ™azeno
3.  **`serazeno = True`**: Na zaÄÃ¡tku kaÅ¾dÃ©ho prÅ¯chodu pÅ™edpoklÃ¡dÃ¡m "je
    seÅ™azeno"
4.  **Projdu vÅ¡echny dvojice**: `for i in range(len(seznam) - 1)`
5.  **Pokud najdu Å¡patnÃ© poÅ™adÃ­**: ProhodÃ­m a nastavÃ­m
    `serazeno = False`
6.  **Pokud projdu celÃ½ seznam** a nic neprohodÃ­m â†’ `serazeno` zÅ¯stane
    `True` â†’ cyklus skonÄÃ­!
:::

### AlternativnÃ­ implementace (volitelnÄ›)

PÅ™edchozÃ­ implementace je intuitivnÃ­, protoÅ¾e odrÃ¡Å¾Ã­ zpÅ¯sob, jak lidÃ©
**pÅ™irozenÄ› myslÃ­**. Ve skuteÄnosti nenÃ­ ÃºplnÄ› efektivnÃ­, protoÅ¾e po
prvnÃ­m prÅ¯chodu mÃ¡me jistotu, Å¾e poslednÃ­ prvek je jiÅ¾ na sprÃ¡vnÃ©m
mÃ­stÄ›. AlternativnÃ­ implementace pomocÃ­ dvou vnoÅ™enÃ½ch 'for' cyklÅ¯ toto
zohledÅˆuje:

``` python
seznam = [5, 2, 8, 1, 9]

# VnÄ›jÅ¡Ã­ cyklus - kolik prÅ¯chodÅ¯ potÅ™ebujeme?
for i in range(len(seznam)):
    
    # VnitÅ™nÃ­ cyklus - porovnÃ¡nÃ­ sousedÅ¯
    for j in range(len(seznam) - 1 - i):
        
        # PorovnÃ¡nÃ­ a prohozenÃ­
        if seznam[j] > seznam[j + 1]:
            seznam[j], seznam[j + 1] = seznam[j + 1], seznam[j]

print(seznam)  # [1, 2, 5, 8, 9]
```

::: callout-important
## VnoÅ™enÃ© cykly!

VÅ¡imnÄ›te si **dvou cyklÅ¯ jeden v druhÃ©m**: - **VnÄ›jÅ¡Ã­** (`for i`) Å™Ã­kÃ¡:
"KolikrÃ¡t opakuji celÃ½ prÅ¯chod?" - **VnitÅ™nÃ­** (`for j`) Å™Ã­kÃ¡: "Jak
prochÃ¡zÃ­m dvojice?"

Toto je **vnoÅ™enÃ½ cyklus** - stejnÃ½ princip jako vnoÅ™enÃ© modely v Model
Builderu!
:::

### ProÄ `len(seznam) - 1 - i`?

``` python
# PrvnÃ­ prÅ¯chod (i=0): porovnÃ¡vÃ¡me vÅ¡echny dvojice
range(len(seznam) - 1)  # 0,1,2,3

# DruhÃ½ prÅ¯chod (i=1): poslednÃ­ je uÅ¾ sprÃ¡vnÄ›, vynechÃ¡me
range(len(seznam) - 1 - 1)  # 0,1,2

# A tak dÃ¡le...
```

::: callout-note
## KterÃ¡ verze je efektivnÄ›jÅ¡Ã­?

**ZÃ¡visÃ­ na situaci!**

**While verze** je mnohem rychlejÅ¡Ã­, kdyÅ¾: - Seznam je uÅ¾ seÅ™azenÃ½ nebo
skoro seÅ™azenÃ½ - MÅ¯Å¾e skonÄit brzy (best case: jen 1 prÅ¯chod)

**For verze** je rychlejÅ¡Ã­, kdyÅ¾: - Seznam je ÃºplnÄ› zamÃ­chanÃ½ nebo
opaÄnÄ› seÅ™azenÃ½ - V nejhorÅ¡Ã­m pÅ™Ã­padÄ› dÄ›lÃ¡ mÃ©nÄ› porovnÃ¡nÃ­ celkem
:::

------------------------------------------------------------------------

## Selection Sort (tÅ™Ã­dÄ›nÃ­ vÃ½bÄ›rem)

::: callout-tip
## TeÄ pouÅ¾ijeme, co jsme se nauÄili!

Pamatujete si hledÃ¡nÃ­ indexu minima? PÅ™esnÄ› to teÄ pouÅ¾ijeme!
:::

### Princip

**MyÅ¡lenka:** 1. Najdi **nejmenÅ¡Ã­ prvek** v celÃ©m seznamu â†’ dej ho na
prvnÃ­ mÃ­sto 2. Najdi **nejmenÅ¡Ã­ prvek** ve zbytku seznamu â†’ dej ho na
druhÃ© mÃ­sto 3. Opakuj...

**VyuÅ¾Ã­vÃ¡me:** Algoritmus pro hledÃ¡nÃ­ indexu minima, kterÃ½ jsme prÃ¡vÄ›
napsali!

### Vizualizace krok za krokem

```         
PÅ¯vodnÃ­ seznam: [5, 2, 8, 1, 9, 3]

Krok 1: Najdi minimum v [5, 2, 8, 1, 9, 3]
        â†’ minimum je 1 (index 3)
        â†’ prohoÄ 5 â†” 1
        [1, 2, 8, 5, 9, 3]
         ^ vyÅ™eÅ¡eno

Krok 2: Najdi minimum v [2, 8, 5, 9, 3]
        â†’ minimum je 2 (index 1)
        â†’ uÅ¾ je na sprÃ¡vnÃ©m mÃ­stÄ›
        [1, 2, 8, 5, 9, 3]
            ^ vyÅ™eÅ¡eno

Krok 3: Najdi minimum v [8, 5, 9, 3]
        â†’ minimum je 3 (index 5)
        â†’ prohoÄ 8 â†” 3
        [1, 2, 3, 5, 9, 8]
               ^ vyÅ™eÅ¡eno

Krok 4: Najdi minimum v [5, 9, 8]
        â†’ minimum je 5 (index 3)
        â†’ uÅ¾ je sprÃ¡vnÄ›
        [1, 2, 3, 5, 9, 8]
                  ^ vyÅ™eÅ¡eno

Krok 5: Najdi minimum v [9, 8]
        â†’ minimum je 8 (index 5)
        â†’ prohoÄ 9 â†” 8
        [1, 2, 3, 5, 8, 9]
                     ^ vyÅ™eÅ¡eno

Hotovo!
```

### Implementace - spoleÄnÄ›

``` python
seznam = [5, 2, 8, 1, 9, 3]

# Pro kaÅ¾dou pozici 0, 1, 2, ...
for i in range(len(seznam)):
    # Najdi index minima ve zbytku seznamu
    # (od pozice i do konce)
    # â†“â†“â†“ TOHLE JSME DÄšLALI PÅ˜ED CHVÃLÃ! â†“â†“â†“
    min_index = i
    
    for j in range(i + 1, len(seznam)):
        if seznam[j] < seznam[min_index]:
            min_index = j
    # â†‘â†‘â†‘ ALGORITMUS PRO HLEDÃNÃ INDEXU MINIMA â†‘â†‘â†‘
    
    # ProhoÄ aktuÃ¡lnÃ­ prvek s nalezenÃ½m minimem
    seznam[i], seznam[min_index] = seznam[min_index], seznam[i]

print(seznam)  # [1, 2, 3, 5, 8, 9]
```

::: callout-important
## VÅ¡imnÄ›te si!

**VnitÅ™nÃ­ cyklus** je pÅ™esnÄ› algoritmus pro hledÃ¡nÃ­ indexu minima, kterÃ½
jsme dÄ›lali pÅ™ed chvÃ­lÃ­!

Selection Sort = **opakovanÃ© pouÅ¾itÃ­** algoritmu pro hledÃ¡nÃ­ minima! ğŸ¯
:::

::: callout-tip
## Pro praxi

V reÃ¡lnÃ½ch programech pouÅ¾Ã­vÃ¡me vestavÄ›nou funkci `sort()` nebo
`sorted()`, kterÃ¡ je **mnohem rychlejÅ¡Ã­**:

``` python
seznam = [5, 2, 8, 1, 9]

# ZpÅ¯sob 1: sort() - upravÃ­ pÅ¯vodnÃ­ seznam
seznam.sort()
print(seznam)  # [1, 2, 5, 8, 9]

# ZpÅ¯sob 2: sorted() - vrÃ¡tÃ­ novÃ½ seznam
puvodni = [5, 2, 8, 1, 9]
serazeny = sorted(puvodni)
print(puvodni)   # [5, 2, 8, 1, 9] - nezmÄ›nÄ›n
print(serazeny)  # [1, 2, 5, 8, 9]
```

**ProÄ jsme pak psali vlastnÃ­ algoritmus?** - Rozvoj **algoritmickÃ©ho
myÅ¡lenÃ­** - PochopenÃ­, **jak poÄÃ­taÄe fungujÃ­** uvnitÅ™ - PÅ™Ã­prava na
**sloÅ¾itÄ›jÅ¡Ã­ problÃ©my** (v GIS budete Å™eÅ¡it vlastnÃ­ algoritmy!) -
PochopenÃ­ **vnoÅ™enÃ½ch cyklÅ¯**
:::

------------------------------------------------------------------------

# VnoÅ™enÃ© cykly a propojenÃ­ s Model Builderem

## Co jsou vnoÅ™enÃ© cykly?

**VnoÅ™enÃ½ cyklus** = cyklus uvnitÅ™ jinÃ©ho cyklu.

``` python
for i in range(3):
    for j in range(2):
        print(f"i={i}, j={j}")
```

**VÃ½stup:**

```         
i=0, j=0
i=0, j=1
i=1, j=0
i=1, j=1
i=2, j=0
i=2, j=1
```

**Jak to funguje:** - Pro kaÅ¾dou hodnotu `i` (vnÄ›jÅ¡Ã­ cyklus) - Projdeme
vÅ¡echny hodnoty `j` (vnitÅ™nÃ­ cyklus)

## PraktickÃ½ pÅ™Ã­klad: Tabulka nÃ¡sobenÃ­

``` python
# Tabulka nÃ¡sobenÃ­ 1-5
for i in range(1, 6):
    for j in range(1, 6):
        print(f"{i} Ã— {j} = {i * j}")
    print("---")  # OddÄ›lovaÄ
```

## PropojenÃ­ s Model Builderem

::: callout-note
## VzpomÃ­nÃ¡te na vnoÅ™enÃ© modely?

V Model Builderu jste pouÅ¾Ã­vali **vnoÅ™enÃ© iterÃ¡tory**: - VnÄ›jÅ¡Ã­
iterator: Pro kaÅ¾dÃ½ **okres** - VnitÅ™nÃ­ iterator: Pro kaÅ¾dÃ½ **rok**\
- â†’ Zpracovat data pro kaÅ¾dÃ½ okres v kaÅ¾dÃ©m roce

**V Pythonu je to stejnÃ©, jen mÃ­sto Model Builderu pÃ­Å¡ete kÃ³d!**
:::

### PÅ™Ã­klad: GIS Ãºloha

``` python
okresy = ["Praha", "Brno", "Ostrava"]
roky = [2020, 2021, 2022]

for okres in okresy:
    for rok in roky:
        print(f"ZpracovÃ¡vÃ¡m: {okres}, {rok}")
        # Zde by byl ArcPy kÃ³d pro zpracovÃ¡nÃ­ dat
```

**VÃ½stup:**

```         
ZpracovÃ¡vÃ¡m: Praha, 2020
ZpracovÃ¡vÃ¡m: Praha, 2021
ZpracovÃ¡vÃ¡m: Praha, 2022
ZpracovÃ¡vÃ¡m: Brno, 2020
ZpracovÃ¡vÃ¡m: Brno, 2021
ZpracovÃ¡vÃ¡m: Brno, 2022
ZpracovÃ¡vÃ¡m: Ostrava, 2020
ZpracovÃ¡vÃ¡m: Ostrava, 2021
ZpracovÃ¡vÃ¡m: Ostrava, 2022
```

**VypadÃ¡ vÃ¡m to povÄ›domÄ›?** PÅ™esnÄ› toto jste dÄ›lali v Model Builderu
graficky. V Pythonu to napÃ­Å¡ete pÅ™Ã­mo!

------------------------------------------------------------------------

# ShrnutÃ­

## Co jsme se nauÄili

âœ… **Slicing** - Å™ezy seznamÅ¯ (`seznam[start:stop:step]`)\
âœ… **Metody seznamÅ¯** - `extend()`, `insert()`, `remove()`, `pop()`,
`reverse()`, `sort()`\
âœ… **HledÃ¡nÃ­ minima/maxima** - algoritmus pro hledÃ¡nÃ­ nejmenÅ¡Ã­/nejvÄ›tÅ¡Ã­
hodnoty\
âœ… **Index minima** - klÃ­ÄovÃ© pro tÅ™Ã­dÄ›nÃ­!\
âœ… **Bubble Sort** - tÅ™Ã­dÄ›nÃ­ porovnÃ¡vÃ¡nÃ­m sousedÅ¯ (while verze)\
âœ… **Selection Sort** - tÅ™Ã­dÄ›nÃ­ vÃ½bÄ›rem minima\
âœ… **VnoÅ™enÃ© cykly** - cyklus v cyklu\
âœ… **PropojenÃ­ s Model Builderem** - vnoÅ™enÃ© cykly = vnoÅ™enÃ© iterÃ¡tory

## Co bude pÅ™Ã­Å¡tÄ›?

V pÅ™Ã­Å¡tÃ­ lekci:

-   **Funkce** - jak psÃ¡t znovupouÅ¾itelnÃ½ kÃ³d
-   **Moduly** - jak organizovat program
-   PÅ™epÃ­Å¡eme Fibonacci, faktoriÃ¡l a tÅ™Ã­dÄ›nÃ­ **jako funkce**
-   VytvoÅ™Ã­me vlastnÃ­ modul `math_utils.py`

------------------------------------------------------------------------

# DomÃ¡cÃ­ Ãºkol

## Varianta A (zÃ¡kladnÃ­)

1.  **ProcviÄenÃ­ minima/maxima:**

    -   NapiÅ¡te funkci, kterÃ¡ vrÃ¡tÃ­ minimum a maximum najednou
    -   NajdÄ›te druhÃ© nejmenÅ¡Ã­ ÄÃ­slo v seznamu

2.  **PrvoÄÃ­sla**

    -   NapiÅ¡te program, kterÃ½ zjistÃ­, zda je ÄÃ­slo prvoÄÃ­slo
    -   **NÃ¡povÄ›da:**

    ``` python
    n = int(input("Zadej ÄÃ­slo: "))
    je_prvocislo = True

    # Zkusit dÄ›lit vÅ¡emi ÄÃ­sly od 2 do n-1
    for i in range(2, n):
        if n % i == 0:  # Je dÄ›litelnÃ©?
            je_prvocislo = False
            break

    if je_prvocislo:
        print(f"{n} je prvoÄÃ­slo")
    else:
        print(f"{n} nenÃ­ prvoÄÃ­slo")
    ```

## Varianta B (pokroÄilÃ¡)

1.  **VÅ¡echna prvoÄÃ­sla do 100** - najdÄ›te vÅ¡echna prvoÄÃ­sla v rozsahu
2.  **Implementujte oba tÅ™Ã­dÃ­cÃ­ algoritmy** a porovnejte, kterÃ½ je
    ÄitelnÄ›jÅ¡Ã­
3.  **K-tÃ© nejmenÅ¡Ã­ ÄÃ­slo** - najdÄ›te tÅ™etÃ­ nejmenÅ¡Ã­ ÄÃ­slo v seznamu

## Varianta C (vÃ½zva)

1.  **Eratosthenovo sÃ­to** - velmi rychlÃ½ algoritmus pro hledÃ¡nÃ­
    prvoÄÃ­sel:

    ``` python
    n = 100
    je_prvocislo = [True] * (n + 1)
    je_prvocislo[0] = je_prvocislo[1] = False

    # Implementujte Eratosthenovo sÃ­to...
    ```

2.  **VlastnÃ­ tÅ™Ã­dÃ­cÃ­ algoritmus** - vymyslete ÃºplnÄ› jinÃ½ zpÅ¯sob tÅ™Ã­dÄ›nÃ­

------------------------------------------------------------------------

\newpage

# Cheatsheet

``` python
# === SLICING ===
seznam[start:stop]      # Od start do stop (bez stop)
seznam[:n]              # PrvnÃ­ n prvkÅ¯
seznam[n:]              # Od n-tÃ©ho do konce
seznam[-n:]             # PoslednÃ­ch n prvkÅ¯
seznam[::step]          # KaÅ¾dÃ½ step-tÃ½ prvek
seznam[::-1]            # OtoÄenÃ­ seznamu

# === METODY SEZNAMÅ® ===
seznam.extend([a, b])   # PÅ™idÃ¡nÃ­ vÃ­ce prvkÅ¯
seznam.insert(i, x)     # VloÅ¾enÃ­ x na index i
seznam.remove(x)        # OdstranÄ›nÃ­ prvnÃ­ hodnoty x
seznam.pop()            # OdstranÄ›nÃ­ a vrÃ¡cenÃ­ poslednÃ­ho
seznam.pop(i)           # OdstranÄ›nÃ­ a vrÃ¡cenÃ­ i-tÃ©ho
seznam.reverse()        # OtoÄenÃ­ seznamu (in-place)
seznam.sort()           # SeÅ™azenÃ­ (in-place)
sorted(seznam)          # SeÅ™azenÃ­ (novÃ½ seznam)

# === MINIMUM/MAXIMUM ===
# Hodnota minima
minimum = cisla[0]
for cislo in cisla:
    if cislo < minimum:
        minimum = cislo

# Index minima
min_index = 0
for i in range(len(cisla)):
    if cisla[i] < cisla[min_index]:
        min_index = i

# === BUBBLE SORT (while verze) ===
serazeno = False
while not serazeno:
    serazeno = True
    for i in range(len(seznam) - 1):
        if seznam[i] > seznam[i + 1]:
            seznam[i], seznam[i + 1] = seznam[i + 1], seznam[i]
            serazeno = False

# === SELECTION SORT ===
for i in range(len(seznam)):
    min_index = i
    for j in range(i + 1, len(seznam)):
        if seznam[j] < seznam[min_index]:
            min_index = j
    seznam[i], seznam[min_index] = seznam[min_index], seznam[i]

# === VNOÅ˜ENÃ‰ CYKLY ===
for i in range(n):
    for j in range(m):
        # Pro kaÅ¾dÃ© i projdi vÅ¡echna j
        print(f"{i}, {j}")
```

------------------------------------------------------------------------

::: {.content-visible when-format="pdf"}

\newpage

# PoznÃ¡mky pro vyuÄujÃ­cÃ­ho

## BÄ›Å¾nÃ© chyby studentÅ¯

``` python
# 1. Slicing - zapomÃ­najÃ­, Å¾e stop je bez
seznam[2:5]  # [2, 3, 4] - NE [2, 3, 4, 5]!

# 2. Bubble sort - zapomÃ­najÃ­ range(len - 1)
for i in range(len(seznam)):  # CHYBA - index out of range!
    if seznam[i] > seznam[i + 1]:  # i+1 pÅ™esÃ¡hne dÃ©lku

# SprÃ¡vnÄ›:
for i in range(len(seznam) - 1):

# 3. Selection sort - prohozenÃ­ pÅ™ed nalezenÃ­m minima
for i in range(len(seznam)):
    min_index = i  # âœ“
    seznam[i], seznam[min_index] = ...  # âœ— CHYBA - min_index jeÅ¡tÄ› nenÃ­ sprÃ¡vnÃ½!
    # NajÃ­t minimum NEJDÅ˜ÃV!

# 4. Minimum - zapomÃ­najÃ­ inicializovat
minimum = cisla[0]  # âœ“ ZaÄÃ­t s prvnÃ­m prvkem!
```

## ÄŒasovÃ½ plÃ¡n (90 min)

| ÄŒas | Obsah |
|----------------|--------------------------------------------------------|
| 0-5 min | Rekapitulace minulÃ© lekce |
| 5-20 min | Seznamy - slicing a metody |
| 20-45 min | **Minimum/Maximum** - hodnota + index |
| 45-85 min | **TÅ™Ã­dÄ›nÃ­** - Bubble Sort (20 min) + Selection Sort (20 min) + vnoÅ™enÃ© cykly (5 min) |
| 85-90 min | DomÃ¡cÃ­ Ãºkol |

## KlÃ­ÄovÃ© momenty

### Seznamy (5-20 min):

-   Slicing ukÃ¡zat na konkrÃ©tnÃ­ch pÅ™Ã­kladech
-   `[::-1]` je nejuÅ¾iteÄnÄ›jÅ¡Ã­ trik
-   Metody rychle proletÄ›t, nejsou kritickÃ©

### Minimum/Maximum (20-45 min):

-   **ZdÅ¯raznÄ›te:** "Tohle pouÅ¾ijeme za chvÃ­li v tÅ™Ã­dÄ›nÃ­!"
-   **Index minima** je klÃ­ÄovÃ½ - vÄ›nujte tomu Äas
-   Nechte studenty implementovat minimum sami
-   UkaÅ¾te debugovacÃ­ verzi

### TÅ™Ã­dÄ›nÃ­ (45-85 min):

-   **KRITICKÃ‰:** ZaÄÃ­t brainstormingem (5 min)
-   Studenti Äasto sami pÅ™ijdou na algoritmy!
-   **Bubble Sort s while** - zdÅ¯raznÄ›te pÅ™irozenou logiku
-   **Selection Sort** - "VidÃ­te? To jsme dÄ›lali pÅ™ed chvÃ­lÃ­!"
-   Vizualizovat na tabuli/projektoru
-   ZdÅ¯raznit vnoÅ™enÃ© cykly

## Rizika a Å™eÅ¡enÃ­

1.  **TÅ™Ã­dÄ›nÃ­ mÅ¯Å¾e bÃ½t tÄ›Å¾kÃ©**
    -   Å˜eÅ¡enÃ­: MÃ­t pÅ™ipravenÃ½ promÃ­tanÃ½ kÃ³d
    -   Selection Sort je volitelnÃ½ (mÅ¯Å¾ete pÅ™eskoÄit)
    -   DÅ¯leÅ¾itÄ›jÅ¡Ã­ je dobrÃ½ Bubble Sort
2.  **Studenti budou rÅ¯znÄ› rychlÃ­**
    -   Å˜eÅ¡enÃ­: RychlejÅ¡Ã­ pomÃ¡hajÃ­ pomalejÅ¡Ã­m
    -   BonusovÃ© Ãºkoly pro rychlÃ©
3.  **VnoÅ™enÃ© cykly jsou abstraktnÃ­**
    -   Å˜eÅ¡enÃ­: Vizualizovat tabulku nÃ¡sobenÃ­
    -   Propojit s Model Builderem iterÃ¡tory!

## Tipy

-   **Brainstorming tÅ™Ã­dÄ›nÃ­ je klÃ­ÄovÃ½!** Dejte studentÅ¯m Äas pÅ™emÃ½Å¡let
-   Na tabuli vizualizujte krok za krokem
-   PÅ™ipravte si seznam ÄÃ­sel na kartiÄkÃ¡ch - fyzickÃ© tÅ™Ã­dÄ›nÃ­!
-   **PropojenÃ­ s Model Builderem** - tento moment je dÅ¯leÅ¾itÃ½,
    zdÅ¯raznÄ›te ho!
-   **Minimum â†’ Selection Sort** - zdÅ¯raznÄ›te propojenÃ­
-   UkaÅ¾te, jak elegantnÃ­ je `sort()` po tom, co implementovali vlastnÃ­
    algoritmus
:::
