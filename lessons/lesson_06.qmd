---
title: "Lekce 6: Funkce a moduly"
subtitle: "Python pro GIS - ZnovupouÅ¾itelnÃ½ kÃ³d"
author: "VÃ¡Å¡ kurz"
date: today
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    theme: cosmo
---

# CÃ­le lekce

Po absolvovÃ¡nÃ­ tÃ©to lekce budete umÄ›t:

- Definovat vlastnÃ­ funkce pomocÃ­ `def`
- PouÅ¾Ã­vat parametry a nÃ¡vratovÃ© hodnoty
- RozumÄ›t rozdÃ­lu mezi `print()` a `return`
- PsÃ¡t dokumentaÄnÃ­ Å™etÄ›zce (docstrings)
- Organizovat kÃ³d do modulÅ¯
- Importovat a pouÅ¾Ã­vat moduly
- VytvoÅ™it vlastnÃ­ modul `math_utils.py`

**ÄŒasovÃ¡ dotace:** 90 minut

---

# 1. ProÄ funkce?

## Motivace

**VzpomeÅˆte si na pÅ™edchozÃ­ lekce:**

Napsali jste kÃ³d pro:
- Fibonacci ÄÃ­slo
- FaktoriÃ¡l
- Test prvoÄÃ­selnosti
- TÅ™Ã­dÄ›nÃ­ seznamu

**Co kdybyste tyto operace potÅ™ebovali pouÅ¾Ã­t vÃ­cekrÃ¡t?**

```python
# Fibonacci pro ÄÃ­slo 10
n = 10
a, b = 0, 1
for i in range(n):
    a, b = b, a + b
print(f"Fibonacci({n}) = {a}")

# Fibonacci pro ÄÃ­slo 20 - MUSÃME PSÃT ZNOVU!
n = 20
a, b = 0, 1
for i in range(n):
    a, b = b, a + b
print(f"Fibonacci({n}) = {a}")

# Fibonacci pro ÄÃ­slo 15 - ZASE ZNOVU!
# ...
```

**ProblÃ©m:** Opakujeme stejnÃ½ kÃ³d â†’ neefektivnÃ­, nÃ¡chylnÃ© k chybÃ¡m

## DRY princip

**DRY = Don't Repeat Yourself** (Neopakuj se)

Pokud pÃ­Å¡ete stejnÃ½ kÃ³d vÃ­cekrÃ¡t, mÄ›li byste ho **zabalit do funkce**.

::: {.callout-tip}
## Funkce = pojmenovanÃ½ kus kÃ³du

Funkce je **pojmenovanÃ½ blok kÃ³du**, kterÃ½:
- MÅ¯Å¾ete volat kdykoli
- MÅ¯Å¾e pÅ™ijÃ­mat vstupy (parametry)
- MÅ¯Å¾e vracet vÃ½stup (nÃ¡vratovou hodnotu)
- DÄ›lÃ¡ kÃ³d ÄitelnÄ›jÅ¡Ã­m a znovupouÅ¾itelnÃ½m
:::

---

# 2. Definice funkcÃ­

## ZÃ¡kladnÃ­ syntaxe

```python
def jmeno_funkce():
    # TÄ›lo funkce (odsazenÃ©)
    prikaz1
    prikaz2
```

**KlÃ­ÄovÃ© slovo:** `def` (define)  
**ZÃ¡vorky:** `()` jsou povinnÃ©  
**DvojteÄka:** `:` na konci Å™Ã¡dku  
**OdsazenÃ­:** TÄ›lo funkce je odsazenÃ© (4 mezery)

## PrvnÃ­ funkce

```python
def pozdrav():
    print("Ahoj!")
    print("VÃ­tej v kurzu Pythonu!")

# VolÃ¡nÃ­ funkce:
pozdrav()
```

**VÃ½sledek:**
```
Ahoj!
VÃ­tej v kurzu Pythonu!
```

::: {.callout-important}
## Funkci musÃ­te ZAVOLAT!

Definice funkce ji jen **vytvoÅ™Ã­**, ale **neprovede**:

```python
def pozdrav():
    print("Ahoj!")

# Nic se nevypÃ­Å¡e! Funkce jen existuje.

pozdrav()  # TEÄ se provede!
```
:::

---

# 3. Parametry funkcÃ­

## Funkce s jednÃ­m parametrem

```python
def pozdrav(jmeno):
    print(f"Ahoj, {jmeno}!")

pozdrav("Jan")     # Ahoj, Jan!
pozdrav("Marie")   # Ahoj, Marie!
```

**Parametr** = promÄ›nnÃ¡, kterÃ¡ pÅ™ijÃ­mÃ¡ hodnotu pÅ™i volÃ¡nÃ­ funkce

## Funkce s vÃ­ce parametry

```python
def secti(a, b):
    vysledek = a + b
    print(f"{a} + {b} = {vysledek}")

secti(5, 3)   # 5 + 3 = 8
secti(10, 7)  # 10 + 7 = 17
```

## Default hodnoty parametrÅ¯

MÅ¯Å¾ete nastavit **vÃ½chozÃ­ hodnotu** pro parametr:

```python
def pozdrav(jmeno, jazyk="cs"):
    if jazyk == "cs":
        print(f"Ahoj, {jmeno}!")
    elif jazyk == "en":
        print(f"Hello, {jmeno}!")

pozdrav("Jan")           # Ahoj, Jan! (pouÅ¾ije default "cs")
pozdrav("John", "en")    # Hello, John!
pozdrav("Marie", "cs")   # Ahoj, Marie!
```

---

# 4. NÃ¡vratovÃ© hodnoty - return

## ProblÃ©m s print()

```python
def secti(a, b):
    vysledek = a + b
    print(vysledek)

# MÅ¯Å¾eme vypsat vÃ½sledek:
secti(5, 3)  # 8

# Ale NEMÅ®Å½EME ho pouÅ¾Ã­t dÃ¡l:
x = secti(5, 3)  # x = None (funkce nic nevracÃ­!)
y = x + 10       # CHYBA! None + 10 nejde
```

## Å˜eÅ¡enÃ­: return

```python
def secti(a, b):
    vysledek = a + b
    return vysledek  # VrÃ¡tÃ­ hodnotu

# TeÄ MÅ®Å½EME vÃ½sledek pouÅ¾Ã­t:
x = secti(5, 3)    # x = 8
y = x + 10         # y = 18
print(f"VÃ½sledek: {y}")  # VÃ½sledek: 18
```

::: {.callout-warning}
## print() vs. return - KRITICKÃ ROZDÃL!

- **print()** - vypÃ­Å¡e na obrazovku, ale **nevracÃ­** hodnotu
- **return** - **vracÃ­** hodnotu, kterou mÅ¯Å¾ete pouÅ¾Ã­t dÃ¡l

```python
def spatne(x):
    print(x * 2)    # VypÃ­Å¡e, ale nevracÃ­

def spravne(x):
    return x * 2    # VracÃ­ hodnotu

a = spatne(5)       # VypÃ­Å¡e 10, ale a = None
b = spravne(5)      # b = 10 (mÅ¯Å¾eme pouÅ¾Ã­t dÃ¡l)
```

**Pravidlo:** Funkce by mÄ›ly **vracet** hodnoty pomocÃ­ `return`, ne je vypisovat pomocÃ­ `print()`!
:::

## return ukonÄuje funkci

```python
def je_kladne(cislo):
    if cislo > 0:
        return True  # Funkce SKONÄŒÃ zde
    return False     # Tohle se provede jen pokud cislo <= 0

print(je_kladne(5))   # True
print(je_kladne(-3))  # False
```

---

# 5. DokumentaÄnÃ­ Å™etÄ›zce (docstrings)

## Co jsou docstrings?

**Docstring** = dokumentace funkce napsanÃ¡ hned pod definicÃ­ v trojitÃ½ch uvozovkÃ¡ch.

```python
def fibonacci(n):
    """VrÃ¡tÃ­ n-tÃ½ Älen Fibonacciho posloupnosti.
    
    Args:
        n: PoÅ™adovÃ© ÄÃ­slo Älenu (int)
    
    Returns:
        n-tÃ½ Älen posloupnosti (int)
    """
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a
```

## ProÄ pouÅ¾Ã­vat docstrings?

```python
# MÅ¯Å¾ete si pÅ™eÄÃ­st dokumentaci:
help(fibonacci)
```

**VÃ½stup:**
```
Help on function fibonacci:

fibonacci(n)
    VrÃ¡tÃ­ n-tÃ½ Älen Fibonacciho posloupnosti.
    
    Args:
        n: PoÅ™adovÃ© ÄÃ­slo Älenu (int)
    
    Returns:
        n-tÃ½ Älen posloupnosti (int)
```

::: {.callout-tip}
## DobrÃ½ docstring obsahuje

1. **StruÄnÃ½ popis** - co funkce dÄ›lÃ¡
2. **Args** - jakÃ© pÅ™ijÃ­mÃ¡ parametry
3. **Returns** - co vracÃ­
4. **Raises** (volitelnÄ›) - jakÃ© mÅ¯Å¾e vyvolat chyby

NemusÃ­te psÃ¡t sloÅ¾itÃ© docstringy, ale alespoÅˆ jednoÅ™Ã¡dkovÃ½ popis je dobrÃ½!
:::

---

# 6. PÅ™epis Ãºloh jako funkcÃ­

## Fibonacci jako funkce

**PÅ¯vodnÃ­ kÃ³d:**
```python
n = int(input("KterÃ© ÄÃ­slo? "))
a, b = 0, 1
for i in range(n):
    a, b = b, a + b
print(f"{n}. Älen: {a}")
```

**Jako funkce:**
```python
def fibonacci(n):
    """VrÃ¡tÃ­ n-tÃ½ Älen Fibonacciho posloupnosti."""
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a

# PouÅ¾itÃ­:
print(f"10. Älen: {fibonacci(10)}")
print(f"20. Älen: {fibonacci(20)}")

# Nebo pro seznam ÄÃ­sel:
for i in [5, 10, 15, 20]:
    print(f"F({i}) = {fibonacci(i)}")
```

## CviÄenÃ­ 1: FaktoriÃ¡l jako funkce

PÅ™epiÅ¡te vÃ¡Å¡ kÃ³d pro faktoriÃ¡l jako funkci:

```python
def faktorial(n):
    """VrÃ¡tÃ­ faktoriÃ¡l ÄÃ­sla n."""
    # Zde doplÅˆte kÃ³d...
    
# Test:
print(faktorial(5))   # MÄ›lo by bÃ½t 120
print(faktorial(10))  # MÄ›lo by bÃ½t 3628800
```

## CviÄenÃ­ 2: Test prvoÄÃ­selnosti jako funkce

```python
def je_prvocislo(n):
    """VrÃ¡tÃ­ True, pokud je n prvoÄÃ­slo, jinak False."""
    # Zde doplÅˆte kÃ³d...
    
# Test:
print(je_prvocislo(7))   # True
print(je_prvocislo(8))   # False
print(je_prvocislo(17))  # True
```

## CviÄenÃ­ 3: Bubble Sort jako funkce

```python
def bubble_sort(seznam):
    """SeÅ™adÃ­ seznam pomocÃ­ Bubble Sort algoritmu.
    
    Args:
        seznam: Seznam ÄÃ­sel (list)
    
    Returns:
        SeÅ™azenÃ½ seznam (list)
    """
    # POZOR: MÄ›li byste vytvoÅ™it kopii!
    serazeny = seznam.copy()
    
    # Zde doplÅˆte tÅ™Ã­dÃ­cÃ­ kÃ³d...
    
    return serazeny

# Test:
cisla = [5, 2, 8, 1, 9]
serazene = bubble_sort(cisla)
print(f"PÅ¯vodnÃ­: {cisla}")
print(f"SeÅ™azenÃ©: {serazene}")
```

::: {.callout-warning}
## Pozor na Ãºpravu seznamÅ¯!

Seznamy jsou **mutable** (mÄ›nitelnÃ©). Pokud funkce upravuje seznam, mÄ›nÃ­ pÅ¯vodnÃ­:

```python
def spatne_sort(seznam):
    seznam.sort()  # MÄ›nÃ­ pÅ¯vodnÃ­ seznam!
    return seznam

cisla = [5, 2, 8]
vysledek = spatne_sort(cisla)
print(cisla)  # [2, 5, 8] - ZMÄšNÄšNO!

# LepÅ¡Ã­:
def dobre_sort(seznam):
    kopie = seznam.copy()
    kopie.sort()
    return kopie
```
:::

---

# 7. Moduly

## Co je modul?

**Modul** = Python soubor (`.py`) obsahujÃ­cÃ­ funkce, kterÃ© mÅ¯Å¾ete pouÅ¾Ã­t v jinÃ½ch programech.

**ProÄ moduly?**
- **Organizace** - rozdÄ›lenÃ­ programu do logickÃ½ch celkÅ¯
- **ZnovupouÅ¾itelnost** - jednou napÃ­Å¡ete, pouÅ¾ijete vÅ¡ude
- **SdÃ­lenÃ­** - mÅ¯Å¾ete sdÃ­let s kolegy

## VytvoÅ™enÃ­ vlastnÃ­ho modulu

### Krok 1: VytvoÅ™te soubor `math_utils.py`

```python
# math_utils.py

def fibonacci(n):
    """VrÃ¡tÃ­ n-tÃ½ Älen Fibonacciho posloupnosti."""
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a

def faktorial(n):
    """VrÃ¡tÃ­ faktoriÃ¡l ÄÃ­sla n."""
    vysledek = 1
    for i in range(1, n + 1):
        vysledek *= i
    return vysledek

def je_prvocislo(n):
    """VrÃ¡tÃ­ True, pokud je n prvoÄÃ­slo."""
    if n < 2:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

def bubble_sort(seznam):
    """SeÅ™adÃ­ seznam pomocÃ­ Bubble Sort."""
    serazeny = seznam.copy()
    for i in range(len(serazeny)):
        for j in range(len(serazeny) - 1 - i):
            if serazeny[j] > serazeny[j + 1]:
                serazeny[j], serazeny[j + 1] = serazeny[j + 1], serazeny[j]
    return serazeny
```

### Krok 2: VytvoÅ™te soubor `main.py` ve STEJNÃ‰ sloÅ¾ce

```python
# main.py

import math_utils

# TeÄ mÅ¯Å¾eme pouÅ¾Ã­vat funkce z math_utils:
n = int(input("Zadej ÄÃ­slo: "))

print(f"Fibonacci: {math_utils.fibonacci(n)}")
print(f"FaktoriÃ¡l: {math_utils.faktorial(n)}")
print(f"Je prvoÄÃ­slo: {math_utils.je_prvocislo(n)}")

cisla = [5, 2, 8, 1, 9]
print(f"SeÅ™azenÃ©: {math_utils.bubble_sort(cisla)}")
```

## ZpÅ¯soby importu

### 1. Import celÃ©ho modulu

```python
import math_utils

math_utils.fibonacci(10)
math_utils.faktorial(5)
```

### 2. Import konkrÃ©tnÃ­ch funkcÃ­

```python
from math_utils import fibonacci, faktorial

fibonacci(10)   # Bez math_utils.
faktorial(5)
```

### 3. Import s aliasem

```python
import math_utils as mu

mu.fibonacci(10)
mu.faktorial(5)
```

### 4. Import vÅ¡eho (NEDOPORUÄŒENO!)

```python
from math_utils import *

fibonacci(10)  # Funguje, ale nenÃ­ jasnÃ©, odkud funkce pochÃ¡zÃ­
```

::: {.callout-tip}
## DoporuÄenÃ­

- Pro **vlastnÃ­ moduly**: `import math_utils` (jasnÃ©, odkud funkce pochÃ¡zÃ­)
- Pro **specifickÃ© funkce**: `from math_utils import fibonacci` (kratÅ¡Ã­ kÃ³d)
- **Nikdy** nepouÅ¾Ã­vejte `import *` - nenÃ­ jasnÃ©, co importujete!
:::

## VestavÄ›nÃ© moduly

Python mÃ¡ mnoho **vestavÄ›nÃ½ch modulÅ¯**, kterÃ© mÅ¯Å¾ete rovnou pouÅ¾Ã­t:

### Modul `math`

```python
import math

print(math.sqrt(16))      # 4.0 - odmocnina
print(math.pi)            # 3.14159... - ÄÃ­slo Ï€
print(math.ceil(3.2))     # 4 - zaokrouhlenÃ­ nahoru
print(math.floor(3.8))    # 3 - zaokrouhlenÃ­ dolÅ¯
```

### Modul `random`

```python
import random

print(random.randint(1, 10))        # NÃ¡hodnÃ© ÄÃ­slo 1-10
print(random.choice([1, 2, 3, 4]))  # NÃ¡hodnÃ½ prvek ze seznamu
```

### Modul `os` (operaÄnÃ­ systÃ©m)

```python
import os

print(os.getcwd())           # AktuÃ¡lnÃ­ sloÅ¾ka
print(os.listdir('.'))       # Seznam souborÅ¯
```

### Modul `csv` (prÃ¡ce s CSV)

```python
import csv

# Budeme pouÅ¾Ã­vat pÅ™Ã­Å¡tÃ­ lekci!
```

## Preview: import arcpy

::: {.callout-note}
## PÅ™ipravujeme se na ArcPy!

V pÅ™Ã­Å¡tÃ­ch tÃ½dnech budete psÃ¡t:

```python
import arcpy

# Funkce z ArcPy modulu:
arcpy.Buffer_analysis(...)
arcpy.Clip_analysis(...)
arcpy.management.CreateFeatureclass(...)
```

**VidÃ­te?** ArcPy je jen dalÅ¡Ã­ modul! Funguje ÃºplnÄ› stejnÄ› jako `math_utils`.
:::

---

# 8. Struktura projektu

## IdeÃ¡lnÃ­ organizace

```
muj_projekt/
â”‚
â”œâ”€â”€ main.py              # HlavnÃ­ program
â”œâ”€â”€ math_utils.py        # MatematickÃ© funkce
â”‚
â””â”€â”€ data/
    â””â”€â”€ data.csv         # Data (pÅ™Ã­Å¡tÃ­ lekce)
```

**main.py:**
```python
import math_utils

# HlavnÃ­ program...
```

**math_utils.py:**
```python
def fibonacci(n):
    # ...

def faktorial(n):
    # ...
```

::: {.callout-important}
## Soubory musÃ­ bÃ½t ve stejnÃ© sloÅ¾ce!

Aby `import math_utils` fungoval, musÃ­ bÃ½t `math_utils.py` ve **stejnÃ© sloÅ¾ce** jako `main.py`, nebo v Pythonem rozpoznanÃ© cestÄ›.
:::

---

# 9. PraktickÃ¡ Ãºloha

## ZadÃ¡nÃ­

VytvoÅ™te kompletnÃ­ projekt:

### 1. Soubor `math_utils.py`

Obsahuje funkce:
- `fibonacci(n)`
- `faktorial(n)`
- `je_prvocislo(n)`
- `bubble_sort(seznam)`

VÅ¡echny funkce majÃ­ docstringy!

### 2. Soubor `main.py`

Program, kterÃ½:
1. NaÄte ÄÃ­slo N od uÅ¾ivatele
2. VypoÄÃ­tÃ¡ a vypÃ­Å¡e:
   - N-tÃ½ Fibonacci ÄÃ­slo
   - FaktoriÃ¡l N
   - Zda je N prvoÄÃ­slo
3. VytvoÅ™Ã­ seznam prvnÃ­ch 10 Fibonacci ÄÃ­sel
4. SeÅ™adÃ­ tento seznam (aÄkoli uÅ¾ je seÅ™azenÃ½ ğŸ˜Š)
5. VypÃ­Å¡e vÃ½sledek

**Kostra:**

```python
# main.py
import math_utils

n = int(input("Zadej ÄÃ­slo: "))

# ZÃ¡kladnÃ­ vÃ½poÄty
print(f"Fibonacci({n}) = {math_utils.fibonacci(n)}")
print(f"FaktoriÃ¡l({n}) = {math_utils.faktorial(n)}")

if math_utils.je_prvocislo(n):
    print(f"{n} je prvoÄÃ­slo")
else:
    print(f"{n} nenÃ­ prvoÄÃ­slo")

# Seznam Fibonacci ÄÃ­sel
fibonacci_cisla = []
for i in range(10):
    fibonacci_cisla.append(math_utils.fibonacci(i))

print(f"\nPrvnÃ­ch 10 Fibonacci ÄÃ­sel: {fibonacci_cisla}")

# SeÅ™azenÃ­ (uÅ¾ je seÅ™azenÃ½, ale ukÃ¡Å¾eme funkci)
serazeny = math_utils.bubble_sort(fibonacci_cisla)
print(f"SeÅ™azenÃ½ seznam: {serazeny}")
```

---

# 10. ShrnutÃ­

## Co jsme se nauÄili

âœ… **Definice funkcÃ­** pomocÃ­ `def`  
âœ… **Parametry** - vstupy do funkce  
âœ… **return** - nÃ¡vratovÃ© hodnoty  
âœ… **RozdÃ­l print() vs. return** - klÃ­ÄovÃ© pro pochopenÃ­!  
âœ… **Docstrings** - dokumentace funkcÃ­  
âœ… **Moduly** - organizace kÃ³du do souborÅ¯  
âœ… **import** - pouÅ¾itÃ­ modulÅ¯  
âœ… **VestavÄ›nÃ© moduly** - math, random, os, csv  
âœ… **Preview ArcPy** - import arcpy funguje stejnÄ›!  

## Co bude pÅ™Ã­Å¡tÄ›?

V pÅ™Ã­Å¡tÃ­ lekci:

- **ÄŒtenÃ­ textovÃ½ch souborÅ¯** - `open()`, `read()`, `readlines()`
- **ZÃ¡pis do souborÅ¯** - vytvÃ¡Å™enÃ­ novÃ½ch souborÅ¯
- **ZpracovÃ¡nÃ­ jednoduchÃ½ch dat** - napÅ™. seznam mÄ›st s populacÃ­
- **PouÅ¾itÃ­ funkcÃ­** z `math_utils` pro zpracovÃ¡nÃ­ dat

---

# 11. DomÃ¡cÃ­ Ãºkol

## Varianta A (zÃ¡kladnÃ­)

1. **DokonÄete math_utils.py** s vÅ¡emi ÄtyÅ™mi funkcemi
2. **VytvoÅ™te main.py**, kterÃ½ pouÅ¾Ã­vÃ¡ vÅ¡echny funkce
3. **PÅ™idejte docstringy** ke vÅ¡em funkcÃ­m

## Varianta B (pokroÄilÃ¡)

1. **RozÅ¡iÅ™te math_utils.py** o novÃ© funkce:
   - `selection_sort(seznam)` - druhÃ½ tÅ™Ã­dÃ­cÃ­ algoritmus
   - `najdi_prvocisla(n)` - seznam vÅ¡ech prvoÄÃ­sel do n
   - `n_te_prvocislo(n)` - najde n-tÃ© prvoÄÃ­slo

2. **Otestujte** vÅ¡echny novÃ© funkce v `main.py`

## Varianta C (vÃ½zva)

VytvoÅ™te modul `statistika.py` s funkcemi:

```python
def prumer(seznam):
    """VrÃ¡tÃ­ prÅ¯mÄ›r ÄÃ­sel v seznamu."""
    # ...

def median(seznam):
    """VrÃ¡tÃ­ mediÃ¡n seznamu (prostÅ™ednÃ­ hodnota)."""
    # ...

def maximum(seznam):
    """VrÃ¡tÃ­ maximum ze seznamu."""
    # ...

def minimum(seznam):
    """VrÃ¡tÃ­ minimum ze seznamu."""
    # ...
```

**Bonus:** MÅ¯Å¾ete pouÅ¾Ã­t `math_utils.bubble_sort()` v `median()`!

---

# 12. Cheatsheet

```python
# === DEFINICE FUNKCE ===
def jmeno_funkce(parametr1, parametr2):
    """DokumentaÄnÃ­ Å™etÄ›zec."""
    # TÄ›lo funkce
    return vysledek

# === VOLÃNÃ FUNKCE ===
vysledek = jmeno_funkce(hodnota1, hodnota2)

# === DEFAULT PARAMETRY ===
def pozdrav(jmeno, jazyk="cs"):
    # ...

pozdrav("Jan")          # PouÅ¾ije default
pozdrav("John", "en")   # PÅ™epÃ­Å¡e default

# === DOCSTRING ===
def funkce(x):
    """StruÄnÃ½ popis.
    
    Args:
        x: Popis parametru
    
    Returns:
        Popis nÃ¡vratovÃ© hodnoty
    """
    return x * 2

# === MODULY ===
# VytvoÅ™enÃ­: uloÅ¾te funkce do souboru.py

# Import celÃ©ho modulu:
import math_utils
math_utils.fibonacci(10)

# Import konkrÃ©tnÃ­ funkce:
from math_utils import fibonacci
fibonacci(10)

# Import s aliasem:
import math_utils as mu
mu.fibonacci(10)

# === VESTAVÄšNÃ‰ MODULY ===
import math
math.sqrt(16)
math.pi

import random
random.randint(1, 10)

import os
os.getcwd()

# === PRINT vs RETURN ===
def spatne(x):
    print(x * 2)    # VypÃ­Å¡e, ale nevracÃ­!
    
def spravne(x):
    return x * 2    # VracÃ­ hodnotu!

a = spatne(5)       # a = None
b = spravne(5)      # b = 10
```

---

# 13. PoznÃ¡mky pro vyuÄujÃ­cÃ­ho

## BÄ›Å¾nÃ© chyby studentÅ¯

```python
# 1. ZapomÃ­najÃ­ return
def secti(a, b):
    vysledek = a + b
    # ZapomnÄ›li return!

x = secti(5, 3)  # x = None

# 2. PouÅ¾Ã­vajÃ­ print mÃ­sto return
def secti(a, b):
    print(a + b)  # Å patnÄ›!
    
vysledek = secti(5, 3) + 10  # Chyba!

# 3. VolajÃ­ funkci s def
def fibonacci(n)  # ZapomnÄ›li dvojteÄku!

# 4. ZapomÃ­najÃ­ zÃ¡vorky pÅ™i volÃ¡nÃ­
fibonacci  # Toto je funkce samotnÃ¡, ne vÃ½sledek!
fibonacci(10)  # SprÃ¡vnÄ› - volÃ¡nÃ­

# 5. Å patnÃ½ import
import math_utils
fibonacci(10)  # Chyba - musÃ­ bÃ½t math_utils.fibonacci(10)

# Nebo:
from math_utils import fibonacci
math_utils.fibonacci(10)  # Chyba - uÅ¾ nenÃ­ potÅ™eba math_utils.

# 6. Soubory v jinÃ½ch sloÅ¾kÃ¡ch
# main.py je v C:\Users\Jan\projekt\
# math_utils.py je v C:\Users\Jan\Desktop\
# import math_utils  # NEFUNGUJE!
```

## ÄŒasovÃ½ plÃ¡n (90 min)

| ÄŒas | Obsah |
|-----|-------|
| 0-10 min | Motivace - proÄ funkce? DRY princip |
| 10-30 min | Definice funkcÃ­, parametry, return |
| 30-40 min | print() vs. return - DÅ®LEÅ½ITÃ‰! |
| 40-50 min | Docstrings, pÅ™epis Fibonacci/faktoriÃ¡l |
| 50-60 min | CviÄenÃ­ - pÅ™epis prvoÄÃ­sla a tÅ™Ã­dÄ›nÃ­ |
| 60-75 min | Moduly - vytvoÅ™enÃ­ math_utils.py |
| 75-85 min | Import, pouÅ¾itÃ­ v main.py |
| 85-90 min | Preview ArcPy, zadÃ¡nÃ­ Ãºkolu |

## KlÃ­ÄovÃ© momenty

### print() vs. return (30-40 min):
- **NEJDÅ®LEÅ½ITÄšJÅ Ã KONCEPT** v tÃ©to lekci!
- Studenti Äasto nerozumÃ­ rozdÃ­lu
- UkÃ¡zat konkrÃ©tnÃ­ pÅ™Ã­klad, kde print() selhÃ¡vÃ¡:

```python
def spatne(x):
    print(x * 2)

vysledek = spatne(5) + 10  # TypeError!
```

- VysvÄ›tlit: "print je pro LIDI, return je pro PROGRAM"

### Moduly (60-85 min):
- Prakticky vytvoÅ™it math_utils.py spoleÄnÄ›
- UkÃ¡zat, Å¾e musÃ­ bÃ½t ve stejnÃ© sloÅ¾ce
- Otestovat import v main.py
- ZdÅ¯raznit: "ArcPy bude fungovat ÃºplnÄ› stejnÄ›!"

### Docstrings (40-50 min):
- NemusÃ­ bÃ½t dokonalÃ©, ale alespoÅˆ jednoÅ™Ã¡dkovÃ©
- UkÃ¡zat `help(funkce)`
- ZdÅ¯raznit, Å¾e v praxi je dokumentace dÅ¯leÅ¾itÃ¡

## Rizika

1. **print() vs. return mÅ¯Å¾e bÃ½t matoucÃ­ (mÅ¯Å¾e trvat 15 min)**
   - Å˜eÅ¡enÃ­: VÄ›novat tomu dostatek Äasu, ukÃ¡zat konkrÃ©tnÃ­ pÅ™Ã­klady
   - Nechat studenty experimentovat

2. **Import nemusÃ­ fungovat (chyby s cestami)**
   - Å˜eÅ¡enÃ­: ZdÅ¯raznit, Å¾e soubory musÃ­ bÃ½t ve stejnÃ© sloÅ¾ce
   - MÃ­t pÅ™ipravenÃ© screenshoty struktury sloÅ¾ek

3. **Studenti budou rÅ¯znÄ› rychlÃ­ s pÅ™episem funkcÃ­**
   - Å˜eÅ¡enÃ­: RychlejÅ¡Ã­ pomÃ¡hajÃ­ pomalejÅ¡Ã­m
   - MÅ¯Å¾ete poskytnout kostru math_utils.py

## Tipy

- **print() vs. return je nejÄastÄ›jÅ¡Ã­ problÃ©m** - vÄ›nujte tomu extra Äas!
- Na konci vÅ¾dy zdÅ¯raznÄ›te: "ArcPy je jen modul - budete psÃ¡t `import arcpy` stejnÄ› jako `import math_utils`"
- UkaÅ¾te `help()` funkci - je uÅ¾iteÄnÃ¡ pro ÄtenÃ­ dokumentace
- VytvoÅ™te math_utils.py spoleÄnÄ› na projektoru - aÅ¥ vidÃ­ celÃ½ proces
- Nechte je otestovat vÅ¡echny funkce v main.py

## MateriÃ¡ly k pÅ™Ã­pravÄ›

- [ ] PÅ™ipravit kostru math_utils.py (pro pomalÃ© studenty)
- [ ] UkÃ¡zkovÃ¡ main.py s pouÅ¾itÃ­m vÅ¡ech funkcÃ­
- [ ] Diagram struktury projektu (sloÅ¾ky a soubory)
- [ ] Cheatsheet pro rÅ¯znÃ© zpÅ¯soby importu