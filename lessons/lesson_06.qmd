---
title: "Lekce 6: Funkce a moduly"
subtitle: "Python pro GIS - Znovupoužitelný kód"
author: "Váš kurz"
date: today
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    theme: cosmo
---

# Cíle lekce

Po absolvování této lekce budete umět:

- Definovat vlastní funkce pomocí `def`
- Používat parametry a návratové hodnoty
- Rozumět rozdílu mezi `print()` a `return`
- Psát dokumentační řetězce (docstrings)
- Organizovat kód do modulů
- Importovat a používat moduly
- Vytvořit vlastní modul `math_utils.py`

**Časová dotace:** 90 minut

---

# 1. Proč funkce?

## Motivace

**Vzpomeňte si na předchozí lekce:**

Napsali jste kód pro:
- Fibonacci číslo
- Faktoriál
- Test prvočíselnosti
- Třídění seznamu

**Co kdybyste tyto operace potřebovali použít vícekrát?**

```python
# Fibonacci pro číslo 10
n = 10
a, b = 0, 1
for i in range(n):
    a, b = b, a + b
print(f"Fibonacci({n}) = {a}")

# Fibonacci pro číslo 20 - MUSÍME PSÁT ZNOVU!
n = 20
a, b = 0, 1
for i in range(n):
    a, b = b, a + b
print(f"Fibonacci({n}) = {a}")

# Fibonacci pro číslo 15 - ZASE ZNOVU!
# ...
```

**Problém:** Opakujeme stejný kód → neefektivní, náchylné k chybám

## DRY princip

**DRY = Don't Repeat Yourself** (Neopakuj se)

Pokud píšete stejný kód vícekrát, měli byste ho **zabalit do funkce**.

::: {.callout-tip}
## Funkce = pojmenovaný kus kódu

Funkce je **pojmenovaný blok kódu**, který:
- Můžete volat kdykoli
- Může přijímat vstupy (parametry)
- Může vracet výstup (návratovou hodnotu)
- Dělá kód čitelnějším a znovupoužitelným
:::

---

# 2. Definice funkcí

## Základní syntaxe

```python
def jmeno_funkce():
    # Tělo funkce (odsazené)
    prikaz1
    prikaz2
```

**Klíčové slovo:** `def` (define)  
**Závorky:** `()` jsou povinné  
**Dvojtečka:** `:` na konci řádku  
**Odsazení:** Tělo funkce je odsazené (4 mezery)

## První funkce

```python
def pozdrav():
    print("Ahoj!")
    print("Vítej v kurzu Pythonu!")

# Volání funkce:
pozdrav()
```

**Výsledek:**
```
Ahoj!
Vítej v kurzu Pythonu!
```

::: {.callout-important}
## Funkci musíte ZAVOLAT!

Definice funkce ji jen **vytvoří**, ale **neprovede**:

```python
def pozdrav():
    print("Ahoj!")

# Nic se nevypíše! Funkce jen existuje.

pozdrav()  # TEĎ se provede!
```
:::

---

# 3. Parametry funkcí

## Funkce s jedním parametrem

```python
def pozdrav(jmeno):
    print(f"Ahoj, {jmeno}!")

pozdrav("Jan")     # Ahoj, Jan!
pozdrav("Marie")   # Ahoj, Marie!
```

**Parametr** = proměnná, která přijímá hodnotu při volání funkce

## Funkce s více parametry

```python
def secti(a, b):
    vysledek = a + b
    print(f"{a} + {b} = {vysledek}")

secti(5, 3)   # 5 + 3 = 8
secti(10, 7)  # 10 + 7 = 17
```

## Default hodnoty parametrů

Můžete nastavit **výchozí hodnotu** pro parametr:

```python
def pozdrav(jmeno, jazyk="cs"):
    if jazyk == "cs":
        print(f"Ahoj, {jmeno}!")
    elif jazyk == "en":
        print(f"Hello, {jmeno}!")

pozdrav("Jan")           # Ahoj, Jan! (použije default "cs")
pozdrav("John", "en")    # Hello, John!
pozdrav("Marie", "cs")   # Ahoj, Marie!
```

---

# 4. Návratové hodnoty - return

## Problém s print()

```python
def secti(a, b):
    vysledek = a + b
    print(vysledek)

# Můžeme vypsat výsledek:
secti(5, 3)  # 8

# Ale NEMŮŽEME ho použít dál:
x = secti(5, 3)  # x = None (funkce nic nevrací!)
y = x + 10       # CHYBA! None + 10 nejde
```

## Řešení: return

```python
def secti(a, b):
    vysledek = a + b
    return vysledek  # Vrátí hodnotu

# Teď MŮŽEME výsledek použít:
x = secti(5, 3)    # x = 8
y = x + 10         # y = 18
print(f"Výsledek: {y}")  # Výsledek: 18
```

::: {.callout-warning}
## print() vs. return - KRITICKÝ ROZDÍL!

- **print()** - vypíše na obrazovku, ale **nevrací** hodnotu
- **return** - **vrací** hodnotu, kterou můžete použít dál

```python
def spatne(x):
    print(x * 2)    # Vypíše, ale nevrací

def spravne(x):
    return x * 2    # Vrací hodnotu

a = spatne(5)       # Vypíše 10, ale a = None
b = spravne(5)      # b = 10 (můžeme použít dál)
```

**Pravidlo:** Funkce by měly **vracet** hodnoty pomocí `return`, ne je vypisovat pomocí `print()`!
:::

## return ukončuje funkci

```python
def je_kladne(cislo):
    if cislo > 0:
        return True  # Funkce SKONČÍ zde
    return False     # Tohle se provede jen pokud cislo <= 0

print(je_kladne(5))   # True
print(je_kladne(-3))  # False
```

---

# 5. Dokumentační řetězce (docstrings)

## Co jsou docstrings?

**Docstring** = dokumentace funkce napsaná hned pod definicí v trojitých uvozovkách.

```python
def fibonacci(n):
    """Vrátí n-tý člen Fibonacciho posloupnosti.
    
    Args:
        n: Pořadové číslo členu (int)
    
    Returns:
        n-tý člen posloupnosti (int)
    """
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a
```

## Proč používat docstrings?

```python
# Můžete si přečíst dokumentaci:
help(fibonacci)
```

**Výstup:**
```
Help on function fibonacci:

fibonacci(n)
    Vrátí n-tý člen Fibonacciho posloupnosti.
    
    Args:
        n: Pořadové číslo členu (int)
    
    Returns:
        n-tý člen posloupnosti (int)
```

::: {.callout-tip}
## Dobrý docstring obsahuje

1. **Stručný popis** - co funkce dělá
2. **Args** - jaké přijímá parametry
3. **Returns** - co vrací
4. **Raises** (volitelně) - jaké může vyvolat chyby

Nemusíte psát složité docstringy, ale alespoň jednořádkový popis je dobrý!
:::

---

# 6. Přepis úloh jako funkcí

## Fibonacci jako funkce

**Původní kód:**
```python
n = int(input("Které číslo? "))
a, b = 0, 1
for i in range(n):
    a, b = b, a + b
print(f"{n}. člen: {a}")
```

**Jako funkce:**
```python
def fibonacci(n):
    """Vrátí n-tý člen Fibonacciho posloupnosti."""
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a

# Použití:
print(f"10. člen: {fibonacci(10)}")
print(f"20. člen: {fibonacci(20)}")

# Nebo pro seznam čísel:
for i in [5, 10, 15, 20]:
    print(f"F({i}) = {fibonacci(i)}")
```

## Cvičení 1: Faktoriál jako funkce

Přepište váš kód pro faktoriál jako funkci:

```python
def faktorial(n):
    """Vrátí faktoriál čísla n."""
    # Zde doplňte kód...
    
# Test:
print(faktorial(5))   # Mělo by být 120
print(faktorial(10))  # Mělo by být 3628800
```

## Cvičení 2: Test prvočíselnosti jako funkce

```python
def je_prvocislo(n):
    """Vrátí True, pokud je n prvočíslo, jinak False."""
    # Zde doplňte kód...
    
# Test:
print(je_prvocislo(7))   # True
print(je_prvocislo(8))   # False
print(je_prvocislo(17))  # True
```

## Cvičení 3: Bubble Sort jako funkce

```python
def bubble_sort(seznam):
    """Seřadí seznam pomocí Bubble Sort algoritmu.
    
    Args:
        seznam: Seznam čísel (list)
    
    Returns:
        Seřazený seznam (list)
    """
    # POZOR: Měli byste vytvořit kopii!
    serazeny = seznam.copy()
    
    # Zde doplňte třídící kód...
    
    return serazeny

# Test:
cisla = [5, 2, 8, 1, 9]
serazene = bubble_sort(cisla)
print(f"Původní: {cisla}")
print(f"Seřazené: {serazene}")
```

::: {.callout-warning}
## Pozor na úpravu seznamů!

Seznamy jsou **mutable** (měnitelné). Pokud funkce upravuje seznam, mění původní:

```python
def spatne_sort(seznam):
    seznam.sort()  # Mění původní seznam!
    return seznam

cisla = [5, 2, 8]
vysledek = spatne_sort(cisla)
print(cisla)  # [2, 5, 8] - ZMĚNĚNO!

# Lepší:
def dobre_sort(seznam):
    kopie = seznam.copy()
    kopie.sort()
    return kopie
```
:::

---

# 7. Moduly

## Co je modul?

**Modul** = Python soubor (`.py`) obsahující funkce, které můžete použít v jiných programech.

**Proč moduly?**
- **Organizace** - rozdělení programu do logických celků
- **Znovupoužitelnost** - jednou napíšete, použijete všude
- **Sdílení** - můžete sdílet s kolegy

## Vytvoření vlastního modulu

### Krok 1: Vytvořte soubor `math_utils.py`

```python
# math_utils.py

def fibonacci(n):
    """Vrátí n-tý člen Fibonacciho posloupnosti."""
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a

def faktorial(n):
    """Vrátí faktoriál čísla n."""
    vysledek = 1
    for i in range(1, n + 1):
        vysledek *= i
    return vysledek

def je_prvocislo(n):
    """Vrátí True, pokud je n prvočíslo."""
    if n < 2:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

def bubble_sort(seznam):
    """Seřadí seznam pomocí Bubble Sort."""
    serazeny = seznam.copy()
    for i in range(len(serazeny)):
        for j in range(len(serazeny) - 1 - i):
            if serazeny[j] > serazeny[j + 1]:
                serazeny[j], serazeny[j + 1] = serazeny[j + 1], serazeny[j]
    return serazeny
```

### Krok 2: Vytvořte soubor `main.py` ve STEJNÉ složce

```python
# main.py

import math_utils

# Teď můžeme používat funkce z math_utils:
n = int(input("Zadej číslo: "))

print(f"Fibonacci: {math_utils.fibonacci(n)}")
print(f"Faktoriál: {math_utils.faktorial(n)}")
print(f"Je prvočíslo: {math_utils.je_prvocislo(n)}")

cisla = [5, 2, 8, 1, 9]
print(f"Seřazené: {math_utils.bubble_sort(cisla)}")
```

## Způsoby importu

### 1. Import celého modulu

```python
import math_utils

math_utils.fibonacci(10)
math_utils.faktorial(5)
```

### 2. Import konkrétních funkcí

```python
from math_utils import fibonacci, faktorial

fibonacci(10)   # Bez math_utils.
faktorial(5)
```

### 3. Import s aliasem

```python
import math_utils as mu

mu.fibonacci(10)
mu.faktorial(5)
```

### 4. Import všeho (NEDOPORUČENO!)

```python
from math_utils import *

fibonacci(10)  # Funguje, ale není jasné, odkud funkce pochází
```

::: {.callout-tip}
## Doporučení

- Pro **vlastní moduly**: `import math_utils` (jasné, odkud funkce pochází)
- Pro **specifické funkce**: `from math_utils import fibonacci` (kratší kód)
- **Nikdy** nepoužívejte `import *` - není jasné, co importujete!
:::

## Vestavěné moduly

Python má mnoho **vestavěných modulů**, které můžete rovnou použít:

### Modul `math`

```python
import math

print(math.sqrt(16))      # 4.0 - odmocnina
print(math.pi)            # 3.14159... - číslo π
print(math.ceil(3.2))     # 4 - zaokrouhlení nahoru
print(math.floor(3.8))    # 3 - zaokrouhlení dolů
```

### Modul `random`

```python
import random

print(random.randint(1, 10))        # Náhodné číslo 1-10
print(random.choice([1, 2, 3, 4]))  # Náhodný prvek ze seznamu
```

### Modul `os` (operační systém)

```python
import os

print(os.getcwd())           # Aktuální složka
print(os.listdir('.'))       # Seznam souborů
```

### Modul `csv` (práce s CSV)

```python
import csv

# Budeme používat příští lekci!
```

## Preview: import arcpy

::: {.callout-note}
## Připravujeme se na ArcPy!

V příštích týdnech budete psát:

```python
import arcpy

# Funkce z ArcPy modulu:
arcpy.Buffer_analysis(...)
arcpy.Clip_analysis(...)
arcpy.management.CreateFeatureclass(...)
```

**Vidíte?** ArcPy je jen další modul! Funguje úplně stejně jako `math_utils`.
:::

---

# 8. Struktura projektu

## Ideální organizace

```
muj_projekt/
│
├── main.py              # Hlavní program
├── math_utils.py        # Matematické funkce
│
└── data/
    └── data.csv         # Data (příští lekce)
```

**main.py:**
```python
import math_utils

# Hlavní program...
```

**math_utils.py:**
```python
def fibonacci(n):
    # ...

def faktorial(n):
    # ...
```

::: {.callout-important}
## Soubory musí být ve stejné složce!

Aby `import math_utils` fungoval, musí být `math_utils.py` ve **stejné složce** jako `main.py`, nebo v Pythonem rozpoznané cestě.
:::

---

# 9. Praktická úloha

## Zadání

Vytvořte kompletní projekt:

### 1. Soubor `math_utils.py`

Obsahuje funkce:
- `fibonacci(n)`
- `faktorial(n)`
- `je_prvocislo(n)`
- `bubble_sort(seznam)`

Všechny funkce mají docstringy!

### 2. Soubor `main.py`

Program, který:
1. Načte číslo N od uživatele
2. Vypočítá a vypíše:
   - N-tý Fibonacci číslo
   - Faktoriál N
   - Zda je N prvočíslo
3. Vytvoří seznam prvních 10 Fibonacci čísel
4. Seřadí tento seznam (ačkoli už je seřazený 😊)
5. Vypíše výsledek

**Kostra:**

```python
# main.py
import math_utils

n = int(input("Zadej číslo: "))

# Základní výpočty
print(f"Fibonacci({n}) = {math_utils.fibonacci(n)}")
print(f"Faktoriál({n}) = {math_utils.faktorial(n)}")

if math_utils.je_prvocislo(n):
    print(f"{n} je prvočíslo")
else:
    print(f"{n} není prvočíslo")

# Seznam Fibonacci čísel
fibonacci_cisla = []
for i in range(10):
    fibonacci_cisla.append(math_utils.fibonacci(i))

print(f"\nPrvních 10 Fibonacci čísel: {fibonacci_cisla}")

# Seřazení (už je seřazený, ale ukážeme funkci)
serazeny = math_utils.bubble_sort(fibonacci_cisla)
print(f"Seřazený seznam: {serazeny}")
```

---

# 10. Shrnutí

## Co jsme se naučili

✅ **Definice funkcí** pomocí `def`  
✅ **Parametry** - vstupy do funkce  
✅ **return** - návratové hodnoty  
✅ **Rozdíl print() vs. return** - klíčové pro pochopení!  
✅ **Docstrings** - dokumentace funkcí  
✅ **Moduly** - organizace kódu do souborů  
✅ **import** - použití modulů  
✅ **Vestavěné moduly** - math, random, os, csv  
✅ **Preview ArcPy** - import arcpy funguje stejně!  

## Co bude příště?

V příští lekci:

- **Čtení textových souborů** - `open()`, `read()`, `readlines()`
- **Zápis do souborů** - vytváření nových souborů
- **Zpracování jednoduchých dat** - např. seznam měst s populací
- **Použití funkcí** z `math_utils` pro zpracování dat

---

# 11. Domácí úkol

## Varianta A (základní)

1. **Dokončete math_utils.py** s všemi čtyřmi funkcemi
2. **Vytvořte main.py**, který používá všechny funkce
3. **Přidejte docstringy** ke všem funkcím

## Varianta B (pokročilá)

1. **Rozšiřte math_utils.py** o nové funkce:
   - `selection_sort(seznam)` - druhý třídící algoritmus
   - `najdi_prvocisla(n)` - seznam všech prvočísel do n
   - `n_te_prvocislo(n)` - najde n-té prvočíslo

2. **Otestujte** všechny nové funkce v `main.py`

## Varianta C (výzva)

Vytvořte modul `statistika.py` s funkcemi:

```python
def prumer(seznam):
    """Vrátí průměr čísel v seznamu."""
    # ...

def median(seznam):
    """Vrátí medián seznamu (prostřední hodnota)."""
    # ...

def maximum(seznam):
    """Vrátí maximum ze seznamu."""
    # ...

def minimum(seznam):
    """Vrátí minimum ze seznamu."""
    # ...
```

**Bonus:** Můžete použít `math_utils.bubble_sort()` v `median()`!

---

# 12. Cheatsheet

```python
# === DEFINICE FUNKCE ===
def jmeno_funkce(parametr1, parametr2):
    """Dokumentační řetězec."""
    # Tělo funkce
    return vysledek

# === VOLÁNÍ FUNKCE ===
vysledek = jmeno_funkce(hodnota1, hodnota2)

# === DEFAULT PARAMETRY ===
def pozdrav(jmeno, jazyk="cs"):
    # ...

pozdrav("Jan")          # Použije default
pozdrav("John", "en")   # Přepíše default

# === DOCSTRING ===
def funkce(x):
    """Stručný popis.
    
    Args:
        x: Popis parametru
    
    Returns:
        Popis návratové hodnoty
    """
    return x * 2

# === MODULY ===
# Vytvoření: uložte funkce do souboru.py

# Import celého modulu:
import math_utils
math_utils.fibonacci(10)

# Import konkrétní funkce:
from math_utils import fibonacci
fibonacci(10)

# Import s aliasem:
import math_utils as mu
mu.fibonacci(10)

# === VESTAVĚNÉ MODULY ===
import math
math.sqrt(16)
math.pi

import random
random.randint(1, 10)

import os
os.getcwd()

# === PRINT vs RETURN ===
def spatne(x):
    print(x * 2)    # Vypíše, ale nevrací!
    
def spravne(x):
    return x * 2    # Vrací hodnotu!

a = spatne(5)       # a = None
b = spravne(5)      # b = 10
```

---

# 13. Poznámky pro vyučujícího

## Běžné chyby studentů

```python
# 1. Zapomínají return
def secti(a, b):
    vysledek = a + b
    # Zapomněli return!

x = secti(5, 3)  # x = None

# 2. Používají print místo return
def secti(a, b):
    print(a + b)  # Špatně!
    
vysledek = secti(5, 3) + 10  # Chyba!

# 3. Volají funkci s def
def fibonacci(n)  # Zapomněli dvojtečku!

# 4. Zapomínají závorky při volání
fibonacci  # Toto je funkce samotná, ne výsledek!
fibonacci(10)  # Správně - volání

# 5. Špatný import
import math_utils
fibonacci(10)  # Chyba - musí být math_utils.fibonacci(10)

# Nebo:
from math_utils import fibonacci
math_utils.fibonacci(10)  # Chyba - už není potřeba math_utils.

# 6. Soubory v jiných složkách
# main.py je v C:\Users\Jan\projekt\
# math_utils.py je v C:\Users\Jan\Desktop\
# import math_utils  # NEFUNGUJE!
```

## Časový plán (90 min)

| Čas | Obsah |
|-----|-------|
| 0-10 min | Motivace - proč funkce? DRY princip |
| 10-30 min | Definice funkcí, parametry, return |
| 30-40 min | print() vs. return - DŮLEŽITÉ! |
| 40-50 min | Docstrings, přepis Fibonacci/faktoriál |
| 50-60 min | Cvičení - přepis prvočísla a třídění |
| 60-75 min | Moduly - vytvoření math_utils.py |
| 75-85 min | Import, použití v main.py |
| 85-90 min | Preview ArcPy, zadání úkolu |

## Klíčové momenty

### print() vs. return (30-40 min):
- **NEJDŮLEŽITĚJŠÍ KONCEPT** v této lekci!
- Studenti často nerozumí rozdílu
- Ukázat konkrétní příklad, kde print() selhává:

```python
def spatne(x):
    print(x * 2)

vysledek = spatne(5) + 10  # TypeError!
```

- Vysvětlit: "print je pro LIDI, return je pro PROGRAM"

### Moduly (60-85 min):
- Prakticky vytvořit math_utils.py společně
- Ukázat, že musí být ve stejné složce
- Otestovat import v main.py
- Zdůraznit: "ArcPy bude fungovat úplně stejně!"

### Docstrings (40-50 min):
- Nemusí být dokonalé, ale alespoň jednořádkové
- Ukázat `help(funkce)`
- Zdůraznit, že v praxi je dokumentace důležitá

## Rizika

1. **print() vs. return může být matoucí (může trvat 15 min)**
   - Řešení: Věnovat tomu dostatek času, ukázat konkrétní příklady
   - Nechat studenty experimentovat

2. **Import nemusí fungovat (chyby s cestami)**
   - Řešení: Zdůraznit, že soubory musí být ve stejné složce
   - Mít připravené screenshoty struktury složek

3. **Studenti budou různě rychlí s přepisem funkcí**
   - Řešení: Rychlejší pomáhají pomalejším
   - Můžete poskytnout kostru math_utils.py

## Tipy

- **print() vs. return je nejčastější problém** - věnujte tomu extra čas!
- Na konci vždy zdůrazněte: "ArcPy je jen modul - budete psát `import arcpy` stejně jako `import math_utils`"
- Ukažte `help()` funkci - je užitečná pro čtení dokumentace
- Vytvořte math_utils.py společně na projektoru - ať vidí celý proces
- Nechte je otestovat všechny funkce v main.py

## Materiály k přípravě

- [ ] Připravit kostru math_utils.py (pro pomalé studenty)
- [ ] Ukázková main.py s použitím všech funkcí
- [ ] Diagram struktury projektu (složky a soubory)
- [ ] Cheatsheet pro různé způsoby importu