[
  {
    "objectID": "material/overview.html",
    "href": "material/overview.html",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Kurz: Programování pro GIS\nFakulta životního prostředí, ČZU Praha\nAktualizováno: Leden 2025\n\n\n\nCelkem: 8 výukových lekcí + 1 test = 9 lekcí (4 týdny)\n\n\n\nTýden\nLekce\nTéma\nČasová dotace\n\n\n\n\n3\n3\nZáklady Pythonu + datové typy\n90 min\n\n\n\n4\nPodmínky a cykly I - Fibonacci/Faktoriál\n90 min\n\n\n4\n5\nPodmínky a cykly II - Prvočísla + třídění\n90 min\n\n\n\n6\nFunkce a moduly\n90 min\n\n\n5\n7\nTextové soubory I - Jednoduchá tabulka\n90 min\n\n\n\n8\nTextové soubory II - CSV tabulka\n90 min\n\n\n6\n9\nTEST\n90 min\n\n\n\n10\nOOP - Třída Pes\n90 min\n\n\n\n\n\n\n\nCíl: Napsat a spustit první Python program, pochopit základní datové typy\n\n\n\n\n\nPython Command Prompt (ArcGIS Pro)\nVS Code + terminál\nVytvoření .py souboru\nPrvní program: print(\"Hello World\")\n\n\n\n\n\nint, float, string, bool\nProměnné a přiřazení\nZákladní operace (+, -, *, /, %, //)\ninput() od uživatele\nf-strings pro formátování\nSeznamy: vytvoření, indexování, append, len\n\n\n\n\n\nKalkulačka (načte 2 čísla, vypíše součet)\nPráce se seznamem (vytvoř seznam měst, vypiš první/poslední)\n\n\n\n\n\n\nFunkční .py soubor\nProgram s input/output\nZákladní práce se seznamy\n\n\n\n\n\nSeznamy jen ZÁKLADY (vytvoření, indexování, append, len)\nDetaily (slicing, metody) až v lekcích 4-5\nZaměřit se na to, aby dokázali SPUSTIT program\n\n\n\n\n\n\nCíl: Naučit se rozhodování (if) a opakování (for, while), aplikovat na matematické úlohy\n\n\n\n\n\nif/elif/else\nPorovnávací operátory (==, !=, &lt;, &gt;, &lt;=, &gt;=)\nLogické operátory (and, or, not)\nPříklady: kategorizace čísel, kontrola věku\n\n\n\n\n\nIterace přes range()\nIterace přes seznam\nAkumulace výsledků (suma, součin)\n\n\n\n\n\nCyklus s podmínkou\nbreak, continue\n\n\n\n\n\nSpolečně: n-tý člen Fibonacciho posloupnosti\nSamostatně: faktoriál čísla\n\n\n\n\n\n# F(0) = 0, F(1) = 1\n# F(n) = F(n-1) + F(n-2)\n\nn = int(input(\"Který člen? \"))\n\n# Iterativní řešení:\na, b = 0, 1\nfor i in range(n):\n    a, b = b, a + b\n    \nprint(f\"{n}. člen Fibonacciho posloupnosti: {a}\")\n\n\n\n# Studenti zkusí sami\n# 5! = 5 * 4 * 3 * 2 * 1\n\n\n\n\nDokončit faktoriál (pokud nestihli)\nVariace: Fibonacci/faktoriál pro seznam čísel\n\n\n\n\n\nFibonacci je klasika - dobře ukazuje logiku cyklů\nFaktoriál je dobrý samostatný úkol pro procvičení\nObojí užitečné pro pochopení akumulace v cyklu\n\n\n\n\n\n\nCíl: Prohlubování cyklů, algoritmické myšlení, vytvoření třídícího algoritmu\n\n\n\n\n\nDotazy k Fibonacci/Faktoriálu\nRychlá kontrola domácích úkolů\n\n\n\n\n\nCo je prvočíslo?\nAlgoritmus: zkouška dělitelnosti\nSpolečně: “Je číslo N prvočíslo?”\nSamostatně: “Najdi všechna prvočísla do 100”\n\n\n\n\n\nZadání: Seřaď seznam [5, 2, 8, 1, 9]\nBrainstorming: Jak byste to udělali ručně?\nStudenti většinou navrhnou:\n\n\nNajít nejmenší, přesunout → Selection sort\n\n\nPorovnávat sousedy, vyměnit → Bubble sort\n\n\nSpolečně implementovat OBA algoritmy\nVizualizace na tabuli\n\n\n\n\n\nUkázat, že třídění = vnořené cykly\nPropojení s Model Builder: “Pamatujete vnořené modely? V Pythonu je to přirozené!”\n\n\n\n\n\nn = int(input(\"Číslo: \"))\nje_prvocislo = True\n\nfor i in range(2, n):\n    if n % i == 0:\n        je_prvocislo = False\n        break\n\nif je_prvocislo:\n    print(f\"{n} je prvočíslo\")\nelse:\n    print(f\"{n} není prvočíslo\")\n\n\n\nseznam = [5, 2, 8, 1, 9]\n\nfor i in range(len(seznam)):\n    for j in range(len(seznam) - 1 - i):\n        if seznam[j] &gt; seznam[j + 1]:\n            # Výměna\n            seznam[j], seznam[j + 1] = seznam[j + 1], seznam[j]\n\nprint(seznam)\n\n\n\nVarianta A: - Vymyslet a implementovat vlastní třídící algoritmus\nVarianta B: - Najdi všechna prvočísla do 1000 - Nebo: N-té prvočíslo\n\n\n\n\nGuided discovery funguje skvěle - studenti často sami přijdou na algoritmy!\nMít připravený backup plán, pokud studenti nevymyslí\n40 min na třídění může být málo - případně zkrátit prvočísla\nDŮLEŽITÉ: Propojit s Model Builder vnořenými modely!\n\n\n\n\n\n\nCíl: Naučit se psát znovupoužitelný kód, organizovat program do funkcí a modulů\n\n\n\n\n\n“Psali jste Fibonacci/faktoriál vícekrát stejně?”\nDRY principle (Don’t Repeat Yourself)\nFunkce = pojmenovaný kus kódu, který můžeme volat\n\n\n\n\n\ndef, parametry, return\nDokumentační stringy (docstrings)\nFunkce s více parametry\nDefault hodnoty parametrů\nRozdíl mezi print() a return\n\n\n\n\n\nSpolečně: fibonacci(n)\nSamostatně:\n\nfaktorial(n)\nje_prvocislo(n)\nbubble_sort(seznam)\n\n\n\n\n\n\nVytvoření vlastního modulu (math_utils.py)\nimport math_utils\nfrom math_utils import fibonacci\nDůležité vestavěné moduly: math, os, csv\nPREVIEW: import arcpy\n\n\n\n\n\ndef fibonacci(n):\n    \"\"\"Vrátí n-tý člen Fibonacciho posloupnosti.\n    \n    Args:\n        n: Pořadové číslo členu (int)\n    \n    Returns:\n        n-tý člen (int)\n    \"\"\"\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a\n\n# Použití:\nvysledek = fibonacci(10)\nprint(f\"10. člen: {vysledek}\")\n\n\n\nmath_utils.py:\n--------------\ndef fibonacci(n):\n    \"\"\"Vrátí n-tý člen Fibonacciho posloupnosti.\"\"\"\n    ...\n    \ndef faktorial(n):\n    \"\"\"Vrátí faktoriál čísla n.\"\"\"\n    ...\n\ndef je_prvocislo(n):\n    \"\"\"Zjistí, zda je číslo prvočíslo.\"\"\"\n    ...\n\ndef bubble_sort(seznam):\n    \"\"\"Seřadí seznam bublinovým tříděním.\"\"\"\n    ...\n\nmain.py:\n--------\nimport math_utils\n\nn = int(input(\"Zadej číslo: \"))\nprint(f\"Fibonacci: {math_utils.fibonacci(n)}\")\nprint(f\"Faktoriál: {math_utils.faktorial(n)}\")\nprint(f\"Je prvočíslo: {math_utils.je_prvocislo(n)}\")\n\n\n\n\nDůležité: Vysvětlit rozdíl mezi print() a return\nStudenti často nerozumí, proč funkce “nic nedělá” (když vrací hodnotu, ale nevypisuje)\nModul = příprava na strukturu ArcPy skriptů\nZdůraznit: import arcpy budou používat pořád!\n\n\n\n\n\n\nCíl: Naučit se číst a zapisovat textové soubory, zpracovat jednoduchou tabulku\n\n\n\n\n\nopen(), read(), readlines()\nwith statement (context manager)\nZpracování řádků (.strip(), .split())\nEncoding (utf-8)\n\n\n\n\n\nRežimy: ‘r’, ‘w’, ‘a’\nVytvoření nového souboru\nZápis výsledků\n\n\n\n\n\nFormát: hodnoty oddělené mezerami/taby\nData: např. seznam měst s populací\n\nPraha 1300000\nBrno 380000\nOstrava 290000\nPlzeň 170000\nLiberec 103000\n\nÚkoly:\n\nNačti soubor\nVypiš města nad 500000 obyvatel\nSpočítaj celkovou populaci\nNajdi město s nejvyšší/nejnižší populací\nZapiš výsledky do nového souboru\n\n\n\n\n\n\n# Čtení a zpracování\nwith open('mesta.txt', 'r', encoding='utf-8') as f:\n    for radek in f:\n        radek = radek.strip()\n        if radek:  # neprázdný řádek\n            casti = radek.split()\n            mesto = casti[0]\n            populace = int(casti[1])\n            \n            if populace &gt; 500000:\n                print(f\"{mesto}: {populace:,} obyvatel\")\n\n# Zápis výsledků\nwith open('vysledky.txt', 'w', encoding='utf-8') as f:\n    f.write(\"Velká města:\\n\")\n    f.write(f\"Praha: 1,300,000\\n\")\n\n\n\n\nJednoduchý formát (whitespace separated) - bez komplikací s čárkami\nZákladní operace: čtení, parsování, filtrování, zápis\nPřipravuje na složitější CSV tabulky v příští lekci\n\n\n\n\n\n\nCíl: Naučit se pracovat s CSV formátem, zpracovat reálnější data\n\n\n\n\n\nComma-Separated Values\nProblém: čárky v datech, speciální znaky\nProč používat csv modul místo ručního parsování\n\n\n\n\n\ncsv.reader() - základní\ncsv.DictReader() - lepší pro data s hlavičkami\nPráce s hlavičkami\nPřevody datových typů\n\n\n\n\n\ncsv.writer()\ncsv.DictWriter() - doporučeno\nnewline='' parametr\n\n\n\n\n\nCSV s daty o okresech:\n\nOkres,Populace,Rozloha,Hustota\nPraha,1300000,496,2621\nBrno,380000,230,1652\nOstrava,290000,214,1355\nPlzeň,170000,261,651\n\nÚkoly:\n\nNačti CSV pomocí DictReader\nFiltruj okresy (např. populace &gt; 200000)\nSpočítej statistiky:\n\nPrůměrná populace\nPrůměrná hustota\nMax/min hodnoty\n\nPoužij funkce z math_utils!\nVytvoř nový CSV s výsledky\n\n\n\n\n\n\nimport csv\n\n# Čtení s DictReader\nokresy = []\nwith open('okresy.csv', 'r', encoding='utf-8') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        okresy.append({\n            'nazev': row['Okres'],\n            'populace': int(row['Populace']),\n            'rozloha': float(row['Rozloha']),\n            'hustota': float(row['Hustota'])\n        })\n\n# Zpracování (filtrace)\nvelke_okresy = [o for o in okresy if o['populace'] &gt; 200000]\n\n# Statistiky\nprumer_pop = sum(o['populace'] for o in okresy) / len(okresy)\nprint(f\"Průměrná populace: {prumer_pop:,.0f}\")\n\n# Zápis výsledků\nwith open('vysledky.csv', 'w', encoding='utf-8', newline='') as f:\n    fieldnames = ['nazev', 'populace', 'hustota']\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    \n    writer.writeheader()\n    writer.writerows(velke_okresy)\n\n\n\n\n“Atributové tabulky v ArcGIS vypadají podobně!”\n“V ArcPy budete exportovat výsledky do CSV”\n“Nebo načítat CSV a vytvářet z nich feature classes”\n\n\n\n\n\ncsv modul je důležitý - budou ho používat v ArcPy\nList comprehensions lze lehce ukázat ([x for x in ...])\nRealistická data připomínají atributové tabulky z GIS!\n\n\n\n\n\n\nCíl: Ověřit porozumění základům Pythonu\n\n\n\n\nFormát: - Porozumění kódu (co vypíše tento program?) - Doplnění kódu (doplň chybějící řádky) - Krátké úlohy (napiš funkci, která…) - Otázky k teorii (co dělá with statement?)\nPříklady otázek:\n# 1. Co vypíše tento kód?\nx = [1, 2, 3, 4, 5]\nfor i in x:\n    if i % 2 == 0:\n        print(i)\n\n# 2. Doplň chybějící část:\ndef soucet(a, b):\n    ___________  # Vrať součet a a b\n\n# 3. Napiš funkci, která zjistí, zda je číslo sudé\n\n\n\nZadání:\nMáte CSV soubor s daty o okresech:\n- Sloupce: Okres, Populace, Rozloha\n\nÚkol:\n1. Načti CSV soubor\n2. Vytvoř funkci vypocitej_hustotu(populace, rozloha)\n3. Pro každý okres spočítej hustotu obyvatel\n4. Najdi okresy s hustotou &gt; 500 obyvatel/km²\n5. Zapiš výsledky do nového CSV souboru\n\nOdevzdej:\n- Soubor main.py s hlavním programem\n- Soubor funkce.py s funkcí vypocitej_hustotu\n- Výsledný CSV soubor\nHodnotí se: - Funkčnost (program běží bez chyb) - Použití funkcí a modulů - Správná práce se soubory (otevření, zavření, encoding) - Čitelnost kódu (proměnné, komentáře) - Správnost výpočtů\n\n\n\n\n\n60 min je dostatečné na napsání funkčního programu\nKombinuje všechno, co se naučili: funkce, moduly, soubory, cykly\nData připravit dopředu (okresy.csv)\n\n\n\n\n\n\nCíl: Pochopit základní koncept objektového programování, připravit se na práci s ArcPy objekty\n\n\n\n\n\nObjekt = věc s vlastnostmi (atributy) + schopnostmi (metody)\nTřída = šablona/recept pro vytváření objektů\nInstance = konkrétní objekt vytvořený z třídy\nAnalogie: Třída = plánek domu, Instance = konkrétní dům\n\n\n\n\n\nDefinice třídy (class)\nKonstruktor __init__\nParametr self\nAtributy (jmeno, vek, rasa)\nMetody (stekej, oslavPrazdniny)\n\n\n\n\n\nVytváření instancí\nVolání metod\nPřístup k atributům\nVíce instancí ze stejné třídy\n\n\n\n\n\n“V ArcPy budete POUŽÍVAT objekty, ne je vytvářet!”\nPříklady z ArcPy:\n\narcpy.Describe() → objekt s atributy\ndesc.spatialReference.name → objekt.atribut.atribut\ngeometry.area → objekt.atribut\ngeometry.buffer(100) → objekt.metoda()\ncursor.insertRow() → objekt.metoda()\n\n“Teď už rozumíte zápisu objekt.metoda()!”\n\n\n\n\n\nclass Pes:\n    \"\"\"Třída reprezentující psa.\"\"\"\n    \n    def __init__(self, jmeno, vek, rasa):\n        \"\"\"Vytvoří nového psa.\n        \n        Args:\n            jmeno: Jméno psa (str)\n            vek: Věk v letech (int)\n            rasa: Rasa psa (str)\n        \"\"\"\n        self.jmeno = jmeno\n        self.vek = vek\n        self.rasa = rasa\n    \n    def stekej(self):\n        \"\"\"Pes zaštěká.\"\"\"\n        print(f\"{self.jmeno}: Haf haf!\")\n    \n    def oslavPrazdniny(self):\n        \"\"\"Pes oslaví narozeniny.\"\"\"\n        self.vek += 1\n        print(f\"{self.jmeno} má teď {self.vek} let\")\n    \n    def __str__(self):\n        \"\"\"Textová reprezentace psa.\"\"\"\n        return f\"{self.jmeno} ({self.rasa}, {self.vek} let)\"\n\n# Použití:\nalik = Pes(\"Alík\", 3, \"Labrador\")\nalik.stekej()           # Alík: Haf haf!\nprint(alik.vek)         # 3\nalik.oslavPrazdniny()   # Alík má teď 4 let\nprint(alik)             # Alík (Labrador, 4 let)\n\n# Další pes ze stejné třídy:\nbeny = Pes(\"Beny\", 5, \"Ovčák\")\nbeny.stekej()           # Beny: Haf haf!\n\n# Dva nezávislé objekty:\nprint(alik.vek)  # 4\nprint(beny.vek)  # 5\n\n\n\nÚkol 1: Vytvoř třídu Okres s atributy: - nazev - populace - rozloha\nA metodami: - vypocitej_hustotu() - vrátí hustotu - je_velky() - vrátí True pokud populace &gt; 100000\nÚkol 2: Vytvoř 3 instance (okresy) a otestuj metody\n\n\n\n# V ArcPy budete psát (bez vytváření vlastních tříd):\n\n# Describe objekt\ndesc = arcpy.Describe(\"vrstva.shp\")\nprint(desc.shapeType)              # objekt.atribut\nprint(desc.spatialReference.name)  # objekt.atribut.atribut\n\n# Geometry objekt (z kurzoru)\nwith arcpy.da.SearchCursor(\"vrstva\", [\"SHAPE@\"]) as cursor:\n    for row in cursor:\n        geom = row[0]              # Geometrie je objekt!\n        print(geom.area)           # objekt.atribut\n        print(geom.length)         # objekt.atribut\n        buffer = geom.buffer(100)  # objekt.metoda()\n\n\n\n\nDŮLEŽITÉ: Studenti NEMUSÍ psát složité třídy!\nCíl: Pochopit, jak POUŽÍVAT objekty z knihoven\nConsumer, not creator\n__str__ lze ukázat jako bonus (pro print)\nTřída Pes je dobrá - jednoduchá, pochopitelná, relatable\nNa konci VŽDY propojit s ArcPy!\n\n\n\n\n\n\n\n\nLekce 3:  Základy (90 min)\nLekce 4:  Fibonacci/faktoriál (90 min)\nLekce 5:  Prvočísla/třídění (90 min)\nLekce 6:  Funkce/moduly (90 min)\nLekce 7:  Soubory - jednoduché (90 min)\nLekce 8:  Soubory - CSV (90 min)\nLekce 9:  TEST (90 min)\nLekce 10: OOP (90 min)\n────────────────────────────────\nCELKEM:   720 min = 12 hodin = 4 týdny\n\n\n\n\n\n\nVnořené cykly (Lekce 5) - kritické pro GIS!\n\nPropojení s Model Builder vnořenými modely\n\nFunkce (Lekce 6) - příprava na ArcPy\n\nKaždý ArcPy nástroj je funkce\n\nCSV soubory (Lekce 8) - praktické pro GIS\n\nExport/import dat z ArcGIS\n\nOOP (Lekce 10) - pochopení ArcPy objektů\n\nConsumer, not creator\nGeometry, Describe, Cursor objekty\n\n\n\n\n\n\nStudenti budou různě rychlí\n\nŘešení: Volitelné bonusové úkoly pro rychlejší\n\nTřídění může být těžké\n\nŘešení: Guided discovery, ale mít připravený backup\n\nOOP může být abstraktní\n\nŘešení: Jednoduchá třída (Pes), praktické příklady z ArcPy\n\n\n\n\n\n\nDictionary, tuple (až v ArcPy lekcích)\nTry/except (až při ArcPy error handling)\nLambda funkce (není potřeba)\nList comprehensions (jen lehce ukázat)\nPokročilé OOP (dědičnost, polymorphismus)\n\n\n\n\n\nLekce 5: Vnořené cykly = vnořené modely v Pythonu přirozené\nLekce 6: Import = jako používání nástrojů z toolboxu\nLekce 7-8: CSV = připomíná atributové tabulky\n\n\n\n\n\n\nLekce 3: Hello World příklady, kalkulačka\nLekce 4: Fibonacci/faktoriál úlohy\nLekce 5: Prvočísla úlohy, vizualizace třídění\nLekce 6: math_utils modul template\nLekce 7: mesta.txt soubor\nLekce 8: okresy.csv soubor\nLekce 9: Testové otázky a praktický úkol\nLekce 10: Třída Pes + propojení s ArcPy ukázky\n\n\nStruktura je realistická a pedagogicky správná!\nPostupná progrese: Základy → Algoritmy → Funkce → Data → Objekty\nPříprava na ArcPy: Každá lekce připravuje na koncepty z ArcPy\n\nDokumentace kurzu “Programování pro GIS”\nFŽP ČZU Praha, 2025"
  },
  {
    "objectID": "material/overview.html#časová-struktura",
    "href": "material/overview.html#časová-struktura",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Celkem: 8 výukových lekcí + 1 test = 9 lekcí (4 týdny)\n\n\n\nTýden\nLekce\nTéma\nČasová dotace\n\n\n\n\n3\n3\nZáklady Pythonu + datové typy\n90 min\n\n\n\n4\nPodmínky a cykly I - Fibonacci/Faktoriál\n90 min\n\n\n4\n5\nPodmínky a cykly II - Prvočísla + třídění\n90 min\n\n\n\n6\nFunkce a moduly\n90 min\n\n\n5\n7\nTextové soubory I - Jednoduchá tabulka\n90 min\n\n\n\n8\nTextové soubory II - CSV tabulka\n90 min\n\n\n6\n9\nTEST\n90 min\n\n\n\n10\nOOP - Třída Pes\n90 min"
  },
  {
    "objectID": "material/overview.html#lekce-3-základy-pythonu-datové-typy",
    "href": "material/overview.html#lekce-3-základy-pythonu-datové-typy",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Cíl: Napsat a spustit první Python program, pochopit základní datové typy\n\n\n\n\n\nPython Command Prompt (ArcGIS Pro)\nVS Code + terminál\nVytvoření .py souboru\nPrvní program: print(\"Hello World\")\n\n\n\n\n\nint, float, string, bool\nProměnné a přiřazení\nZákladní operace (+, -, *, /, %, //)\ninput() od uživatele\nf-strings pro formátování\nSeznamy: vytvoření, indexování, append, len\n\n\n\n\n\nKalkulačka (načte 2 čísla, vypíše součet)\nPráce se seznamem (vytvoř seznam měst, vypiš první/poslední)\n\n\n\n\n\n\nFunkční .py soubor\nProgram s input/output\nZákladní práce se seznamy\n\n\n\n\n\nSeznamy jen ZÁKLADY (vytvoření, indexování, append, len)\nDetaily (slicing, metody) až v lekcích 4-5\nZaměřit se na to, aby dokázali SPUSTIT program"
  },
  {
    "objectID": "material/overview.html#lekce-4-podmínky-a-cykly-i---fibonaccifaktoriál",
    "href": "material/overview.html#lekce-4-podmínky-a-cykly-i---fibonaccifaktoriál",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Cíl: Naučit se rozhodování (if) a opakování (for, while), aplikovat na matematické úlohy\n\n\n\n\n\nif/elif/else\nPorovnávací operátory (==, !=, &lt;, &gt;, &lt;=, &gt;=)\nLogické operátory (and, or, not)\nPříklady: kategorizace čísel, kontrola věku\n\n\n\n\n\nIterace přes range()\nIterace přes seznam\nAkumulace výsledků (suma, součin)\n\n\n\n\n\nCyklus s podmínkou\nbreak, continue\n\n\n\n\n\nSpolečně: n-tý člen Fibonacciho posloupnosti\nSamostatně: faktoriál čísla\n\n\n\n\n\n# F(0) = 0, F(1) = 1\n# F(n) = F(n-1) + F(n-2)\n\nn = int(input(\"Který člen? \"))\n\n# Iterativní řešení:\na, b = 0, 1\nfor i in range(n):\n    a, b = b, a + b\n    \nprint(f\"{n}. člen Fibonacciho posloupnosti: {a}\")\n\n\n\n# Studenti zkusí sami\n# 5! = 5 * 4 * 3 * 2 * 1\n\n\n\n\nDokončit faktoriál (pokud nestihli)\nVariace: Fibonacci/faktoriál pro seznam čísel\n\n\n\n\n\nFibonacci je klasika - dobře ukazuje logiku cyklů\nFaktoriál je dobrý samostatný úkol pro procvičení\nObojí užitečné pro pochopení akumulace v cyklu"
  },
  {
    "objectID": "material/overview.html#lekce-5-podmínky-a-cykly-ii---prvočísla-třídění",
    "href": "material/overview.html#lekce-5-podmínky-a-cykly-ii---prvočísla-třídění",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Cíl: Prohlubování cyklů, algoritmické myšlení, vytvoření třídícího algoritmu\n\n\n\n\n\nDotazy k Fibonacci/Faktoriálu\nRychlá kontrola domácích úkolů\n\n\n\n\n\nCo je prvočíslo?\nAlgoritmus: zkouška dělitelnosti\nSpolečně: “Je číslo N prvočíslo?”\nSamostatně: “Najdi všechna prvočísla do 100”\n\n\n\n\n\nZadání: Seřaď seznam [5, 2, 8, 1, 9]\nBrainstorming: Jak byste to udělali ručně?\nStudenti většinou navrhnou:\n\n\nNajít nejmenší, přesunout → Selection sort\n\n\nPorovnávat sousedy, vyměnit → Bubble sort\n\n\nSpolečně implementovat OBA algoritmy\nVizualizace na tabuli\n\n\n\n\n\nUkázat, že třídění = vnořené cykly\nPropojení s Model Builder: “Pamatujete vnořené modely? V Pythonu je to přirozené!”\n\n\n\n\n\nn = int(input(\"Číslo: \"))\nje_prvocislo = True\n\nfor i in range(2, n):\n    if n % i == 0:\n        je_prvocislo = False\n        break\n\nif je_prvocislo:\n    print(f\"{n} je prvočíslo\")\nelse:\n    print(f\"{n} není prvočíslo\")\n\n\n\nseznam = [5, 2, 8, 1, 9]\n\nfor i in range(len(seznam)):\n    for j in range(len(seznam) - 1 - i):\n        if seznam[j] &gt; seznam[j + 1]:\n            # Výměna\n            seznam[j], seznam[j + 1] = seznam[j + 1], seznam[j]\n\nprint(seznam)\n\n\n\nVarianta A: - Vymyslet a implementovat vlastní třídící algoritmus\nVarianta B: - Najdi všechna prvočísla do 1000 - Nebo: N-té prvočíslo\n\n\n\n\nGuided discovery funguje skvěle - studenti často sami přijdou na algoritmy!\nMít připravený backup plán, pokud studenti nevymyslí\n40 min na třídění může být málo - případně zkrátit prvočísla\nDŮLEŽITÉ: Propojit s Model Builder vnořenými modely!"
  },
  {
    "objectID": "material/overview.html#lekce-6-funkce-a-moduly",
    "href": "material/overview.html#lekce-6-funkce-a-moduly",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Cíl: Naučit se psát znovupoužitelný kód, organizovat program do funkcí a modulů\n\n\n\n\n\n“Psali jste Fibonacci/faktoriál vícekrát stejně?”\nDRY principle (Don’t Repeat Yourself)\nFunkce = pojmenovaný kus kódu, který můžeme volat\n\n\n\n\n\ndef, parametry, return\nDokumentační stringy (docstrings)\nFunkce s více parametry\nDefault hodnoty parametrů\nRozdíl mezi print() a return\n\n\n\n\n\nSpolečně: fibonacci(n)\nSamostatně:\n\nfaktorial(n)\nje_prvocislo(n)\nbubble_sort(seznam)\n\n\n\n\n\n\nVytvoření vlastního modulu (math_utils.py)\nimport math_utils\nfrom math_utils import fibonacci\nDůležité vestavěné moduly: math, os, csv\nPREVIEW: import arcpy\n\n\n\n\n\ndef fibonacci(n):\n    \"\"\"Vrátí n-tý člen Fibonacciho posloupnosti.\n    \n    Args:\n        n: Pořadové číslo členu (int)\n    \n    Returns:\n        n-tý člen (int)\n    \"\"\"\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a\n\n# Použití:\nvysledek = fibonacci(10)\nprint(f\"10. člen: {vysledek}\")\n\n\n\nmath_utils.py:\n--------------\ndef fibonacci(n):\n    \"\"\"Vrátí n-tý člen Fibonacciho posloupnosti.\"\"\"\n    ...\n    \ndef faktorial(n):\n    \"\"\"Vrátí faktoriál čísla n.\"\"\"\n    ...\n\ndef je_prvocislo(n):\n    \"\"\"Zjistí, zda je číslo prvočíslo.\"\"\"\n    ...\n\ndef bubble_sort(seznam):\n    \"\"\"Seřadí seznam bublinovým tříděním.\"\"\"\n    ...\n\nmain.py:\n--------\nimport math_utils\n\nn = int(input(\"Zadej číslo: \"))\nprint(f\"Fibonacci: {math_utils.fibonacci(n)}\")\nprint(f\"Faktoriál: {math_utils.faktorial(n)}\")\nprint(f\"Je prvočíslo: {math_utils.je_prvocislo(n)}\")\n\n\n\n\nDůležité: Vysvětlit rozdíl mezi print() a return\nStudenti často nerozumí, proč funkce “nic nedělá” (když vrací hodnotu, ale nevypisuje)\nModul = příprava na strukturu ArcPy skriptů\nZdůraznit: import arcpy budou používat pořád!"
  },
  {
    "objectID": "material/overview.html#lekce-7-textové-soubory-i---jednoduchá-tabulka",
    "href": "material/overview.html#lekce-7-textové-soubory-i---jednoduchá-tabulka",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Cíl: Naučit se číst a zapisovat textové soubory, zpracovat jednoduchou tabulku\n\n\n\n\n\nopen(), read(), readlines()\nwith statement (context manager)\nZpracování řádků (.strip(), .split())\nEncoding (utf-8)\n\n\n\n\n\nRežimy: ‘r’, ‘w’, ‘a’\nVytvoření nového souboru\nZápis výsledků\n\n\n\n\n\nFormát: hodnoty oddělené mezerami/taby\nData: např. seznam měst s populací\n\nPraha 1300000\nBrno 380000\nOstrava 290000\nPlzeň 170000\nLiberec 103000\n\nÚkoly:\n\nNačti soubor\nVypiš města nad 500000 obyvatel\nSpočítaj celkovou populaci\nNajdi město s nejvyšší/nejnižší populací\nZapiš výsledky do nového souboru\n\n\n\n\n\n\n# Čtení a zpracování\nwith open('mesta.txt', 'r', encoding='utf-8') as f:\n    for radek in f:\n        radek = radek.strip()\n        if radek:  # neprázdný řádek\n            casti = radek.split()\n            mesto = casti[0]\n            populace = int(casti[1])\n            \n            if populace &gt; 500000:\n                print(f\"{mesto}: {populace:,} obyvatel\")\n\n# Zápis výsledků\nwith open('vysledky.txt', 'w', encoding='utf-8') as f:\n    f.write(\"Velká města:\\n\")\n    f.write(f\"Praha: 1,300,000\\n\")\n\n\n\n\nJednoduchý formát (whitespace separated) - bez komplikací s čárkami\nZákladní operace: čtení, parsování, filtrování, zápis\nPřipravuje na složitější CSV tabulky v příští lekci"
  },
  {
    "objectID": "material/overview.html#lekce-8-textové-soubory-ii---csv-tabulka",
    "href": "material/overview.html#lekce-8-textové-soubory-ii---csv-tabulka",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Cíl: Naučit se pracovat s CSV formátem, zpracovat reálnější data\n\n\n\n\n\nComma-Separated Values\nProblém: čárky v datech, speciální znaky\nProč používat csv modul místo ručního parsování\n\n\n\n\n\ncsv.reader() - základní\ncsv.DictReader() - lepší pro data s hlavičkami\nPráce s hlavičkami\nPřevody datových typů\n\n\n\n\n\ncsv.writer()\ncsv.DictWriter() - doporučeno\nnewline='' parametr\n\n\n\n\n\nCSV s daty o okresech:\n\nOkres,Populace,Rozloha,Hustota\nPraha,1300000,496,2621\nBrno,380000,230,1652\nOstrava,290000,214,1355\nPlzeň,170000,261,651\n\nÚkoly:\n\nNačti CSV pomocí DictReader\nFiltruj okresy (např. populace &gt; 200000)\nSpočítej statistiky:\n\nPrůměrná populace\nPrůměrná hustota\nMax/min hodnoty\n\nPoužij funkce z math_utils!\nVytvoř nový CSV s výsledky\n\n\n\n\n\n\nimport csv\n\n# Čtení s DictReader\nokresy = []\nwith open('okresy.csv', 'r', encoding='utf-8') as f:\n    reader = csv.DictReader(f)\n    for row in reader:\n        okresy.append({\n            'nazev': row['Okres'],\n            'populace': int(row['Populace']),\n            'rozloha': float(row['Rozloha']),\n            'hustota': float(row['Hustota'])\n        })\n\n# Zpracování (filtrace)\nvelke_okresy = [o for o in okresy if o['populace'] &gt; 200000]\n\n# Statistiky\nprumer_pop = sum(o['populace'] for o in okresy) / len(okresy)\nprint(f\"Průměrná populace: {prumer_pop:,.0f}\")\n\n# Zápis výsledků\nwith open('vysledky.csv', 'w', encoding='utf-8', newline='') as f:\n    fieldnames = ['nazev', 'populace', 'hustota']\n    writer = csv.DictWriter(f, fieldnames=fieldnames)\n    \n    writer.writeheader()\n    writer.writerows(velke_okresy)\n\n\n\n\n“Atributové tabulky v ArcGIS vypadají podobně!”\n“V ArcPy budete exportovat výsledky do CSV”\n“Nebo načítat CSV a vytvářet z nich feature classes”\n\n\n\n\n\ncsv modul je důležitý - budou ho používat v ArcPy\nList comprehensions lze lehce ukázat ([x for x in ...])\nRealistická data připomínají atributové tabulky z GIS!"
  },
  {
    "objectID": "material/overview.html#lekce-9-test-90-min",
    "href": "material/overview.html#lekce-9-test-90-min",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Cíl: Ověřit porozumění základům Pythonu\n\n\n\n\nFormát: - Porozumění kódu (co vypíše tento program?) - Doplnění kódu (doplň chybějící řádky) - Krátké úlohy (napiš funkci, která…) - Otázky k teorii (co dělá with statement?)\nPříklady otázek:\n# 1. Co vypíše tento kód?\nx = [1, 2, 3, 4, 5]\nfor i in x:\n    if i % 2 == 0:\n        print(i)\n\n# 2. Doplň chybějící část:\ndef soucet(a, b):\n    ___________  # Vrať součet a a b\n\n# 3. Napiš funkci, která zjistí, zda je číslo sudé\n\n\n\nZadání:\nMáte CSV soubor s daty o okresech:\n- Sloupce: Okres, Populace, Rozloha\n\nÚkol:\n1. Načti CSV soubor\n2. Vytvoř funkci vypocitej_hustotu(populace, rozloha)\n3. Pro každý okres spočítej hustotu obyvatel\n4. Najdi okresy s hustotou &gt; 500 obyvatel/km²\n5. Zapiš výsledky do nového CSV souboru\n\nOdevzdej:\n- Soubor main.py s hlavním programem\n- Soubor funkce.py s funkcí vypocitej_hustotu\n- Výsledný CSV soubor\nHodnotí se: - Funkčnost (program běží bez chyb) - Použití funkcí a modulů - Správná práce se soubory (otevření, zavření, encoding) - Čitelnost kódu (proměnné, komentáře) - Správnost výpočtů\n\n\n\n\n\n60 min je dostatečné na napsání funkčního programu\nKombinuje všechno, co se naučili: funkce, moduly, soubory, cykly\nData připravit dopředu (okresy.csv)"
  },
  {
    "objectID": "material/overview.html#lekce-10-lehký-úvod-do-oop---třída-pes",
    "href": "material/overview.html#lekce-10-lehký-úvod-do-oop---třída-pes",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Cíl: Pochopit základní koncept objektového programování, připravit se na práci s ArcPy objekty\n\n\n\n\n\nObjekt = věc s vlastnostmi (atributy) + schopnostmi (metody)\nTřída = šablona/recept pro vytváření objektů\nInstance = konkrétní objekt vytvořený z třídy\nAnalogie: Třída = plánek domu, Instance = konkrétní dům\n\n\n\n\n\nDefinice třídy (class)\nKonstruktor __init__\nParametr self\nAtributy (jmeno, vek, rasa)\nMetody (stekej, oslavPrazdniny)\n\n\n\n\n\nVytváření instancí\nVolání metod\nPřístup k atributům\nVíce instancí ze stejné třídy\n\n\n\n\n\n“V ArcPy budete POUŽÍVAT objekty, ne je vytvářet!”\nPříklady z ArcPy:\n\narcpy.Describe() → objekt s atributy\ndesc.spatialReference.name → objekt.atribut.atribut\ngeometry.area → objekt.atribut\ngeometry.buffer(100) → objekt.metoda()\ncursor.insertRow() → objekt.metoda()\n\n“Teď už rozumíte zápisu objekt.metoda()!”\n\n\n\n\n\nclass Pes:\n    \"\"\"Třída reprezentující psa.\"\"\"\n    \n    def __init__(self, jmeno, vek, rasa):\n        \"\"\"Vytvoří nového psa.\n        \n        Args:\n            jmeno: Jméno psa (str)\n            vek: Věk v letech (int)\n            rasa: Rasa psa (str)\n        \"\"\"\n        self.jmeno = jmeno\n        self.vek = vek\n        self.rasa = rasa\n    \n    def stekej(self):\n        \"\"\"Pes zaštěká.\"\"\"\n        print(f\"{self.jmeno}: Haf haf!\")\n    \n    def oslavPrazdniny(self):\n        \"\"\"Pes oslaví narozeniny.\"\"\"\n        self.vek += 1\n        print(f\"{self.jmeno} má teď {self.vek} let\")\n    \n    def __str__(self):\n        \"\"\"Textová reprezentace psa.\"\"\"\n        return f\"{self.jmeno} ({self.rasa}, {self.vek} let)\"\n\n# Použití:\nalik = Pes(\"Alík\", 3, \"Labrador\")\nalik.stekej()           # Alík: Haf haf!\nprint(alik.vek)         # 3\nalik.oslavPrazdniny()   # Alík má teď 4 let\nprint(alik)             # Alík (Labrador, 4 let)\n\n# Další pes ze stejné třídy:\nbeny = Pes(\"Beny\", 5, \"Ovčák\")\nbeny.stekej()           # Beny: Haf haf!\n\n# Dva nezávislé objekty:\nprint(alik.vek)  # 4\nprint(beny.vek)  # 5\n\n\n\nÚkol 1: Vytvoř třídu Okres s atributy: - nazev - populace - rozloha\nA metodami: - vypocitej_hustotu() - vrátí hustotu - je_velky() - vrátí True pokud populace &gt; 100000\nÚkol 2: Vytvoř 3 instance (okresy) a otestuj metody\n\n\n\n# V ArcPy budete psát (bez vytváření vlastních tříd):\n\n# Describe objekt\ndesc = arcpy.Describe(\"vrstva.shp\")\nprint(desc.shapeType)              # objekt.atribut\nprint(desc.spatialReference.name)  # objekt.atribut.atribut\n\n# Geometry objekt (z kurzoru)\nwith arcpy.da.SearchCursor(\"vrstva\", [\"SHAPE@\"]) as cursor:\n    for row in cursor:\n        geom = row[0]              # Geometrie je objekt!\n        print(geom.area)           # objekt.atribut\n        print(geom.length)         # objekt.atribut\n        buffer = geom.buffer(100)  # objekt.metoda()\n\n\n\n\nDŮLEŽITÉ: Studenti NEMUSÍ psát složité třídy!\nCíl: Pochopit, jak POUŽÍVAT objekty z knihoven\nConsumer, not creator\n__str__ lze ukázat jako bonus (pro print)\nTřída Pes je dobrá - jednoduchá, pochopitelná, relatable\nNa konci VŽDY propojit s ArcPy!"
  },
  {
    "objectID": "material/overview.html#celkové-shrnutí-a-doporučení",
    "href": "material/overview.html#celkové-shrnutí-a-doporučení",
    "title": "Přehled: Python základy (Lekce 3-10)",
    "section": "",
    "text": "Lekce 3:  Základy (90 min)\nLekce 4:  Fibonacci/faktoriál (90 min)\nLekce 5:  Prvočísla/třídění (90 min)\nLekce 6:  Funkce/moduly (90 min)\nLekce 7:  Soubory - jednoduché (90 min)\nLekce 8:  Soubory - CSV (90 min)\nLekce 9:  TEST (90 min)\nLekce 10: OOP (90 min)\n────────────────────────────────\nCELKEM:   720 min = 12 hodin = 4 týdny\n\n\n\n\n\n\nVnořené cykly (Lekce 5) - kritické pro GIS!\n\nPropojení s Model Builder vnořenými modely\n\nFunkce (Lekce 6) - příprava na ArcPy\n\nKaždý ArcPy nástroj je funkce\n\nCSV soubory (Lekce 8) - praktické pro GIS\n\nExport/import dat z ArcGIS\n\nOOP (Lekce 10) - pochopení ArcPy objektů\n\nConsumer, not creator\nGeometry, Describe, Cursor objekty\n\n\n\n\n\n\nStudenti budou různě rychlí\n\nŘešení: Volitelné bonusové úkoly pro rychlejší\n\nTřídění může být těžké\n\nŘešení: Guided discovery, ale mít připravený backup\n\nOOP může být abstraktní\n\nŘešení: Jednoduchá třída (Pes), praktické příklady z ArcPy\n\n\n\n\n\n\nDictionary, tuple (až v ArcPy lekcích)\nTry/except (až při ArcPy error handling)\nLambda funkce (není potřeba)\nList comprehensions (jen lehce ukázat)\nPokročilé OOP (dědičnost, polymorphismus)\n\n\n\n\n\nLekce 5: Vnořené cykly = vnořené modely v Pythonu přirozené\nLekce 6: Import = jako používání nástrojů z toolboxu\nLekce 7-8: CSV = připomíná atributové tabulky\n\n\n\n\n\n\nLekce 3: Hello World příklady, kalkulačka\nLekce 4: Fibonacci/faktoriál úlohy\nLekce 5: Prvočísla úlohy, vizualizace třídění\nLekce 6: math_utils modul template\nLekce 7: mesta.txt soubor\nLekce 8: okresy.csv soubor\nLekce 9: Testové otázky a praktický úkol\nLekce 10: Třída Pes + propojení s ArcPy ukázky\n\n\nStruktura je realistická a pedagogicky správná!\nPostupná progrese: Základy → Algoritmy → Funkce → Data → Objekty\nPříprava na ArcPy: Každá lekce připravuje na koncepty z ArcPy\n\nDokumentace kurzu “Programování pro GIS”\nFŽP ČZU Praha, 2025"
  },
  {
    "objectID": "material/old_materials/Lekce 8 Funkce a moduly.html",
    "href": "material/old_materials/Lekce 8 Funkce a moduly.html",
    "title": "Lekce 8: Funkce a moduly",
    "section": "",
    "text": "Často nastává situace, kdy nějakou část kódu chceme používat opakovaně. Například můžeme chtít opakovaně v našem programu počítat faktoriál nějakého čísla (přičemž toto číslo může být pokaždé jiné). Výpočet faktoriálu jsme si ukázali v kapitole o cyklu for, řešení může vypadat třeba takto:\nfaktorialn = 1\nfor i in range(n): faktorialn = faktorialn * (i+1)\nprint faktorialn\n„Nejprimitivnější“ možností by bylo vložit tento kód všude tam, kde v kódu potřebujeme počítat faktoriál, samozřejmě vždy s patřičně změněnou hodnotou n.\nProblém takového řešení nastává ve chvíli, kdy budeme chtít samotný výpočet faktoriálu změnit – např. pokud bychom zjistili, že jsme v původním kódu udělali chybu a je třeba jej opravit. Máme-li totiž výše uvedený kód v našem programu na mnoha místech, je třeba jej (správně) přepsat na každém takovém místě. To je značně nepohodlné a navíc se při tom snadno dopustíme chyb.\nElegantnějším řešením je vytvořit (tj. definovat) funkci, která bude výpočet faktoriálu provádět, a tuto funkci pak na příslušných místech volat.\nStruktura zápisu definice funkce je následující:\ndef nazev_funkce(parametr1, parametr2, ... , parametrN):\n    tělo funkce\nDefinice je uvozena klíčovým slovem def, podle kterého interpret pozná, že se jedná o definici funkce. Následuje libovolný název a v závorkách posloupnost tzv. parametrů, tj. proměnných zastupujících hodnoty vstupující do výpočtu, který má funkce provádět. Tělo funkce pak obsahuje příkazy (psané na samostatné řádky odsazené o jednu úroveň za slovo def), které obvykle něco provádějí s parametry. Ukažme si funkci na konkrétním příkladu výpočtu faktoriálu:\ndef faktorial(n):\n    faktorialn = 1\n    for i in range(n): faktorialn = faktorialn * (i+1)\n    return faktorialn\nKlíčové slovo return ukončuje definici funkce (není však povinné, jak uvidíme níže), přičemž stanoví, jaká hodnota má být funkcí vrácena při jejím volání.\nPokud odešleme kód s definicí funkce do překladače (resp. interpretu), není výsledkem provedení příslušných příkazů uvedených v těle funkce, ale pouze je funkce uložena v operační paměti a je ji možné kdykoli tzv. zavolat. Volání funkce má strukturu analogickou její definici:\nnazev_funkce(argmunet1, argument2, ... , argumentN)\nJednotlivé argumenty přesně odpovídají jednotlivým parametrům funkce, jsou vlastně konkrétními hodnotami, které se při volání funkce za jednotlivé parametry dosadí. Ukažme si volání funkce opět na příkladu faktoriálu, přičemž budeme funkci definovanou výše volat v okně Python Shell:\n&gt;&gt;&gt; faktorial(3)\n6\n&gt;&gt;&gt; faktorial(6)\n720\n&gt;&gt;&gt; faktorial(10)\n3628800\nVýhoda tohoto řešení je zřejmá: kdykoli lze nyní použít funkci faktorial s libovolným celočíselným argumentem, přičemž pokud bychom chtěli funkci nějak změnit, stačí tak učinit pouze jednou, v samotné její definici.\nUveďme příklad funkce s více než jedním parametrem, např. funkci, která počítá zadanou celočíselnou mocninu zadaného čísla:\ndef mocnina(x,y):\n    vysledek = 1\n    for i in range(y): vysledek = vysledek * x\n    return vysledek\n(Samozřejmě jsme mohli funkci definovat i jednodušeji: def mocnina(x,y): return x**y. Prozkoumejte nicméně uvedenou složitější definici a uvědomte si, že bude pro celočíselnou mocninu fungovat.)\nPři volání funkce je nutné zapsat argumenty ve stejném pořadí, v jakém jsou definovány příslušné parametry:\n&gt;&gt;&gt; mocnina(3,4)\n81\n&gt;&gt;&gt; mocnina(4,3)\n64\nPokud bychom chtěli z nějakého důvodu zadat argumenty v jiném pořadí, než jak jsou definovány argumenty, je možné použít při volání funkce explicitně jména příslušných parametrů a operátor =:\n&gt;&gt;&gt; mocnina(y=4, x=3)\n81\nZadávání argumentů jménem parametru je výhodné u funkcí s velkým počtem parametrů: muset si pamatovat jejich pořadí by bylo nepraktické.\nParametry mohou mít tzv. implicitní neboli výchozí hodnotu, takže je pak není nutné při volání funkce zadávat. Pokud příslušný argument nezadáme, použije se tato výchozí hodnota. Parametry s implicitní hodnotou je však nutné umístit v definici funkce na konec, tj. až za parametry bez implicitních hodnot. Důvodem je, aby parametrům bez implicitních hodnot bylo možné zadávat hodnoty na základě pořadí.\nUkažme si definování implicitní hodnoty na příkladu funkce mocnina. Pokud definujeme implicitní hodnotu parametru y jako 2, bude funkce při zadání pouze jednoho argumentu počítat jeho druhou mocninu:\ndef mocnina(x, y = 2):\n    vysledek = 1\n    for i in range(y): vysledek = vysledek * x\n    return vysledek\nPo zavolání v okně Python Shell:\n&gt;&gt;&gt; mocnina(4) # Zde bude použita implicitní hodnota parametru y\n16\n&gt;&gt;&gt; mocnina(4, 3) # Zde bude použita uživatelem specifikovaná hodnota parametru y\n64\nSamozřejmě výsledek volání funkce lze uložit do proměnné, tak jak to znáte při používání vestavěných funkcí Pythonu (např. input, range či konverzní funkce int apod.):\n&gt;&gt;&gt; a = mocnina(4)\n&gt;&gt;&gt; print a\n16\nStejně tak argumenty funkce mohou být zadávány přímo pomocí hodnot (viz ukázky výše), nebo pomocí proměnných:\n&gt;&gt;&gt; a = 4\n&gt;&gt;&gt; b = 5\n&gt;&gt;&gt; mocnina(a, b)\n1024\nJak jsme se již zmínili, funkce mohou, ale nemusí mít návratovou hodnotu. Pokud funkce pouze něco vykoná, ale nic nevrátí, říká se jít někdy procedura. Pozná se podle toho, že v definici neobsahuje klíčové slovo return. Příkladem může být funkce, která výsledek výpočtu zapíše do textového souboru:\n# funkce, která otevře textový soubor a vytvoří nový, se zrcadlově obráceným textem\ndef prevrat_text(txt_in, txt_out):\n    \n    # přečtení vstupního textového souboru\n    in_file = open(txt_in, \"r\")\n    in_text = in_file.read()\n    in_file.close()\n    \n    # zápis výstupního souboru se zrcadlově otočeným textem\n    out_file = open(txt_out, \"w\")\n    for i in range(len(in_text), 0, -1):\n        out_file.write(in_text[i-1])\n    out_file.close()\nPokud volání takové funkce (procedury) uložíme do nějaké proměnné, nebude tato proměnná nic obsahuje (bude odkazovat na objekt None). Přesto funkce (procedura) svou práci odvede.\n\nÚkol 1. Napište funkci pro výpočet n-tého členu Fibonacciho posloupnosti.\n\n\nÚkol 2. Napište funkci, která otevře daný textový soubor a vrátí počet jeho slov (parametrem funkce bude textový řetězec s adresou souboru).\n\n\n\n\nJména proměnných a funkcí existují vždy v nějaké jmenném prostoru (angl. namespace), někdy též oboru platnosti (angl. scope), podle toho, kde byly definovány. Uvnitř tohoto jmenného prostoru je pak proměnná či funkce “vidět”, tj. lze se na tam na ně odkazovat. Jmenné prostory jsou hierarchisky uspořádány:\n\nZákladním jmenným prostorem je tzv. vestavěný jmenný prostor, obsahující např. jména vestavěných funkcí jako range či print. Jelikož jsou tato jména definována ve vestavěném prostoru, jsou dostupná v jakékoli části kódu v jazyce Python (tj. ve všech hierarchicky nižších jmenných prostorech).\nO jednu hierarchickou úroveň níže je tzv. globální jmenný prostor. Ten vzniká automaticky při otevření konzole Python Shell (resp. při spuštění skriptu). Pokud konzoli otevřeme spuštěním programu IDLE z nabídky programů, případně ji restartujeme pomocí Shell -&gt; Restart Shell, globální jmenný prostor se nastaví jako prázdný. Při jakémkoli vytvoření proměnné či funkce se následně dané jméno přidá do globálního prostoru, díky čemuž s ním nadále můžeme v tomto prostoru pracovat. Opětovné restartování konzole však globální jmenný prostor opět vyprázdní:\n\n&gt;&gt;&gt; a = 5 # Vytvoření proměnné v globálním jmenném prostoru\n&gt;&gt;&gt; a # Proměnná existuje...\n5\n&gt;&gt;&gt; \n=============================== RESTART: Shell ===============================\n&gt;&gt;&gt; a # Po restartu konzole již proměnná v globálním jmenném prostoru není:\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;\n    a\nNameError: name 'a' is not defined\n\nPoslední hierarchickou úrovní jsou tzv. lokální jmenné prostory, které jsou přiřazeny funkcím. V praxi to znamená, že pokud v těle funkce definuji nějakou proměnnou, tato proměnná existuje (“je vidět”) pouze v lokálním jmenném prostoru této funkce. Uvnitř funkce se proto na tuto proměnnou mohu odkazovat, vně funkce však nikoli:\n\n&gt;&gt;&gt; def my_function(): a = 5 # Zde jsme definovali lokální proměnnou ve jmenném prostoru funkce\n&gt;&gt;&gt; a # Zde vidíme, že vně funkce tato proměnná neexistuje\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#17&gt;\", line 1, in &lt;module&gt;\n    a\nNameError: name 'a' is not defined\nPokud se kdekoli v kódu odkazujeme na nějaké jméno (tj. proměnnou či funkci), překladač nejprve jméno hledá v příslušném lokálním jmenném prostoru. Pokud tam takové jméno nenajde, pokračuje prohledáváním globálního jmenného prostoru. Pokud ani tam neuspěje, prohledává vestavěný jmenný prostor. Pokud neuspěje ani tam, výsledkem je chybové hlášení NameError: name is not defined (viz předchozí ukázku).\nPopsaná hierarchie se mimo jiné projevuje v tom, že pokud v lokálním prostoru definujeme nějaké jméno, které je shodné s jiným jméněm definovaným v globálním či vestavěném prostoru, bude mít toto lokální jméno vždy přednost. V následujícím kódu používáme jméno range k vytvoření proměnné, do které ukládáme textový řetězec. Víme, že ve vestavěnném jmenném prostoru jde o jméno funkce, vytvářející posloupnost čísel. Pokud nicméně následně chceme tuto funkci volat, jméno range je nejprve nalezeno v lokálním jmenném prostoru, kde jde ovšem o proměnnou a nikoli o funkci. Výsledkem je tedy chybové hlášení, že textový řetězec nelze volat jako funkci (TypeError: 'str' object is not callable):\n&gt;&gt;&gt; range = \"Some text.\"\n&gt;&gt;&gt; range(5)\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#26&gt;\", line 1, in &lt;module&gt;\n    range(5)\nTypeError: 'str' object is not callable\nPři vytváření jmen je tedy nutné dávat pozor, abychom “nepřepsali” nějaké jméno z některého nadřazeného jmenného prostoru.\nLokálních jmenných prostorů může být více do sebe vnořených: můžeme totiž definovat funkci uvnitř jiné funkce. Taková vnořená funkce pak bude použitelná (tj. volatelná) pouze v rámci této nadřazené funkce. (Příklad neuvádíme.)\n\nVe skutečnosti jsme v hierarchii jmenných prostorů vynechali jmenné prostory objektů a tříd. K těm se ale vrátíme až v příslušné kapitole, pojednávající o objektovém programování v Pythonu.\n\nCo když při volání funkce zadáme její argument pomocí nějaké již existující proměnné? V jakém jmenném prostoru bude tato proměnná existovat? Změní se hodnota této původní proměnné, pokud funkce obsahuje kód, který nějak mění odpovídající parametr? Ilustrujme si otázku na příkladu: máme funkci, do které vstupuje nějaký seznam, přičemž funkce do něj přidá další prvek s hodnotou 1 (metodou append), aniž by tento změněný seznam vrátila příkazem return:\ndef add_one(my_list):\n    my_list.append(1)\nZavoláme-li funkci na nějaký konkrétní seznam, ovlivní ho to, nebo ne?\nV programovacích jazycích obecně existují dva způsoby, jak funkce nakládají se svými argumenty, tj. s hodnotami parametrů zadanými při volání funkce:\n\nargumenty předávané hodnotou - při volání funkce se v jejím lokálním jmenném prostoru vytvoří nová proměnná, do které se zkopíruje pouze hodnota argumentu. Tato lokální proměnná je tedy nezávislá na původní proměnné, která byla použita jako argument. Případná změna této proměnné se proto neprojeví vně funkce. V tomto případě by tedy naše funkce add_one původní seznam nezměnila.\nargumenty předávané odkazem - při volání funkce se v jejím lokálním jmenném prostoru vytvoří nová proměnná, která odkazuje na stejné místo v paměti jako původní proměnná, která byla použita jako argument. To znamená, že pokud nějak změníme hodnotu této lokální proměnné, dotkne se změna i původní proměnné vně funkce. Volání funkce add_one by tedy opravdu změnilo původní seznam.\n\nV Pythonu jsou argumenty vždy předávané odkazem, platí tedy rozhodně druhá možnost (pozor: v jiným jazycích to může být jinak!):\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; add_one(a)\n&gt;&gt;&gt; a\n[1, 2, 3, 1]\nMohli bychom však snadno vymyslet příklad, který se zdánlivě chová opačně. Např. následující funkce dělá prakticky totéž, jako funkce add_one:\ndef add_one2(my_list):\n    my_list = my_list + [1]\nPokud vyzkoušíme její chování, zjistíme, že vnější seznam, předaný jako argument této funkci, zůstane voláním funkce nedotčen:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; add_one2(a)\n&gt;&gt;&gt; a\n[1, 2, 3]\nVe skutečnosti pořád platí, co jsme uvedli výše: seznam a je předán odkazem, a pokud by byl ve funkci opravdu změněn, tato změna by se projevila i vně funkce, tj. změnou tohoto původního seznamu a. Problém je v tom, že funkce add_one2 ve skutečnosti původní seznam nemění, ale namísto toho vytváří seznam nový, na původním nezávislý. Na řádku my_list = my_list + [1] je vytvořena nová proměnná my_list, jejíž hodnota je odvozena od hodnoty původní proměnné my_list (na pravé straně výrazu), která je na ní však již nezávislá (tj. odkazuje na jiné místo v paměti). Tato nová proměnná, jelikož je vytvořena uvnitř funkce, existuje pouze v lokálním jmenném prostoru této funkce. Původní seznam tak zůstává nezměněn.\nPokud bychom chtěli, aby se změna, provedená způsobem my_list = my_list + [1], projevila ve “vnější” proměnné s původním seznamem, mohli bychom výsledek výpočtu funkce předat “ven” pomocí příkazu return:\ndef add_one3(my_list):\n    my_list = my_list + [1]\n    return my_list\nNásledně bychom výsledek funkce uložili do původní proměnné:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; a = add_one3(a)\n&gt;&gt;&gt; a\n[1, 2, 3, 1]\n\n\n\nModul je soubor se zdrojovým kódem, obsahujícím především definice nejrůznějších funkcí (ale i jiných objektů, jako jsou proměnné, třídy ad.). Význam modulu je v tom, že umožňuje použití v něm definovaných funkcí (či jiných objektů) v libovolném kódu, aniž bychom museli tyto funkce v daném kódu definovat. V modulu jsou tyto funkce již definovány a nám stačí je z daného modulu načíst.\nModul se vlastně formálně nijak neliší od jakéhokoli skriptu. Není to nic jiného než textový soubor s příponou .py. Ve skutečnosti je možné to chápat i opačně a považovat jakýkoli skript za modul. V praxi se však pojmenování modul používá pro skripty obsahující téměř výhradně definice funkcí (či tříd). Moduly tak často hrají roli jakýchsi knihoven funkcí, použitelných v jakémkoli jiném skriptu či přímo v interaktivním okně Python Shell.\nVedle modulů existují v terminologii Pythonu ještě tzv. balíčky (site-packages). Jejich význam je stejný jako u modulů, rozdíl je pouze v tom, že mají složitější strukturu, díky níž může jeden balíček obsahovat řadu modulů. Vzhledem k tomu, že používání balíčků se formálně nijak neliší od používání modulů, nebudeme v tomto textu mezi balíčky a moduly rozlišovat a zůstaneme u souhrnného označení modul. Moduly obsažené uvnitř balíčků pak budeme v případě potřeby označovat jako pod-moduly.\nJak již víte, pokud chceme použít funkce nějakého modulu, je třeba modul načíst pomocí příkazu import. Syntaxe je tedy:\nimport nazev_modulu\nNázev modulu se uvádí bez koncovky .py a bez udání jeho umístění na disku. Příslušný modul samozřejmě musí existovat a musí být umístěn v některé ze složek, v nichž jsou moduly při použití příkazu import vyhledávány. (Jak zjistit či ovlivnit, které složky v počítači jsou při načítání modulů prohledávány, si povíme v další části.)\nPo načtení modulu máme k dispozici veškeré funkce, které jsou v něm definovány. Jinými slovy, příslušná jména jsou přidána do globálního jmenného prostoru, ovšem s předponou nazev_modulu.. K příslušným funkcím (či proměnným a jiným objektům) tak musíme přistupovat následovně:\nnazev_modulu.nazev_funkce(argumenty)\nPříklad modulu os:\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.getcwd()\n'C:\\\\my_path\\\\pracovni_adresar'\nChceme-li z nějakého modulu použít jen nějakou jeho část, např. jen jednu funkci, můžeme namísto celého modulu načíst jen tuto jeho část:\nfrom nazev_modulu import nazev_funkce\nNačtenou funkci pak mámek dispozici přímo, tj. nemusíme (a ani nemůžeme) k ní přistupovat pomocí uvedení názvu modulu a tečky. Příslušné jméno je přidáno přímo do globálního jmenného prostoru:\n&gt;&gt;&gt; from os import getcwd\n&gt;&gt;&gt; getcwd()\n'C:\\\\my_path\\\\pracovni_adresar'\nStejnou syntax můžeme použít i pro načtení pod-modulů, jak jsme již uvedli v lekci 7 na příkladu modulu path z balíčku os:\n# Varianta s načtením celého balíčku os\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.path.join(\"C:\", \"my_path\", \"my_file.txt\")\n'C:\\\\my_path\\\\my_file.txt'\n\n# Varianta s načtením pouze modulu path\n&gt;&gt;&gt; from os import path\n&gt;&gt;&gt; path.join(\"C:\", \"my_path\", \"my_file.txt\")\n'C:my_path\\\\my_file.txt'\nPodobně můžeme načíst všechny funkce z daného modulu naráz, ale způsobem uvedeným výše, tj. vlastně každou zvlášť:\nfrom nazev_modulu import *\nVšechny funkce či pod-moduly daného modulu jsou pak přístupné přímo přes své jméno, aniž bychom uváděli jméno modulu. Jsou totiž přidány přímo do globálního jmenného prostoru. Tato praxe však není doporučována, a to z následujících důvodů:\n\nZtrácíme přehled o tom, kde se vlastně jednotlivé funkce vzaly, tj. zda jsme je definovali sami, případně z jakého modulu je načítáme.\nV případě, že více modulů obsahuje funkce (či jiné objekty) stejného jména, které však dělají něco jiného (to se může v praxi snadno stát), ztrácíme přehled, kterou z daných funkcí vlastně voláme.\nJména načtených funkcí (či jiných objektů) se smíchají s ostatními jmény globálního jmenného prostoru, takže může dojít ke konfliktu jmen z modulu a jmen, která jsme sami vytvořili (např. nějaká naše proměnná se může jmenovat stejně jako nějaká funkce z daného modulu).\n\nJméno modulu můžeme při načtení nahradit nějakým vlastním, zpravidla kratším jménem:\nimport nazev_modulu as vlastni_kratsi_nazev\nvlastni_kratsi_nazev.funkce_modulu()\nPříklad:\n&gt;&gt;&gt; import random as rnd\n&gt;&gt;&gt; rnd.random()\n0.5218355675703937\n\n\n\nVytvořit vlastní modul je stejně jednoduché, jako napsat skript. Je to vlastně totéž. Pro ukázku si vytvořme jednoduchý modul, nazvaný matematika, který bude obsahovat dvě funkce, obsah_kruhu a obvod_kruhu. Vytvořte skript s následujícím kódem:\n\"\"\"Toto je modul s funkcemi pro vypocet obsahu a objemu kruhu.\"\"\"\npi = 3.1416\n\ndef obvod_kruhu(r):\n    \"\"\"Tato funkce pocita obvod kruhu o polomeru r.\"\"\"\n    return 2*pi*r\n\ndef obsah_kruhu(r):\n    \"\"\"Tato funkce pocita obsah kruhu o polomeru r.\"\"\"\n    return pi*r*r\nNásledně skript uložte do pracovního adresáře pod názvem matematika.py. (Připomínáme, že aktuální pracovní adresář zjistíte pomocí funkce getcwd z modulu os, případně jej můžete změnit funkcí chdir ze stejného modulu.)\nNyní je možné skript normálně spustit (např. klávesovou zkratkou F5) tak, jak jsme zvyklí spouštět skripty. Výsledkem je, že se obsah skriptu nahraje do okna Python Shell (a je tudíž přístupný pomocí procházení paměti příkazů), takže jednotlivé funkce ve skriptu definované jsou přímo přístupné pod svým názvem (naopak ale nebudou přístupné pod názvem modulu, protože ve skutečnosti nedošlo k jeho načtení).\nJinou možností, o kterou nám v tuto chvíli jde, je načtení modulu z okna Python Shell pomocí příkazu import:\n&gt;&gt;&gt; import matematika\nNyní lze k funkcím a proměnným modulu přistupovat přes název modulu:\n&gt;&gt;&gt; import matematika\n&gt;&gt;&gt; matematika.pi\n3.1416\n&gt;&gt;&gt; matematika.obvod_kruhu(4)\n25.1328\n&gt;&gt;&gt; matematika.obsah_kruhu(4)\n50.2656\nZbývá vysvětlit, k čemu jsou dobré textové řetězce na začátku výše uvedeného skriptu a uvnitř definic obou uvedených funkcí. Tyto textové řetězce jsou nepovinné, tj. modul i funkce by stejně dobře fungovaly i bez nich. Uvedli jsme je v této ukázce proto, abychom ukázali možnost psát dokumentační řetězce, v nichž je zpravidla uvedena popisná informace o účelu daného modulu či funkce. Dokumentační řetězec, pokud existuje, je možné vyvolat zavolání jména modulu či funkce, tečky a řetězce __doc__ (pozor: před i za slovem doc jsou vždy dvě podtržítka):\n&gt;&gt;&gt; matematika.__doc__\n'Toto je modul s funkcemi pro vypocet obsahu a objemu kruhu.'\n&gt;&gt;&gt; matematika.obsah_kruhu.__doc__\n'Tato funkce pocita obsah kruhu o polomeru r.'\nBudeme-li již načtený modul upravovat a následně jej znovu načteme příkazem import, modul ve skutečnosti znovu načten nebude a provedené změny se tudíž neprojeví. Příkaz import totiž nejprve zkontroluje, zda příslušný modul již není načtený, a pokud ne načte jej. Pokud ano, neudělá nic. K tomu, abychom již načtený modul načetly znovu, je třeba použít vestavěnou funkci reload:\n&gt;&gt;&gt; reload(matematika)\n&lt;module 'matematika' from 'C:\\Python25\\matematika.pyc'&gt;\nNyní zbývá vyřešit, kam vlastně moduly ukládat, abychom je mohli načítat příkazem import. Pokud zavoláme příkaz import a uvedeme název nějakého modulu, interpret načte první modul zadaného jména, který nalezne ve složkách, v nichž moduly hledá. Jaké složky to jsou, lze zjistit pomocí proměnné path definované v modulu sys. Tato proměnná obsahuje seznam adres, které se mají při načítání modulů prohledávat. K jejímu zavolání je třeba samozřejmě nejprve načíst modul sys:\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.path\n['C:\\\\Python25\\\\Lib\\\\idlelib', 'C:\\\\Program Files\\\\ArcGIS\\\\bin', 'C:\\\\WINDOWS\\\\system32\\\\python25.zip', 'C:\\\\Python25\\\\DLLs', 'C:\\\\Python25\\\\lib', 'C:\\\\Python25\\\\lib\\\\plat-win', 'C:\\\\Python25\\\\lib\\\\lib-tk', 'C:\\\\Python25', 'C:\\\\Python25\\\\lib\\\\site-packages']\nKonkrétní obsah seznamu bude samozřejmě záviset na konkrétním počítači.\nPokud budeme chtít k tomuto seznamu nějakou složku přidat, je možné proměnnou path změnit standardním způsobem, jakým se pracuje se seznamy:\n&gt;&gt;&gt; sys.path.append(\"C:\\\\Moje_slozka\")\n&gt;&gt;&gt; sys.path\n['C:\\\\Python25\\\\Lib\\\\idlelib', 'C:\\\\Program Files\\\\ArcGIS\\\\bin', 'C:\\\\WINDOWS\\\\system32\\\\python25.zip', 'C:\\\\Python25\\\\DLLs', 'C:\\\\Python25\\\\lib', 'C:\\\\Python25\\\\lib\\\\plat-win', 'C:\\\\Python25\\\\lib\\\\lib-tk', 'C:\\\\Python25', 'C:\\\\Python25\\\\lib\\\\site-packages', 'C:\\\\Moje_slozka']\nTímto způsobem můžeme do proměnné path přidat složky, v nichž máme uložené moduly. Tuto akci však budeme muset udělat vždy znovu, kdykoli spustíme Python. Jinou možností je ukládat moduly do složky, která již v seznamu proměnné path je. Tento způsobe však není vhodný, neboť při přeinstalování Pythonu jsou tyto složky většinou smazány a s nimi i vše, co obsahují. Vhodnější je proto např. do kódu programu, v němž budeme chtít načítat nějaké vlastní moduly, rovnou vložit příkaz s aktualizací proměnné path.\nJinou možností je ukládat moduly do stejné složky, v níž je uložen samotný program (či „hlavní skript“), neboť do proměnné path je vždy automaticky přidána aktuální pracovní složka (tj. např. složka, z níž je spouštěn nějaký skript).\nJiný způsob, jak prohlížet složky s moduly, je pomocí prohlížeče Path Browser, umístěného v hlavní nabídce okna Python Shell pod File -&gt; Path Browser. Okno prohlížeče vypadá následovně:\n\n\n\nimage-20201102183750177\n\n\n\n\n\n\n\n\n\nNapište funkci, která vrátí maximum resp. minimum ze zadaného seznamu čísel (řešte bez použití vestavěné funkce max resp. min).\nNapište funkci, která seřadí vzestupně (sestupně) zadaný seznam čísel (řešte bez použití metody seznamu sort). (Nápověda: můžete použít např. algoritmus “řazení výběrem”, “řazení vkládáním” či “bublinkové řazení”. Pro přehled různých přístupů viz např. tento odkaz na wikipedii.)"
  },
  {
    "objectID": "material/old_materials/Lekce 8 Funkce a moduly.html#definice-a-volání-funkce",
    "href": "material/old_materials/Lekce 8 Funkce a moduly.html#definice-a-volání-funkce",
    "title": "Lekce 8: Funkce a moduly",
    "section": "",
    "text": "Často nastává situace, kdy nějakou část kódu chceme používat opakovaně. Například můžeme chtít opakovaně v našem programu počítat faktoriál nějakého čísla (přičemž toto číslo může být pokaždé jiné). Výpočet faktoriálu jsme si ukázali v kapitole o cyklu for, řešení může vypadat třeba takto:\nfaktorialn = 1\nfor i in range(n): faktorialn = faktorialn * (i+1)\nprint faktorialn\n„Nejprimitivnější“ možností by bylo vložit tento kód všude tam, kde v kódu potřebujeme počítat faktoriál, samozřejmě vždy s patřičně změněnou hodnotou n.\nProblém takového řešení nastává ve chvíli, kdy budeme chtít samotný výpočet faktoriálu změnit – např. pokud bychom zjistili, že jsme v původním kódu udělali chybu a je třeba jej opravit. Máme-li totiž výše uvedený kód v našem programu na mnoha místech, je třeba jej (správně) přepsat na každém takovém místě. To je značně nepohodlné a navíc se při tom snadno dopustíme chyb.\nElegantnějším řešením je vytvořit (tj. definovat) funkci, která bude výpočet faktoriálu provádět, a tuto funkci pak na příslušných místech volat.\nStruktura zápisu definice funkce je následující:\ndef nazev_funkce(parametr1, parametr2, ... , parametrN):\n    tělo funkce\nDefinice je uvozena klíčovým slovem def, podle kterého interpret pozná, že se jedná o definici funkce. Následuje libovolný název a v závorkách posloupnost tzv. parametrů, tj. proměnných zastupujících hodnoty vstupující do výpočtu, který má funkce provádět. Tělo funkce pak obsahuje příkazy (psané na samostatné řádky odsazené o jednu úroveň za slovo def), které obvykle něco provádějí s parametry. Ukažme si funkci na konkrétním příkladu výpočtu faktoriálu:\ndef faktorial(n):\n    faktorialn = 1\n    for i in range(n): faktorialn = faktorialn * (i+1)\n    return faktorialn\nKlíčové slovo return ukončuje definici funkce (není však povinné, jak uvidíme níže), přičemž stanoví, jaká hodnota má být funkcí vrácena při jejím volání.\nPokud odešleme kód s definicí funkce do překladače (resp. interpretu), není výsledkem provedení příslušných příkazů uvedených v těle funkce, ale pouze je funkce uložena v operační paměti a je ji možné kdykoli tzv. zavolat. Volání funkce má strukturu analogickou její definici:\nnazev_funkce(argmunet1, argument2, ... , argumentN)\nJednotlivé argumenty přesně odpovídají jednotlivým parametrům funkce, jsou vlastně konkrétními hodnotami, které se při volání funkce za jednotlivé parametry dosadí. Ukažme si volání funkce opět na příkladu faktoriálu, přičemž budeme funkci definovanou výše volat v okně Python Shell:\n&gt;&gt;&gt; faktorial(3)\n6\n&gt;&gt;&gt; faktorial(6)\n720\n&gt;&gt;&gt; faktorial(10)\n3628800\nVýhoda tohoto řešení je zřejmá: kdykoli lze nyní použít funkci faktorial s libovolným celočíselným argumentem, přičemž pokud bychom chtěli funkci nějak změnit, stačí tak učinit pouze jednou, v samotné její definici.\nUveďme příklad funkce s více než jedním parametrem, např. funkci, která počítá zadanou celočíselnou mocninu zadaného čísla:\ndef mocnina(x,y):\n    vysledek = 1\n    for i in range(y): vysledek = vysledek * x\n    return vysledek\n(Samozřejmě jsme mohli funkci definovat i jednodušeji: def mocnina(x,y): return x**y. Prozkoumejte nicméně uvedenou složitější definici a uvědomte si, že bude pro celočíselnou mocninu fungovat.)\nPři volání funkce je nutné zapsat argumenty ve stejném pořadí, v jakém jsou definovány příslušné parametry:\n&gt;&gt;&gt; mocnina(3,4)\n81\n&gt;&gt;&gt; mocnina(4,3)\n64\nPokud bychom chtěli z nějakého důvodu zadat argumenty v jiném pořadí, než jak jsou definovány argumenty, je možné použít při volání funkce explicitně jména příslušných parametrů a operátor =:\n&gt;&gt;&gt; mocnina(y=4, x=3)\n81\nZadávání argumentů jménem parametru je výhodné u funkcí s velkým počtem parametrů: muset si pamatovat jejich pořadí by bylo nepraktické.\nParametry mohou mít tzv. implicitní neboli výchozí hodnotu, takže je pak není nutné při volání funkce zadávat. Pokud příslušný argument nezadáme, použije se tato výchozí hodnota. Parametry s implicitní hodnotou je však nutné umístit v definici funkce na konec, tj. až za parametry bez implicitních hodnot. Důvodem je, aby parametrům bez implicitních hodnot bylo možné zadávat hodnoty na základě pořadí.\nUkažme si definování implicitní hodnoty na příkladu funkce mocnina. Pokud definujeme implicitní hodnotu parametru y jako 2, bude funkce při zadání pouze jednoho argumentu počítat jeho druhou mocninu:\ndef mocnina(x, y = 2):\n    vysledek = 1\n    for i in range(y): vysledek = vysledek * x\n    return vysledek\nPo zavolání v okně Python Shell:\n&gt;&gt;&gt; mocnina(4) # Zde bude použita implicitní hodnota parametru y\n16\n&gt;&gt;&gt; mocnina(4, 3) # Zde bude použita uživatelem specifikovaná hodnota parametru y\n64\nSamozřejmě výsledek volání funkce lze uložit do proměnné, tak jak to znáte při používání vestavěných funkcí Pythonu (např. input, range či konverzní funkce int apod.):\n&gt;&gt;&gt; a = mocnina(4)\n&gt;&gt;&gt; print a\n16\nStejně tak argumenty funkce mohou být zadávány přímo pomocí hodnot (viz ukázky výše), nebo pomocí proměnných:\n&gt;&gt;&gt; a = 4\n&gt;&gt;&gt; b = 5\n&gt;&gt;&gt; mocnina(a, b)\n1024\nJak jsme se již zmínili, funkce mohou, ale nemusí mít návratovou hodnotu. Pokud funkce pouze něco vykoná, ale nic nevrátí, říká se jít někdy procedura. Pozná se podle toho, že v definici neobsahuje klíčové slovo return. Příkladem může být funkce, která výsledek výpočtu zapíše do textového souboru:\n# funkce, která otevře textový soubor a vytvoří nový, se zrcadlově obráceným textem\ndef prevrat_text(txt_in, txt_out):\n    \n    # přečtení vstupního textového souboru\n    in_file = open(txt_in, \"r\")\n    in_text = in_file.read()\n    in_file.close()\n    \n    # zápis výstupního souboru se zrcadlově otočeným textem\n    out_file = open(txt_out, \"w\")\n    for i in range(len(in_text), 0, -1):\n        out_file.write(in_text[i-1])\n    out_file.close()\nPokud volání takové funkce (procedury) uložíme do nějaké proměnné, nebude tato proměnná nic obsahuje (bude odkazovat na objekt None). Přesto funkce (procedura) svou práci odvede.\n\nÚkol 1. Napište funkci pro výpočet n-tého členu Fibonacciho posloupnosti.\n\n\nÚkol 2. Napište funkci, která otevře daný textový soubor a vrátí počet jeho slov (parametrem funkce bude textový řetězec s adresou souboru)."
  },
  {
    "objectID": "material/old_materials/Lekce 8 Funkce a moduly.html#jmenné-prostory-a-předávání-argumentů-funkcí",
    "href": "material/old_materials/Lekce 8 Funkce a moduly.html#jmenné-prostory-a-předávání-argumentů-funkcí",
    "title": "Lekce 8: Funkce a moduly",
    "section": "",
    "text": "Jména proměnných a funkcí existují vždy v nějaké jmenném prostoru (angl. namespace), někdy též oboru platnosti (angl. scope), podle toho, kde byly definovány. Uvnitř tohoto jmenného prostoru je pak proměnná či funkce “vidět”, tj. lze se na tam na ně odkazovat. Jmenné prostory jsou hierarchisky uspořádány:\n\nZákladním jmenným prostorem je tzv. vestavěný jmenný prostor, obsahující např. jména vestavěných funkcí jako range či print. Jelikož jsou tato jména definována ve vestavěném prostoru, jsou dostupná v jakékoli části kódu v jazyce Python (tj. ve všech hierarchicky nižších jmenných prostorech).\nO jednu hierarchickou úroveň níže je tzv. globální jmenný prostor. Ten vzniká automaticky při otevření konzole Python Shell (resp. při spuštění skriptu). Pokud konzoli otevřeme spuštěním programu IDLE z nabídky programů, případně ji restartujeme pomocí Shell -&gt; Restart Shell, globální jmenný prostor se nastaví jako prázdný. Při jakémkoli vytvoření proměnné či funkce se následně dané jméno přidá do globálního prostoru, díky čemuž s ním nadále můžeme v tomto prostoru pracovat. Opětovné restartování konzole však globální jmenný prostor opět vyprázdní:\n\n&gt;&gt;&gt; a = 5 # Vytvoření proměnné v globálním jmenném prostoru\n&gt;&gt;&gt; a # Proměnná existuje...\n5\n&gt;&gt;&gt; \n=============================== RESTART: Shell ===============================\n&gt;&gt;&gt; a # Po restartu konzole již proměnná v globálním jmenném prostoru není:\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;\n    a\nNameError: name 'a' is not defined\n\nPoslední hierarchickou úrovní jsou tzv. lokální jmenné prostory, které jsou přiřazeny funkcím. V praxi to znamená, že pokud v těle funkce definuji nějakou proměnnou, tato proměnná existuje (“je vidět”) pouze v lokálním jmenném prostoru této funkce. Uvnitř funkce se proto na tuto proměnnou mohu odkazovat, vně funkce však nikoli:\n\n&gt;&gt;&gt; def my_function(): a = 5 # Zde jsme definovali lokální proměnnou ve jmenném prostoru funkce\n&gt;&gt;&gt; a # Zde vidíme, že vně funkce tato proměnná neexistuje\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#17&gt;\", line 1, in &lt;module&gt;\n    a\nNameError: name 'a' is not defined\nPokud se kdekoli v kódu odkazujeme na nějaké jméno (tj. proměnnou či funkci), překladač nejprve jméno hledá v příslušném lokálním jmenném prostoru. Pokud tam takové jméno nenajde, pokračuje prohledáváním globálního jmenného prostoru. Pokud ani tam neuspěje, prohledává vestavěný jmenný prostor. Pokud neuspěje ani tam, výsledkem je chybové hlášení NameError: name is not defined (viz předchozí ukázku).\nPopsaná hierarchie se mimo jiné projevuje v tom, že pokud v lokálním prostoru definujeme nějaké jméno, které je shodné s jiným jméněm definovaným v globálním či vestavěném prostoru, bude mít toto lokální jméno vždy přednost. V následujícím kódu používáme jméno range k vytvoření proměnné, do které ukládáme textový řetězec. Víme, že ve vestavěnném jmenném prostoru jde o jméno funkce, vytvářející posloupnost čísel. Pokud nicméně následně chceme tuto funkci volat, jméno range je nejprve nalezeno v lokálním jmenném prostoru, kde jde ovšem o proměnnou a nikoli o funkci. Výsledkem je tedy chybové hlášení, že textový řetězec nelze volat jako funkci (TypeError: 'str' object is not callable):\n&gt;&gt;&gt; range = \"Some text.\"\n&gt;&gt;&gt; range(5)\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#26&gt;\", line 1, in &lt;module&gt;\n    range(5)\nTypeError: 'str' object is not callable\nPři vytváření jmen je tedy nutné dávat pozor, abychom “nepřepsali” nějaké jméno z některého nadřazeného jmenného prostoru.\nLokálních jmenných prostorů může být více do sebe vnořených: můžeme totiž definovat funkci uvnitř jiné funkce. Taková vnořená funkce pak bude použitelná (tj. volatelná) pouze v rámci této nadřazené funkce. (Příklad neuvádíme.)\n\nVe skutečnosti jsme v hierarchii jmenných prostorů vynechali jmenné prostory objektů a tříd. K těm se ale vrátíme až v příslušné kapitole, pojednávající o objektovém programování v Pythonu.\n\nCo když při volání funkce zadáme její argument pomocí nějaké již existující proměnné? V jakém jmenném prostoru bude tato proměnná existovat? Změní se hodnota této původní proměnné, pokud funkce obsahuje kód, který nějak mění odpovídající parametr? Ilustrujme si otázku na příkladu: máme funkci, do které vstupuje nějaký seznam, přičemž funkce do něj přidá další prvek s hodnotou 1 (metodou append), aniž by tento změněný seznam vrátila příkazem return:\ndef add_one(my_list):\n    my_list.append(1)\nZavoláme-li funkci na nějaký konkrétní seznam, ovlivní ho to, nebo ne?\nV programovacích jazycích obecně existují dva způsoby, jak funkce nakládají se svými argumenty, tj. s hodnotami parametrů zadanými při volání funkce:\n\nargumenty předávané hodnotou - při volání funkce se v jejím lokálním jmenném prostoru vytvoří nová proměnná, do které se zkopíruje pouze hodnota argumentu. Tato lokální proměnná je tedy nezávislá na původní proměnné, která byla použita jako argument. Případná změna této proměnné se proto neprojeví vně funkce. V tomto případě by tedy naše funkce add_one původní seznam nezměnila.\nargumenty předávané odkazem - při volání funkce se v jejím lokálním jmenném prostoru vytvoří nová proměnná, která odkazuje na stejné místo v paměti jako původní proměnná, která byla použita jako argument. To znamená, že pokud nějak změníme hodnotu této lokální proměnné, dotkne se změna i původní proměnné vně funkce. Volání funkce add_one by tedy opravdu změnilo původní seznam.\n\nV Pythonu jsou argumenty vždy předávané odkazem, platí tedy rozhodně druhá možnost (pozor: v jiným jazycích to může být jinak!):\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; add_one(a)\n&gt;&gt;&gt; a\n[1, 2, 3, 1]\nMohli bychom však snadno vymyslet příklad, který se zdánlivě chová opačně. Např. následující funkce dělá prakticky totéž, jako funkce add_one:\ndef add_one2(my_list):\n    my_list = my_list + [1]\nPokud vyzkoušíme její chování, zjistíme, že vnější seznam, předaný jako argument této funkci, zůstane voláním funkce nedotčen:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; add_one2(a)\n&gt;&gt;&gt; a\n[1, 2, 3]\nVe skutečnosti pořád platí, co jsme uvedli výše: seznam a je předán odkazem, a pokud by byl ve funkci opravdu změněn, tato změna by se projevila i vně funkce, tj. změnou tohoto původního seznamu a. Problém je v tom, že funkce add_one2 ve skutečnosti původní seznam nemění, ale namísto toho vytváří seznam nový, na původním nezávislý. Na řádku my_list = my_list + [1] je vytvořena nová proměnná my_list, jejíž hodnota je odvozena od hodnoty původní proměnné my_list (na pravé straně výrazu), která je na ní však již nezávislá (tj. odkazuje na jiné místo v paměti). Tato nová proměnná, jelikož je vytvořena uvnitř funkce, existuje pouze v lokálním jmenném prostoru této funkce. Původní seznam tak zůstává nezměněn.\nPokud bychom chtěli, aby se změna, provedená způsobem my_list = my_list + [1], projevila ve “vnější” proměnné s původním seznamem, mohli bychom výsledek výpočtu funkce předat “ven” pomocí příkazu return:\ndef add_one3(my_list):\n    my_list = my_list + [1]\n    return my_list\nNásledně bychom výsledek funkce uložili do původní proměnné:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; a = add_one3(a)\n&gt;&gt;&gt; a\n[1, 2, 3, 1]"
  },
  {
    "objectID": "material/old_materials/Lekce 8 Funkce a moduly.html#práce-s-moduly",
    "href": "material/old_materials/Lekce 8 Funkce a moduly.html#práce-s-moduly",
    "title": "Lekce 8: Funkce a moduly",
    "section": "",
    "text": "Modul je soubor se zdrojovým kódem, obsahujícím především definice nejrůznějších funkcí (ale i jiných objektů, jako jsou proměnné, třídy ad.). Význam modulu je v tom, že umožňuje použití v něm definovaných funkcí (či jiných objektů) v libovolném kódu, aniž bychom museli tyto funkce v daném kódu definovat. V modulu jsou tyto funkce již definovány a nám stačí je z daného modulu načíst.\nModul se vlastně formálně nijak neliší od jakéhokoli skriptu. Není to nic jiného než textový soubor s příponou .py. Ve skutečnosti je možné to chápat i opačně a považovat jakýkoli skript za modul. V praxi se však pojmenování modul používá pro skripty obsahující téměř výhradně definice funkcí (či tříd). Moduly tak často hrají roli jakýchsi knihoven funkcí, použitelných v jakémkoli jiném skriptu či přímo v interaktivním okně Python Shell.\nVedle modulů existují v terminologii Pythonu ještě tzv. balíčky (site-packages). Jejich význam je stejný jako u modulů, rozdíl je pouze v tom, že mají složitější strukturu, díky níž může jeden balíček obsahovat řadu modulů. Vzhledem k tomu, že používání balíčků se formálně nijak neliší od používání modulů, nebudeme v tomto textu mezi balíčky a moduly rozlišovat a zůstaneme u souhrnného označení modul. Moduly obsažené uvnitř balíčků pak budeme v případě potřeby označovat jako pod-moduly.\nJak již víte, pokud chceme použít funkce nějakého modulu, je třeba modul načíst pomocí příkazu import. Syntaxe je tedy:\nimport nazev_modulu\nNázev modulu se uvádí bez koncovky .py a bez udání jeho umístění na disku. Příslušný modul samozřejmě musí existovat a musí být umístěn v některé ze složek, v nichž jsou moduly při použití příkazu import vyhledávány. (Jak zjistit či ovlivnit, které složky v počítači jsou při načítání modulů prohledávány, si povíme v další části.)\nPo načtení modulu máme k dispozici veškeré funkce, které jsou v něm definovány. Jinými slovy, příslušná jména jsou přidána do globálního jmenného prostoru, ovšem s předponou nazev_modulu.. K příslušným funkcím (či proměnným a jiným objektům) tak musíme přistupovat následovně:\nnazev_modulu.nazev_funkce(argumenty)\nPříklad modulu os:\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.getcwd()\n'C:\\\\my_path\\\\pracovni_adresar'\nChceme-li z nějakého modulu použít jen nějakou jeho část, např. jen jednu funkci, můžeme namísto celého modulu načíst jen tuto jeho část:\nfrom nazev_modulu import nazev_funkce\nNačtenou funkci pak mámek dispozici přímo, tj. nemusíme (a ani nemůžeme) k ní přistupovat pomocí uvedení názvu modulu a tečky. Příslušné jméno je přidáno přímo do globálního jmenného prostoru:\n&gt;&gt;&gt; from os import getcwd\n&gt;&gt;&gt; getcwd()\n'C:\\\\my_path\\\\pracovni_adresar'\nStejnou syntax můžeme použít i pro načtení pod-modulů, jak jsme již uvedli v lekci 7 na příkladu modulu path z balíčku os:\n# Varianta s načtením celého balíčku os\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.path.join(\"C:\", \"my_path\", \"my_file.txt\")\n'C:\\\\my_path\\\\my_file.txt'\n\n# Varianta s načtením pouze modulu path\n&gt;&gt;&gt; from os import path\n&gt;&gt;&gt; path.join(\"C:\", \"my_path\", \"my_file.txt\")\n'C:my_path\\\\my_file.txt'\nPodobně můžeme načíst všechny funkce z daného modulu naráz, ale způsobem uvedeným výše, tj. vlastně každou zvlášť:\nfrom nazev_modulu import *\nVšechny funkce či pod-moduly daného modulu jsou pak přístupné přímo přes své jméno, aniž bychom uváděli jméno modulu. Jsou totiž přidány přímo do globálního jmenného prostoru. Tato praxe však není doporučována, a to z následujících důvodů:\n\nZtrácíme přehled o tom, kde se vlastně jednotlivé funkce vzaly, tj. zda jsme je definovali sami, případně z jakého modulu je načítáme.\nV případě, že více modulů obsahuje funkce (či jiné objekty) stejného jména, které však dělají něco jiného (to se může v praxi snadno stát), ztrácíme přehled, kterou z daných funkcí vlastně voláme.\nJména načtených funkcí (či jiných objektů) se smíchají s ostatními jmény globálního jmenného prostoru, takže může dojít ke konfliktu jmen z modulu a jmen, která jsme sami vytvořili (např. nějaká naše proměnná se může jmenovat stejně jako nějaká funkce z daného modulu).\n\nJméno modulu můžeme při načtení nahradit nějakým vlastním, zpravidla kratším jménem:\nimport nazev_modulu as vlastni_kratsi_nazev\nvlastni_kratsi_nazev.funkce_modulu()\nPříklad:\n&gt;&gt;&gt; import random as rnd\n&gt;&gt;&gt; rnd.random()\n0.5218355675703937"
  },
  {
    "objectID": "material/old_materials/Lekce 8 Funkce a moduly.html#jak-vytvořit-vlastní-modul",
    "href": "material/old_materials/Lekce 8 Funkce a moduly.html#jak-vytvořit-vlastní-modul",
    "title": "Lekce 8: Funkce a moduly",
    "section": "",
    "text": "Vytvořit vlastní modul je stejně jednoduché, jako napsat skript. Je to vlastně totéž. Pro ukázku si vytvořme jednoduchý modul, nazvaný matematika, který bude obsahovat dvě funkce, obsah_kruhu a obvod_kruhu. Vytvořte skript s následujícím kódem:\n\"\"\"Toto je modul s funkcemi pro vypocet obsahu a objemu kruhu.\"\"\"\npi = 3.1416\n\ndef obvod_kruhu(r):\n    \"\"\"Tato funkce pocita obvod kruhu o polomeru r.\"\"\"\n    return 2*pi*r\n\ndef obsah_kruhu(r):\n    \"\"\"Tato funkce pocita obsah kruhu o polomeru r.\"\"\"\n    return pi*r*r\nNásledně skript uložte do pracovního adresáře pod názvem matematika.py. (Připomínáme, že aktuální pracovní adresář zjistíte pomocí funkce getcwd z modulu os, případně jej můžete změnit funkcí chdir ze stejného modulu.)\nNyní je možné skript normálně spustit (např. klávesovou zkratkou F5) tak, jak jsme zvyklí spouštět skripty. Výsledkem je, že se obsah skriptu nahraje do okna Python Shell (a je tudíž přístupný pomocí procházení paměti příkazů), takže jednotlivé funkce ve skriptu definované jsou přímo přístupné pod svým názvem (naopak ale nebudou přístupné pod názvem modulu, protože ve skutečnosti nedošlo k jeho načtení).\nJinou možností, o kterou nám v tuto chvíli jde, je načtení modulu z okna Python Shell pomocí příkazu import:\n&gt;&gt;&gt; import matematika\nNyní lze k funkcím a proměnným modulu přistupovat přes název modulu:\n&gt;&gt;&gt; import matematika\n&gt;&gt;&gt; matematika.pi\n3.1416\n&gt;&gt;&gt; matematika.obvod_kruhu(4)\n25.1328\n&gt;&gt;&gt; matematika.obsah_kruhu(4)\n50.2656\nZbývá vysvětlit, k čemu jsou dobré textové řetězce na začátku výše uvedeného skriptu a uvnitř definic obou uvedených funkcí. Tyto textové řetězce jsou nepovinné, tj. modul i funkce by stejně dobře fungovaly i bez nich. Uvedli jsme je v této ukázce proto, abychom ukázali možnost psát dokumentační řetězce, v nichž je zpravidla uvedena popisná informace o účelu daného modulu či funkce. Dokumentační řetězec, pokud existuje, je možné vyvolat zavolání jména modulu či funkce, tečky a řetězce __doc__ (pozor: před i za slovem doc jsou vždy dvě podtržítka):\n&gt;&gt;&gt; matematika.__doc__\n'Toto je modul s funkcemi pro vypocet obsahu a objemu kruhu.'\n&gt;&gt;&gt; matematika.obsah_kruhu.__doc__\n'Tato funkce pocita obsah kruhu o polomeru r.'\nBudeme-li již načtený modul upravovat a následně jej znovu načteme příkazem import, modul ve skutečnosti znovu načten nebude a provedené změny se tudíž neprojeví. Příkaz import totiž nejprve zkontroluje, zda příslušný modul již není načtený, a pokud ne načte jej. Pokud ano, neudělá nic. K tomu, abychom již načtený modul načetly znovu, je třeba použít vestavěnou funkci reload:\n&gt;&gt;&gt; reload(matematika)\n&lt;module 'matematika' from 'C:\\Python25\\matematika.pyc'&gt;\nNyní zbývá vyřešit, kam vlastně moduly ukládat, abychom je mohli načítat příkazem import. Pokud zavoláme příkaz import a uvedeme název nějakého modulu, interpret načte první modul zadaného jména, který nalezne ve složkách, v nichž moduly hledá. Jaké složky to jsou, lze zjistit pomocí proměnné path definované v modulu sys. Tato proměnná obsahuje seznam adres, které se mají při načítání modulů prohledávat. K jejímu zavolání je třeba samozřejmě nejprve načíst modul sys:\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.path\n['C:\\\\Python25\\\\Lib\\\\idlelib', 'C:\\\\Program Files\\\\ArcGIS\\\\bin', 'C:\\\\WINDOWS\\\\system32\\\\python25.zip', 'C:\\\\Python25\\\\DLLs', 'C:\\\\Python25\\\\lib', 'C:\\\\Python25\\\\lib\\\\plat-win', 'C:\\\\Python25\\\\lib\\\\lib-tk', 'C:\\\\Python25', 'C:\\\\Python25\\\\lib\\\\site-packages']\nKonkrétní obsah seznamu bude samozřejmě záviset na konkrétním počítači.\nPokud budeme chtít k tomuto seznamu nějakou složku přidat, je možné proměnnou path změnit standardním způsobem, jakým se pracuje se seznamy:\n&gt;&gt;&gt; sys.path.append(\"C:\\\\Moje_slozka\")\n&gt;&gt;&gt; sys.path\n['C:\\\\Python25\\\\Lib\\\\idlelib', 'C:\\\\Program Files\\\\ArcGIS\\\\bin', 'C:\\\\WINDOWS\\\\system32\\\\python25.zip', 'C:\\\\Python25\\\\DLLs', 'C:\\\\Python25\\\\lib', 'C:\\\\Python25\\\\lib\\\\plat-win', 'C:\\\\Python25\\\\lib\\\\lib-tk', 'C:\\\\Python25', 'C:\\\\Python25\\\\lib\\\\site-packages', 'C:\\\\Moje_slozka']\nTímto způsobem můžeme do proměnné path přidat složky, v nichž máme uložené moduly. Tuto akci však budeme muset udělat vždy znovu, kdykoli spustíme Python. Jinou možností je ukládat moduly do složky, která již v seznamu proměnné path je. Tento způsobe však není vhodný, neboť při přeinstalování Pythonu jsou tyto složky většinou smazány a s nimi i vše, co obsahují. Vhodnější je proto např. do kódu programu, v němž budeme chtít načítat nějaké vlastní moduly, rovnou vložit příkaz s aktualizací proměnné path.\nJinou možností je ukládat moduly do stejné složky, v níž je uložen samotný program (či „hlavní skript“), neboť do proměnné path je vždy automaticky přidána aktuální pracovní složka (tj. např. složka, z níž je spouštěn nějaký skript).\nJiný způsob, jak prohlížet složky s moduly, je pomocí prohlížeče Path Browser, umístěného v hlavní nabídce okna Python Shell pod File -&gt; Path Browser. Okno prohlížeče vypadá následovně:\n\n\n\nimage-20201102183750177"
  },
  {
    "objectID": "material/old_materials/Lekce 8 Funkce a moduly.html#úlohy",
    "href": "material/old_materials/Lekce 8 Funkce a moduly.html#úlohy",
    "title": "Lekce 8: Funkce a moduly",
    "section": "",
    "text": "Napište funkci, která vrátí maximum resp. minimum ze zadaného seznamu čísel (řešte bez použití vestavěné funkce max resp. min).\nNapište funkci, která seřadí vzestupně (sestupně) zadaný seznam čísel (řešte bez použití metody seznamu sort). (Nápověda: můžete použít např. algoritmus “řazení výběrem”, “řazení vkládáním” či “bublinkové řazení”. Pro přehled různých přístupů viz např. tento odkaz na wikipedii.)"
  },
  {
    "objectID": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html",
    "href": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html",
    "title": "Lekce 6: Interaktivní vstupy do programu a náhodná čísla",
    "section": "",
    "text": "V této lekci si ukážeme, jak lze v pythonu interaktivně zadávat vstupy do nějakého programu, který spouštíme na konzoli (např. v prostředí IDLE). Vstupy se zadávají pomocí funkce input. Protože její vlastnosti jsou odlišné v Pythonu řady 2.x a řady 3.x, probereme obě varianty zvlášť. Dále si ukážeme, jak v Pythonu generovat náhodná čísla.\n\n\nVe verzích Pythonu 2.x existují dvě funkce, input a raw_input.\nFunkce input vypíše na konzoli zadaný text a následně čeká, až uživatel zadá na konzoli vstup:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo:\nPo zadání a potvrzení klávesou Enter funkce vrátí hodnotu zadanou uživatelem, s tím, že automaticky vyhodnotí, o jaký datový typ se jedná:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo: 5\n5\nV tomto případě funkce automaticky poznala, že se jedná o číslo, neboť bylo zadáno číslo bez uvozovek. V případě, že bychom chtěli, aby funkce vstup přečetla jako textový řetězec, museli bychom vstup zadat v uvozovkách:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej text:\")\nMilý uživateli, zadej text: \"5\"\n'5'\nPodobně lze zadávat i ostatní datové typy:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej seznam:\")\nMilý uživateli, zadej seznam: [1,2,3,4]\n[1, 2, 3, 4]\nnebo např. volat funkce:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej seznam od 0 do 5:\")\nMilý uživateli, zadej seznam od 0 do 5: range(6)\n[0, 1, 2, 3, 4, 5]\nFunkce raw_input oproti tomu vrací jakýkoli vstup v podobě textového řetězce:\n&gt;&gt;&gt; raw_input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo:5\n'5'\n\n&gt;&gt;&gt; raw_input(\"Milý uživateli, zadej seznam:\")\nMilý uživateli, zadej seznam:[1,2,3,4]\n'[1,2,3,4]'\n\n&gt;&gt;&gt; raw_input(\"Milý uživateli, zadej seznam od 0 do 5:\")\nMilý uživateli, zadej seznam od 0 do 5:range(6)\n'range(6)'\n\n\n\nVe výše uvedených ukázkách jsme výsledek volání funkce input pouze nechávali vypsat na konzoli. Zpravidla s ním však chceme provádět nějaké další výpočty či operace. To zajistíme tím, že výsledek volání funkce input resp. raw_input uložíme do proměnné:\n&gt;&gt;&gt; a = input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo:5\n&gt;&gt;&gt; a + 2\n7\nV případě funkce raw_input nesmíme však zapomenout na převedení textového vstupu na požadovaný datový typ:\n&gt;&gt;&gt; a = raw_input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo:5\n&gt;&gt;&gt; int(a) + 2\n7\nJe také možné využít funkci eval (z angl. “evaluate” čili “vyhodnoť”), která vezme textový vstup a pokusí se jej interpretovat jako kód v Pythonu a vrátit požadovaný výstup:\n&gt;&gt;&gt; seznam = raw_input(\"Milý uživateli, zadej seznam od 0 do 5:\")\nMilý uživateli, zadej seznam od 0 do 5:range(6)\n&gt;&gt;&gt; seznam\n'range(6)'\n&gt;&gt;&gt; eval(seznam)\n[0, 1, 2, 3, 4, 5]\nChování funkce input() lze tedy věrně imitovat použitím eval(raw_input()):\n&gt;&gt;&gt; seznam = eval(raw_input(\"Milý uživateli, zadej seznam od 0 do 5:\"))\nMilý uživateli, zadej seznam od 0 do 5:range(6)\n&gt;&gt;&gt; seznam\n[0, 1, 2, 3, 4, 5]\n\nÚkol 1. Napište program, který uživatele vyzve k zadání přirozeného čísla a následně vrátí jeho faktoriál.\n\n\nÚkol 2. Napište program, který uživatele postupně vyzve k zadání dvou čísel a následně sdělí, zda je větší z nich dělitelné menším.\n\n\n\n\nVe verzích Pythonu 3.x došlo k následujícím změnám:\n\nfunkce raw_input byla zrušena,\nchování funkce input bylo změněno na původní chování funkce raw_input.\n\nTo znamená, že k interaktivnímu vstupu přes konzoli již slouží pouze funkce input a vstup je vždy předáván jako textový řetězec. Pokud s ním dále chcete pracovat jako s číslem, seznamem apod., je třeba použít přetypování (konverzní funkce int, float, list apod.), případně funkci eval.\n\n\n\nKe generování náhodných čísel slouží v Pythonu modul random, který je součástí základní výbavy jazyka. Modul je třeba nejprve načíst příkazem import:\n&gt;&gt;&gt; import random\nK jednotlivým funkcím modulu se pak dostaneme, jak je v Pythonu obvyklé, přes jméno modulu, tečku a jméno funkce. Např. funkce random() bez argumentů generuje náhodné číslo z intervalu (0, 1) (z rovnoměrného rozdělení):\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.random()\n0.6744697203253585\n&gt;&gt;&gt; random.random()\n0.7169711430089877\n&gt;&gt;&gt; random.random()\n0.4213975602144999\nModul lze načíst a dále používat i pod zvoleným alternativním (např. kratším) názvem:\n&gt;&gt;&gt; import random as rn\n&gt;&gt;&gt; a = rn.random()\n&gt;&gt;&gt; a\n0.8591162717665027\nFunkce randint(a, b) vrací náhodné celé číslo z intervalu &lt;a, b&gt; (včetně obou mezí):\n&gt;&gt;&gt; rn.randint(-100, 100)\n70\n&gt;&gt;&gt; rn.randint(-100, 100)\n-89\nFunkce choice(seq) vrací náhodně vybraný prvek z posloupnosti (seznamu, n-tice apod.) seq:\n&gt;&gt;&gt; seznam = [1,\"dva\",3,\"ctyri\",5]\n&gt;&gt;&gt; rn.choice(seznam)\n5\n&gt;&gt;&gt; rn.choice(seznam)\n'dva'\nFunkce sample(population, k) vrací náhodný výběr velikosti k z posloupnosti population:\n&gt;&gt;&gt; rn.sample(range(100), 10)\n[10, 67, 93, 45, 56, 17, 71, 8, 91, 9]\nFunkce uniform(a, b) vrací náhodné číslo generované z rovnoměrného rozdělení na intervalu &lt;a,b&gt;. (Poznámka: stejné jako a + random() * abs(a – b).)\n&gt;&gt;&gt; rn.uniform(2,4)\n2.8693870960257666\nFunkce gauss(mu, sigma) vrací náhodné číslo generované z normálního rozdělení se střední hodnotou mu a směrodatnou odchylkou sigma:\n&gt;&gt;&gt; rn.gauss(0, 1)\n-0.072104281974643761\nGenerátor opravdu náhodných čísel pomocí počítače neexistuje (a v principu existovat nemůže). Čísla, která označujeme za “náhodná” jsou tzv. pseudonáhodná, tj. taková, která se jako náhodná pouze tváří. Ve skutečnosti je každé další číslo v posloupnosti “náhodných” čísel složitým algoritmem přesně (a vždy stejně) vypočteno z čísla předchozího. V čem tedy spočívá jejich “náhodnost”? Spočívá v tom, že vygenerujeme-li libovolně dlouhou posloupnost, bude se vždy ze statistického hlediska “tvářit” jako náhodná. Žádný statistický test neodhalí souvislost mezi po sobě následujícími čísly.\nZ uvedeného plyne, že pokud bychom daným generátorem postupně generovali dvě řady náhodných čísel, přičemž bychom začali od stejného čísla, obě řady by byly identické (ačkoli by se každá z nich sama o sobě tvářila jako náhodná). Tento problém se v praxi řeší tím, že se pokaždé začne jiným číslem, tzv. semínkem (anglicky seed). Defaultně se semínko v danou chvíli odvodí z aktuálního času v počítači.\nSemínko je ale možné i nastavit pevně, což se hodí, chceme-li např. opakovaně testovat nějaký algoritmus, pracující s náhodnými čísly, přičemž chceme, aby do každého testu vstupovaly stejné hodnoty. K nastavení semínka slouží funkce seed:\n&gt;&gt;&gt; rn.seed(123)\n&gt;&gt;&gt; rn.random()\n0.052363598850944326\n&gt;&gt;&gt; rn.random()\n0.08718667752263232\n&gt;&gt;&gt; rn.random()\n0.4072417636703983\n&gt;&gt;&gt; rn.seed(123)\n&gt;&gt;&gt; rn.random()\n0.052363598850944326\n&gt;&gt;&gt; rn.random()\n0.08718667752263232\n&gt;&gt;&gt; rn.random()\n0.4072417636703983\nJak je z ukázky vidět, po nastavení semínka na stejnou hodnotu (v našem případě 123) tvoří následující sekvenci stejná čísla.\n\nÚkol 3. Vygenerujte 1000 čísel z rovnoměrného rozdělení na intervalu (0, 1) a zjistěte, kolik procent z nich je větších než 0,7.\n\n\n\n\n\n\n\n\nVytvořte program, který vás vyzkouší z malé násobilky. Program náhodně vygeneruje příklad a vyzve vás, abyste zadali výsledek. V případě špatného výsledku vám vynadá a sdělí vám správný, v případě správného výsledku vám pogratuluje.\nVytvořte program, který bude zkoušet z malé násobilky tak, v případě špatného výsledku vás bude nutit zadat výsledek ještě jednou, a to tak dlouho, dokud nezadáte správný výsledek.\nModifikujte program z úlohy 2 tak, aby se vás po ukončení příkladu zeptal, zda si přejete pokračovat dalším příkladem. Pokud zvolíte “ano” (například tak, že zadáte “Y” jako “YES”), dá vám další příklad. Pokud zvolíte “ne” (např. “N” jako “NO”), ukončí se.\nVygenerujte 10 000 čísel z normálního rozdělení se střední hodnotou 13 a směrodatnou odchylkou 2,3. Spočítejte jejich průměr a (výběrovou) směrodatnou odchylku. Vypočítejte stejné hodnoty z náhodného výběru 100 čísel z vygenerovaného souboru 10 000 čísel. Které hodnoty jsou blíže střední hodnotě a směrodatné odchylce původního normálního rozdělení?"
  },
  {
    "objectID": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#funkce-input-a-raw_input-v-pythonu-2.x",
    "href": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#funkce-input-a-raw_input-v-pythonu-2.x",
    "title": "Lekce 6: Interaktivní vstupy do programu a náhodná čísla",
    "section": "",
    "text": "Ve verzích Pythonu 2.x existují dvě funkce, input a raw_input.\nFunkce input vypíše na konzoli zadaný text a následně čeká, až uživatel zadá na konzoli vstup:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo:\nPo zadání a potvrzení klávesou Enter funkce vrátí hodnotu zadanou uživatelem, s tím, že automaticky vyhodnotí, o jaký datový typ se jedná:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo: 5\n5\nV tomto případě funkce automaticky poznala, že se jedná o číslo, neboť bylo zadáno číslo bez uvozovek. V případě, že bychom chtěli, aby funkce vstup přečetla jako textový řetězec, museli bychom vstup zadat v uvozovkách:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej text:\")\nMilý uživateli, zadej text: \"5\"\n'5'\nPodobně lze zadávat i ostatní datové typy:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej seznam:\")\nMilý uživateli, zadej seznam: [1,2,3,4]\n[1, 2, 3, 4]\nnebo např. volat funkce:\n&gt;&gt;&gt; input(\"Milý uživateli, zadej seznam od 0 do 5:\")\nMilý uživateli, zadej seznam od 0 do 5: range(6)\n[0, 1, 2, 3, 4, 5]\nFunkce raw_input oproti tomu vrací jakýkoli vstup v podobě textového řetězce:\n&gt;&gt;&gt; raw_input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo:5\n'5'\n\n&gt;&gt;&gt; raw_input(\"Milý uživateli, zadej seznam:\")\nMilý uživateli, zadej seznam:[1,2,3,4]\n'[1,2,3,4]'\n\n&gt;&gt;&gt; raw_input(\"Milý uživateli, zadej seznam od 0 do 5:\")\nMilý uživateli, zadej seznam od 0 do 5:range(6)\n'range(6)'"
  },
  {
    "objectID": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#použití-vstupu-do-dalšího-výpočtu",
    "href": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#použití-vstupu-do-dalšího-výpočtu",
    "title": "Lekce 6: Interaktivní vstupy do programu a náhodná čísla",
    "section": "",
    "text": "Ve výše uvedených ukázkách jsme výsledek volání funkce input pouze nechávali vypsat na konzoli. Zpravidla s ním však chceme provádět nějaké další výpočty či operace. To zajistíme tím, že výsledek volání funkce input resp. raw_input uložíme do proměnné:\n&gt;&gt;&gt; a = input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo:5\n&gt;&gt;&gt; a + 2\n7\nV případě funkce raw_input nesmíme však zapomenout na převedení textového vstupu na požadovaný datový typ:\n&gt;&gt;&gt; a = raw_input(\"Milý uživateli, zadej číslo:\")\nMilý uživateli, zadej číslo:5\n&gt;&gt;&gt; int(a) + 2\n7\nJe také možné využít funkci eval (z angl. “evaluate” čili “vyhodnoť”), která vezme textový vstup a pokusí se jej interpretovat jako kód v Pythonu a vrátit požadovaný výstup:\n&gt;&gt;&gt; seznam = raw_input(\"Milý uživateli, zadej seznam od 0 do 5:\")\nMilý uživateli, zadej seznam od 0 do 5:range(6)\n&gt;&gt;&gt; seznam\n'range(6)'\n&gt;&gt;&gt; eval(seznam)\n[0, 1, 2, 3, 4, 5]\nChování funkce input() lze tedy věrně imitovat použitím eval(raw_input()):\n&gt;&gt;&gt; seznam = eval(raw_input(\"Milý uživateli, zadej seznam od 0 do 5:\"))\nMilý uživateli, zadej seznam od 0 do 5:range(6)\n&gt;&gt;&gt; seznam\n[0, 1, 2, 3, 4, 5]\n\nÚkol 1. Napište program, který uživatele vyzve k zadání přirozeného čísla a následně vrátí jeho faktoriál.\n\n\nÚkol 2. Napište program, který uživatele postupně vyzve k zadání dvou čísel a následně sdělí, zda je větší z nich dělitelné menším."
  },
  {
    "objectID": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#funkce-input-v-pythonu-3.x",
    "href": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#funkce-input-v-pythonu-3.x",
    "title": "Lekce 6: Interaktivní vstupy do programu a náhodná čísla",
    "section": "",
    "text": "Ve verzích Pythonu 3.x došlo k následujícím změnám:\n\nfunkce raw_input byla zrušena,\nchování funkce input bylo změněno na původní chování funkce raw_input.\n\nTo znamená, že k interaktivnímu vstupu přes konzoli již slouží pouze funkce input a vstup je vždy předáván jako textový řetězec. Pokud s ním dále chcete pracovat jako s číslem, seznamem apod., je třeba použít přetypování (konverzní funkce int, float, list apod.), případně funkci eval."
  },
  {
    "objectID": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#generování-náhodných-čísel",
    "href": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#generování-náhodných-čísel",
    "title": "Lekce 6: Interaktivní vstupy do programu a náhodná čísla",
    "section": "",
    "text": "Ke generování náhodných čísel slouží v Pythonu modul random, který je součástí základní výbavy jazyka. Modul je třeba nejprve načíst příkazem import:\n&gt;&gt;&gt; import random\nK jednotlivým funkcím modulu se pak dostaneme, jak je v Pythonu obvyklé, přes jméno modulu, tečku a jméno funkce. Např. funkce random() bez argumentů generuje náhodné číslo z intervalu (0, 1) (z rovnoměrného rozdělení):\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.random()\n0.6744697203253585\n&gt;&gt;&gt; random.random()\n0.7169711430089877\n&gt;&gt;&gt; random.random()\n0.4213975602144999\nModul lze načíst a dále používat i pod zvoleným alternativním (např. kratším) názvem:\n&gt;&gt;&gt; import random as rn\n&gt;&gt;&gt; a = rn.random()\n&gt;&gt;&gt; a\n0.8591162717665027\nFunkce randint(a, b) vrací náhodné celé číslo z intervalu &lt;a, b&gt; (včetně obou mezí):\n&gt;&gt;&gt; rn.randint(-100, 100)\n70\n&gt;&gt;&gt; rn.randint(-100, 100)\n-89\nFunkce choice(seq) vrací náhodně vybraný prvek z posloupnosti (seznamu, n-tice apod.) seq:\n&gt;&gt;&gt; seznam = [1,\"dva\",3,\"ctyri\",5]\n&gt;&gt;&gt; rn.choice(seznam)\n5\n&gt;&gt;&gt; rn.choice(seznam)\n'dva'\nFunkce sample(population, k) vrací náhodný výběr velikosti k z posloupnosti population:\n&gt;&gt;&gt; rn.sample(range(100), 10)\n[10, 67, 93, 45, 56, 17, 71, 8, 91, 9]\nFunkce uniform(a, b) vrací náhodné číslo generované z rovnoměrného rozdělení na intervalu &lt;a,b&gt;. (Poznámka: stejné jako a + random() * abs(a – b).)\n&gt;&gt;&gt; rn.uniform(2,4)\n2.8693870960257666\nFunkce gauss(mu, sigma) vrací náhodné číslo generované z normálního rozdělení se střední hodnotou mu a směrodatnou odchylkou sigma:\n&gt;&gt;&gt; rn.gauss(0, 1)\n-0.072104281974643761\nGenerátor opravdu náhodných čísel pomocí počítače neexistuje (a v principu existovat nemůže). Čísla, která označujeme za “náhodná” jsou tzv. pseudonáhodná, tj. taková, která se jako náhodná pouze tváří. Ve skutečnosti je každé další číslo v posloupnosti “náhodných” čísel složitým algoritmem přesně (a vždy stejně) vypočteno z čísla předchozího. V čem tedy spočívá jejich “náhodnost”? Spočívá v tom, že vygenerujeme-li libovolně dlouhou posloupnost, bude se vždy ze statistického hlediska “tvářit” jako náhodná. Žádný statistický test neodhalí souvislost mezi po sobě následujícími čísly.\nZ uvedeného plyne, že pokud bychom daným generátorem postupně generovali dvě řady náhodných čísel, přičemž bychom začali od stejného čísla, obě řady by byly identické (ačkoli by se každá z nich sama o sobě tvářila jako náhodná). Tento problém se v praxi řeší tím, že se pokaždé začne jiným číslem, tzv. semínkem (anglicky seed). Defaultně se semínko v danou chvíli odvodí z aktuálního času v počítači.\nSemínko je ale možné i nastavit pevně, což se hodí, chceme-li např. opakovaně testovat nějaký algoritmus, pracující s náhodnými čísly, přičemž chceme, aby do každého testu vstupovaly stejné hodnoty. K nastavení semínka slouží funkce seed:\n&gt;&gt;&gt; rn.seed(123)\n&gt;&gt;&gt; rn.random()\n0.052363598850944326\n&gt;&gt;&gt; rn.random()\n0.08718667752263232\n&gt;&gt;&gt; rn.random()\n0.4072417636703983\n&gt;&gt;&gt; rn.seed(123)\n&gt;&gt;&gt; rn.random()\n0.052363598850944326\n&gt;&gt;&gt; rn.random()\n0.08718667752263232\n&gt;&gt;&gt; rn.random()\n0.4072417636703983\nJak je z ukázky vidět, po nastavení semínka na stejnou hodnotu (v našem případě 123) tvoří následující sekvenci stejná čísla.\n\nÚkol 3. Vygenerujte 1000 čísel z rovnoměrného rozdělení na intervalu (0, 1) a zjistěte, kolik procent z nich je větších než 0,7."
  },
  {
    "objectID": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#úlohy",
    "href": "material/old_materials/Lekce 6 Interaktivní vstupy do programu a náhodná čísla.html#úlohy",
    "title": "Lekce 6: Interaktivní vstupy do programu a náhodná čísla",
    "section": "",
    "text": "Vytvořte program, který vás vyzkouší z malé násobilky. Program náhodně vygeneruje příklad a vyzve vás, abyste zadali výsledek. V případě špatného výsledku vám vynadá a sdělí vám správný, v případě správného výsledku vám pogratuluje.\nVytvořte program, který bude zkoušet z malé násobilky tak, v případě špatného výsledku vás bude nutit zadat výsledek ještě jednou, a to tak dlouho, dokud nezadáte správný výsledek.\nModifikujte program z úlohy 2 tak, aby se vás po ukončení příkladu zeptal, zda si přejete pokračovat dalším příkladem. Pokud zvolíte “ano” (například tak, že zadáte “Y” jako “YES”), dá vám další příklad. Pokud zvolíte “ne” (např. “N” jako “NO”), ukončí se.\nVygenerujte 10 000 čísel z normálního rozdělení se střední hodnotou 13 a směrodatnou odchylkou 2,3. Spočítejte jejich průměr a (výběrovou) směrodatnou odchylku. Vypočítejte stejné hodnoty z náhodného výběru 100 čísel z vygenerovaného souboru 10 000 čísel. Které hodnoty jsou blíže střední hodnotě a směrodatné odchylce původního normálního rozdělení?"
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "V Pythonu je proměnná odkazem na nějaký objekt v operační paměti. Tento objekt může být různého typu (neboli třídy): může jít o číslo, o textový řetězec, nebo o cokoli jiného (viz dále). Proměnná má nějaký název (zvolený námi) a nějakou hodnotu. Hodnotu do proměnné přiřazujeme operátorem =:\n&gt;&gt;&gt; a = 5\nDatový typ proměnné lze zjistit funkcí type:\n&gt;&gt;&gt; type(a)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; b = \"Ahoj světe\"\n&gt;&gt;&gt; type(b)\n&lt;type 'str'&gt;\n\nPojem funkce si důkladně rozebereme později. Zatím stačí chápat, že při volání nějaké funkce vždy napíšeme její název a do závorky její argumenty, tj. nějaké hodnoty, se kterými daná funkce něco dělá. Funkce pak většinou něco tzv. vrací, tj. jejím výsledkem je nějaká hodnota (objekt). Kdykoli tedy vidíte za nějakým názvem jednoduché závorky, máte co do činění s funkcí.\n\nDo proměnné lze “uložit” hodnotu nějaké jiné proměnné:\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; b\n5\nJe důležité však mít na paměti, že změníme-li hodnotu původní proměnné, hodnota nové proměnné zůstává nezměněna (tato proměnná totiž odkazuje stále na původní objekt - v našem případě číslo 5, kdežto původní proměnná už odkazuje na jiný objekt - např. číslo 100):\n&gt;&gt;&gt; a = 100\n&gt;&gt;&gt; b\n5\nProměnné mohou mít téměř libovolné názvy, je však nutné dodržet následující pravidla:\n\nNázev začíná písmenem anglické abecedy nebo podtržítkem\nNásleduje libovolná posloupnost číslic, písmen angl. abecedy a podtržítek\nNesmí jít o klíčové slovo jazyka (např. and nebo if)\nMalá a velká písmena se rozlišují\n\nPython umožňuje i následující podivnost (vytvoření dvou či více proměnných najednou):\n&gt;&gt;&gt; a, b = 3, 5\n&gt;&gt;&gt; a\n3\n&gt;&gt;&gt; b\n5\n\nÚkol 1. Zkuste si vytvořit několik proměnných různých názvů a ověřit jejich výše uvedené chování.\n\nVytvořenou proměnnou lze také smazat, a to pomocí příkazu del:\n&gt;&gt;&gt; x = 5\n&gt;&gt;&gt; x\n5\n&gt;&gt;&gt; del x\n&gt;&gt;&gt; x\nTraceback (most recent call last):\n  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;\n    x\nNameError: name 'x' is not defined\n\n\n\nV Pythonu jsou dva základní datové typy pro čísla. Jsou to celá čísla (anglicky integer, zkráceně int):\n&gt;&gt;&gt; 56\n56\n&gt;&gt;&gt; -32586\n-32586\na čísla s desetinnou čárkou (anglicky floating point number, zkráceně float):\n&gt;&gt;&gt; 5.32\n5.32\n&gt;&gt;&gt; -6e-7\n-6e-7\n&gt;&gt;&gt; -5.0E-4\n-0.0005\nS čísly lze provádět běžné matematické operace pomocí aritmetických operátorů:\n&gt;&gt;&gt; 3 + 2 # Sčítání\n5\n&gt;&gt;&gt; 3 – 2 # Odčítání\n1\n&gt;&gt;&gt; 3 * 2 # Násobení\n6\n&gt;&gt;&gt; 3 / 2 # Celočíselní dělení celých čísel\n1\n&gt;&gt;&gt; 3.0 / 2 # Dělení\n1.5\n&gt;&gt;&gt; 3.1 // 2 # Celočíselné dělení\n1.0\n&gt;&gt;&gt; 3**2 # Mocnina\n9\n&gt;&gt;&gt; 3 % 2 # Modulo (zbytek po celočíselném dělení)\n1\nČíselný typ výsledku je vždy určen číselným typem vstupních čísel: jsou-li vstupem pouze celá čísla, je výsledkem celé číslo (při dělení se tedy provede celočíselné dělení); je-li alespoň jeden ze vstupů číslo s desetinnou čárkou, je výsledkem rovněž číslo s desetinnou čárkou.\nPython disponuje řadou vestavěných matematických funkcí (v ukázkou jsou jen některé):\n&gt;&gt;&gt; abs(-5) # Absolutní hodnota\n5\n&gt;&gt;&gt; max(5,3,-5,1) # Maximum\n5\n&gt;&gt;&gt; min(5,3,-5,1) # Minimum\n-5\n&gt;&gt;&gt; pow(2,3) # Mocnina (ekvivalent 2**3)\n8\n&gt;&gt;&gt; round(5.6) # Zaokrouhlení\n6.0\n&gt;&gt;&gt; round(5.627,2) # Zaokrouhlení na dvě desetinná místa\n5.63\nDalší matematické funkce lze nalézt v modulu math:\n&gt;&gt;&gt; import math # Načtení modulu math\n&gt;&gt;&gt; math.pi # Aproximace čísla pí\n3.141592653589793\n&gt;&gt;&gt; math.sqrt(2) # Odmocnina\n1.4142135623730951\n&gt;&gt;&gt; math.log(math.exp(1)) # Logaritmus a exponenciela\n1.0\nMezi jednotlivými číselnými typy lze konvertovat:\n&gt;&gt;&gt; a = 5.6\n&gt;&gt;&gt; type(a)\n&lt;type 'float'&gt;\n&gt;&gt;&gt; b = int(a) # Konverze na celé číslo\n&gt;&gt;&gt; b\n5\n&gt;&gt;&gt; type(b)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; c = float(b) # Konverze na číslo s desetinnou čárkou\n&gt;&gt;&gt; c\n5.0\n&gt;&gt;&gt; type(c)\n&lt;type 'float'&gt;\nPodobně lze konvertovat i mezi jinými datovými typy:\n&gt;&gt;&gt; int(\"56\") # Převod textu na celé číslo\n56\n&gt;&gt;&gt; float(\"56\") # Převod textu na číslo s desetinnou čárkou\n56.0\n&gt;&gt;&gt; str(56) # Převod čísla na text\n'56'\n\nÚkol 2. Vyzkoušejte si všechny výše uvedené operace a příkazy.\n\n\n\n\nTextové řetězce (či krátce jen řetězce, angl. string) se zapisují buď v uvozovkách, nebo v apostrofech:\n&gt;&gt;&gt; a = \"Toto je textovy retezec, ktery muze obsahovat znak ',\"\n&gt;&gt;&gt; b = 'a toto je retezec, ktery muze obsahovat znak \".'\n&gt;&gt;&gt; print(a); print(b)\nToto je textovy retezec, ktery muze obsahovat znak ',\na toto je retezec, ktery muze obsahovat znak \".\nTřetím způsobem, jak vytvořit řetězec, je použití trojitých uvozovek. Do takového řetězce je pak možné vkládat i více řádků (aniž bychom museli použít speciální znak pro konec řádku):\n&gt;&gt;&gt; a = \"\"\"Toto je textovy retezec,\nktery obsahuje\ntri radky\"\"\"\n&gt;&gt;&gt; print a\nToto je textovy retezec,\nktery obsahuje\ntri radky\nŘetězce lze do jisté míry chápat jako posloupnosti jednotlivých znaků. V Pythonu jsou řetězce indexované, to znamená, že lze např. číst přímo konkrétní (třeba pátý) znak:\n&gt;&gt;&gt; a = \"Z tohoto retezce budu cist paty znak:\"\n&gt;&gt;&gt; print a[4]\nh\nIndexování v Pythonu začíná nulou, nikoli jedničkou, proto bylo pro vypsání pátého znaku nutné do hranatých závorek psát index 4.\nVedle přístupu k jednotlivým znakům lze také pomocí hranatých závorek a indexů vytvářet tzv. řezy, neboli číst pouze určitou část řetězce:\n&gt;&gt;&gt; a = \"Z tohoto retezce budu delat rezy:\"\n&gt;&gt;&gt; print a[2:10]\ntohoto r\n&gt;&gt;&gt; print a[:20]\nZ tohoto retezce bud\n&gt;&gt;&gt; print a[7:]\no retezce budu delat rezy:\nTvorba řezů se řídí následujícími pravidly:\n\nŘez začíná znakem na pozici prvního indexu a končí na pozici před posledním indexem (poslední prvek tedy již není součástí řezu). Řez a[2:10] tak obsahuje třetí až desátý znak.\nŘez s prázdným prvním indexem obsahuje celý původní řetězec od začátku až do znaku na pozici před posledním indexem.\nŘez s prázdným druhým indexem obsahuje celý původní řetězec počínaje znakem na pozici prvního indexu.\n\nŘetězce (na rozdíl od seznamů) nelze pomocí indexování a řezů přepisovat. Např. pokud bychom chtěli v textu „kost“ změnit první písmeno na „m“, nelze to provést přímo:\n&gt;&gt;&gt; a = \"kost\"\n&gt;&gt;&gt; a[0] = \"m\"\nTraceback (most recent call last):\n  File \"&lt;pyshell#57&gt;\", line 1, in &lt;module&gt;\n    a[0] = \"m\"\nTypeError: 'str' object does not support item assignment\nŘetězce lze sčítat a násobit přirozeným číslem pomocí operátorů + a *:\n&gt;&gt;&gt; a = \"Ahoj\"\n&gt;&gt;&gt; b = \"Svete\"\n&gt;&gt;&gt; print a + b\nAhojSvete\n&gt;&gt;&gt; print a + \" \" + b + \"!\"\nAhoj Svete!\n&gt;&gt;&gt; print a*5\nAhojAhojAhojAhojAhoj\nZměnit výše zmíněnou „kost“ na „most“ lze tedy např. takto:\n&gt;&gt;&gt; a = \"kost\"\n&gt;&gt;&gt; a = \"m\" + a[1:]\n&gt;&gt;&gt; print a\nmost\nŘetězec může obsahovat tzv. escape sekvence, tj. posloupnosti znaků, nesoucí speciální význam. Escape sekvence je vždy uvozena zpětným lomítkem \\:\n&gt;&gt;&gt; print '\\'' # Znak apostrofu v řetězci uvozeném apostrofy\n'\n&gt;&gt;&gt; print \"\\\"\" # Znak uvozovek v řetězci uvozeném uvozovkami\n\"\n&gt;&gt;&gt; print \"Zde je\\ttabulator\" # Znak tabulátoru\nZde je     tabulator\n&gt;&gt;&gt; print \"Zde je\\nnovy radek\" # Znak konce řádku\nZde je\nnovy radek\nJelikož escape sekvence jsou uvozeny zpětným lomítkem, zpětné lomítko samotné nelze v textu použít:\n&gt;&gt;&gt; print(V tomto textu se snazim pouzit znak \\\")\nSyntaxError: EOL while scanning string literal\nTo lze vyřešit použitím dvojitého zpětného lomítka, což je další z escape sekvencí:\n&gt;&gt;&gt; print(\"V tomto textu znak \\\\ klidne pouziji\")\nV tomto textu znak \\ klidne pouziji\nToto je důležité zejména při psaní adresářových a souborových adres, kde se zpětná lomítka používají:\n&gt;&gt;&gt; print \"C:\\\\Users\\\\Muj_pocitac\\\\Documents\"\nC:\\Users\\Muj_pocitac\\Documents\nJiným způsobem psaní adres je použití dopředného lomítka:\n&gt;&gt;&gt; print \"C:/Users/Muj_pocitac/Documents\"\nC:/Users/Muj_pocitac/Documents\nJeště jiný způsob spočívá v uvození řetězce znakem r (před uvozovkami). Tím dáváme najevo, že se jedná o tzv. surový řetězec (angl. raw string), ve kterém se mají všechny znaky číst svým obvyklým způsobem (zpětné lomítko je proto pouze zpětným lomítkem a žádné escape sekvence zde být nemohou):\n&gt;&gt;&gt; print r\"C:\\Users\\Muj_pocitac\\Documents\"\nC:\\Users\\Muj_pocitac\\Documents\n\n\n\nSeznam je posloupnost libovolných objektů. Definuje se pomocí hranatých závorek a jeho položky se oddělují čárkami:\n&gt;&gt;&gt; seznam1 = [2,-4,56,105,0]\n&gt;&gt;&gt; seznam2 = [\"ahoj\",\"STROM\",\"\",\"guru\"]\nDo jednoho seznamu lze ukládat hodnoty různých datových typů (to v jiných programovacích jazycích nebývá zvykem):\n&gt;&gt;&gt; seznam3 = [0, \"ahoj\",-5.78,2,4]\nPodobně jako tomu bylo v případě textových řetězců, k jednotlivým položkám seznamu lze přistupovat pomocí indexů:\n&gt;&gt;&gt; seznam3[3]\n2\nIndexy začínají nulou (tj. první položka seznamu má index 0, nikoli 1!) a lze používat i záporné indexy. Záporné indexy indexují seznam od konce, tj. poslední prvek seznamu má index -1, předposlední -2 atd. Záporné indexování je zvláště výhodné v tom, že lze rychle přistupovat např. k poslední položce seznamu, aniž bychom znali či se odkazovali na délku seznamu:\n&gt;&gt;&gt; seznam3[-1]\n4\nNa rozdíl od textových řetězců, u seznamů lze pomocí indexů měnit jednotlivé položky:\n&gt;&gt;&gt; seznam1[2] = \"nova hodnota\"\n&gt;&gt;&gt; seznam1\n[2, -4, 'nova hodnota', 105, 0]\nŘez seznamu je seznam sestávající pouze z některých prvků původního seznamu. Vytváří se pomocí hranatých závorek, dvou indexů (začátku a konce řezu) a dvojtečky mezi nimi:\n&gt;&gt;&gt; seznam2[1:4]\n['STROM', '', 'guru']\nJak vyplývá z ukázky, prvek na pozici druhého indexu již do řezu nepatří. V řezu lze používat i záporné indexy, takže např. řez\n&gt;&gt;&gt; seznam2[0:-1]\n['ahoj', 'STROM', '']\nobsahuje všechny prvky od prvního do předposledního.\nPokud necháme některý z indexů prázdný, je příslušný řez proveden od začátku resp. do konce seznamu:\n# toto je rez od zacatku seznamu do tretiho prvku:\n&gt;&gt;&gt; seznam2[:3]\n['ahoj', 'STROM', '']\n\n# toto je rez od druheho prvku do konce seznamu:\n&gt;&gt;&gt; seznam2[1:]\n['STROM', '', 'guru']\n\n# toto je tzv. uplny rez:\n&gt;&gt;&gt; seznam2[:]\n['ahoj', 'STROM', '', 'guru']\nDalší možností, jak vytvářet řezy, je použití třetího „indexu“, lépe řečeno hodnoty, která určuje délku kroku při výběru prvků do řezu. Tímto způsobem lze např. vytvořit řez obsahující každé druhé (či třetí) číslo z určitého rozmezí:\n&gt;&gt;&gt; a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\n&gt;&gt;&gt; a[2:10:2]\n[3, 5, 7, 9]\n&gt;&gt;&gt; a[1:13:2]\n[2, 4, 6, 8, 10, 12]\n&gt;&gt;&gt; a[::3]\n[1, 4, 7, 10, 13, 16]\nPodobně jako u textových řetězců, seznamy lze sčítat a násobit přirozeným číslem (včetně nuly):\n&gt;&gt;&gt; seznam1 + seznam2\n[2, -4, 'nova hodnota', 105, 0, 'ahoj', 'STROM', '', 'guru']\n&gt;&gt;&gt; seznam1 * 2\n[2, -4, 'nova hodnota', 105, 0, 2, -4, 'nova hodnota', 105, 0]\n&gt;&gt;&gt; 0 * seznam2\n[]\nVýsledkem násobení seznamu nulou (a stejně tak i libovolným záporným celým číslem) je prázdný seznam.\nStejně jako lze pomocí indexů přepisovat jednotlivé položky seznamu, lze také přepisovat celé řezy, a to opět libovolným (tj. libovolně dlouhým) seznamem:\n&gt;&gt;&gt; a = [1,2,3,4,5]\n&gt;&gt;&gt; a[:3] = [\"jedna\",\"dva\",\"tri\",\"tri a pul\"]\n&gt;&gt;&gt; a\n['jedna', 'dva', 'tri', 'tri a pul', 4, 5]\nTímto způsobem lze také přidávat libovolné položky na konec seznamu (všimněte si, že v takovém případě lze použít index, který již je mimo rozsah původního seznamu):\n&gt;&gt;&gt; a[6:] = [6]\n&gt;&gt;&gt; a\n['jedna', 'dva', 'tri', 'tri a pul', 4, 5, 6]\nnebo na začátek seznamu:\n&gt;&gt;&gt; a[:0] = [-1,0]\n&gt;&gt;&gt; a\n[-1.0, 'jedna', 'dva', 'tri', 'tri a pul', 4, 5, 6]\npřípadně kamkoli doprostřed seznamu:\n&gt;&gt;&gt; a[3:3] = [1.5]\n&gt;&gt;&gt; a\n[-1, 0, 'jedna', 1.5, 'dva', 'tri', 'tri a pul', 4, 5, 6]\nStejně lze i vymazat část seznamu vložením prázdného seznamu:\n&gt;&gt;&gt; a[4:7] = []\n&gt;&gt;&gt; a\n[-1, 0, 'jedna', 1.5, 4, 5, 6]\nV kapitole “Proměnné” jsme si vysvětlili, že proměnná je odkazem na objekt v operační paměti. Proměnná a = [1,2,3] je tedy odkazem na příslušný objekt-seznam. To ale znamená, že pokud vytvořím proměnnou b = a, bude tato nová proměnná odkazovat na stejný objekt. Pokud nyní nyní tento objekt prostřednictvím jedné z proměnných změním, změna se pochopitelně dotkne i druhé proměnné:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; a[0] = -50\n&gt;&gt;&gt; a\n[-50, 2, 3]\n&gt;&gt;&gt; b\n[-50, 2, 3]\nPokud chceme vytvořit nezávislou kopii daného seznamu, můžeme použít úplný řez:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = a[:]\n&gt;&gt;&gt; a[0] = -50\n&gt;&gt;&gt; a\n[-50, 2, 3]\n&gt;&gt;&gt; b\n[1, 2, 3]\nVedle výše uvedených možností, jak pracovat se seznamy pomocí matematických operátorů a řezů, existují v Pythonu ještě tzv. metody seznamů, což jsou funkce, které se volají pomocí jména seznamu, tečky a jména dané funkce:\n&gt;&gt;&gt; x = [1,2,3]\n\n# Přidání nového prvku na konec seznamu metodou append\n&gt;&gt;&gt; x.append(\"ahoj\")\n&gt;&gt;&gt; x\n[1, 2, 3, 'ahoj']\n\n# Vložení prvku na danou pozici seznamu metodou insert\n&gt;&gt;&gt; x.insert(1, 1.5) # Vloží hodnotu 1.5 na druhou pozici (tj. s indexem 1)\n&gt;&gt;&gt; x\n[1, 1.5, 2, 3, 'ahoj']\n\n# Seřazení seznamu čísel nebo textových řetězců metodou sort\n&gt;&gt;&gt; x = [2,9,-13,0,50]\n&gt;&gt;&gt; x.sort()\n&gt;&gt;&gt; x\n[-13, 0, 2, 9, 50]\n&gt;&gt;&gt; x = [\"ahoj\",\"rohlik\",\"kafe\",\"zapalovac\",\"sirky\",\"snidane\"]\n&gt;&gt;&gt; x.sort()\n&gt;&gt;&gt; x\n['ahoj', 'kafe', 'rohlik', 'sirky', 'snidane', 'zapalovac']\n\n# Zjištění indexu dané hodnoty metodou index\n&gt;&gt;&gt; x.index(\"sirky\")\n4\n\n# Zjištění, kolikrát se daná hodnota v seznamu vyskytuje, metodou count\n&gt;&gt;&gt; x.count(\"sirky\")\n1\n\n# Vymazání prvního výskytu dané hodnoty metodou remove\n&gt;&gt;&gt; x.remove(\"sirky\")\n&gt;&gt;&gt; x\n['ahoj', 'rohlik', 'kafe', 'zapalovac', 'snidane']\n\n# Převrácení pořadí hodnot v seznamu metodou reverse\n&gt;&gt;&gt; x.reverse()\n&gt;&gt;&gt; x\n['snidane', 'zapalovac', 'kafe', 'rohlik', 'ahoj']\nVedle metod seznamů jsou v Pythonu k dispozici další vestavěné funkce, pomocí nichž lze se seznamy pracovat (tyto funkce lze stejně dobře použít i pro řetězce):\n&gt;&gt;&gt; a = [1,2,3]\n\n# Zjištění délky seznamu funkcí len\n&gt;&gt;&gt; len(a)\n3\n\n# Zjištění nejmenšího a největšího prvku seznamu funkcí min a max\n&gt;&gt;&gt; min(a)\n1\n&gt;&gt;&gt; max(a)\n3\n\n# Umazání části seznamu funkcí del\n&gt;&gt;&gt; a = [1,2,3,4,5]\n&gt;&gt;&gt; del(a[2])\n&gt;&gt;&gt; a\n[1, 2, 4, 5]\n&gt;&gt;&gt; del a[:2]\n&gt;&gt;&gt; a\n[4, 5]\nDo pythonovského seznamu lze vkládat i jiné seznamy (tzv. vnořené seznamy) a vytvořit tak seznam seznamů, příp. seznam seznamů seznamů atd.:\n&gt;&gt;&gt; a = [1, \"ahoj\", [1,2,3], [\"a\",\"b\"]]\n&gt;&gt;&gt; a[2]\n[1, 2, 3]\n&gt;&gt;&gt; a[3]\n['a', 'b']\n&gt;&gt;&gt; a[3][0]\n'a'\nHloubka vnoření může být značná (prakticky neomezená):\n&gt;&gt;&gt; a = [[[[[1]]]]]\n&gt;&gt;&gt; a[0]\n[[[[1]]]]\n&gt;&gt;&gt; a[0][0]\n[[[1]]]\n&gt;&gt;&gt; a[0][0][0]\n[[1]]\n&gt;&gt;&gt; a[0][0][0][0]\n[1]\n&gt;&gt;&gt; a[0][0][0][0][0]\n1\n\n\n\nn-tice (angl. tuple) je struktura ve všem podobná seznamům, až na to, že ji nelze měnit pomocí indexů. Oproti seznamům se zapisuje pomocí kulatých závorek:\n&gt;&gt;&gt; a = (1,2,3)\n&gt;&gt;&gt; a[1]\n2\n&gt;&gt;&gt; a[1] = 4\nTraceback (most recent call last):\n  File \"&lt;pyshell#43&gt;\", line 1, in &lt;module&gt;\n    a[1] = 4\nTypeError: 'tuple' object does not support item assignment\nDůvod, proč existují n-tice a čím se v praxi liší od seznamů, si vysvětlíme později.\nDalším datovým typem podobným seznamu jsou tzv. slovníky. Slovník si lze představit jako seznam s pojmenovanými položkami. Jménům položek se říká klíče. Každou položku slovníku tak tvoří dvojice klíč-hodnota. Slovník se uvozuje složenými závorkami, jednotlivé položky jsou oddělené čárkami a klíč od příslušné hodnoty je oddělen dvojtečkou:\n&gt;&gt;&gt; person = {\"name\": \"Charles\", \"age\": 60, \"childern\": 3}\n&gt;&gt;&gt; person\n{'age': 60, 'name': 'Charles', 'childern': 3}\nZákladní odlišností slovníků od seznamů je, že ve slovníku se k jednotlivým položkám přistupuje nikoli pomocí indexů, ale právě pomocí klíčů:\n&gt;&gt;&gt; person['name']\n'Charles'\n&gt;&gt;&gt; person['age']\n60\nSeznam hodnot resp. klíčů daného slovníku lze obdržet pomocí metod values a keys:\n&gt;&gt;&gt; person.keys()\n['age', 'name', 'childern']\n&gt;&gt;&gt; person.values()\n[60, 'Charles', 3]\nSlovníky tvoří velmi užitečnou součást jazyka Python a možnosti jejich použití se zdaleka nevyčerpávají uvedenou malou ukázkou. V tomto kurzu s nimi však příliš pracovat nebudeme, proto necháváme hlubší seznámení s nimi na čtenáři.\n\n\n\nPravdivostní hodnoty jsou jak známo dvě: pravda (anglicky true) a nepravda (anglicky false). Většina programovacích jazyků, Python nevyjímaje, disponuje zvláštním datovým typem pro reprezentaci těchto dvou hodnot. Většinou se takovému datovému typu říká boolovský (anglicky Boolean), na počest slavného britského matematika 19. století George Boola, který se významně zasloužil o rozvoj matematické logiky a někdy bývá označován i za praotce informatiky.\nV pythonu je datový typ bool přímo odvozen od datového typu int, tedy celých čísel. Hodnota True (pravda) je tak vlastně ve skutečnosti celočíselná hodnota 1 (a může být jedničkou i zastoupena), hodnotě False zase odpovídá číslo 0 (a rovněž může být nulou zastoupena). Důsledkem toho je např. to, že hodnoty True a False mohou být součástí aritmetických výrazů s čísly:\n&gt;&gt;&gt; True + 1\n2\n&gt;&gt;&gt; False * 3\n0\nVelkou výhodou Pythonu je, že je schopen interpretovat v podstatě libovolnou hodnotu libovolného datového typu jako hodnotu pravdivostní. Jakou pravdivostní hodnotu má ta která hodnota lze přitom snadno zjistit pomocí konverzní funkce bool:\n&gt;&gt;&gt; bool(0) \nFalse\n&gt;&gt;&gt; bool(5)\nTrue\n&gt;&gt;&gt; bool(0.0) \nFalse \n&gt;&gt;&gt; bool(-7.0)\nTrue\n&gt;&gt;&gt; bool(\"\") \nFalse \n&gt;&gt;&gt; bool(\"Ahoj\")\nTrue\n&gt;&gt;&gt; bool([]) \nFalse \n&gt;&gt;&gt; bool([1,2,3])\nTrue\nPravdivostní hodnota je také výsledkem operací porovnání:\n&gt;&gt;&gt; 5 &gt; 3\nTrue\n&gt;&gt;&gt; 5 &lt;= 3\nFalse\n&gt;&gt;&gt; \"a\" == \"a\"\nTrue\n\n\n\nV Pythonu, podobně jako ve většině jiných jazyků, existuje zvláštní hodnota reprezentující nic, neboli prázdnou hodnotu. Prázdná hodnota existuje v Pythonu jako datový objekt None, což si lze představit jako hodnotu, kterou lze přiřadit libovolné proměnné:\n&gt;&gt;&gt; a = None\n&gt;&gt;&gt; a\n&gt;&gt;&gt;\nPo zadání jména proměnné se nevypíše „None“, ale opravdu se nevypíše nic. Proměnná sice existuje, ale nic neobsahuje. Ve skutečnosti je při spuštění Pythonu vytvořen v operační paměti počítače datový objekt None, na který se odkazují všechny proměnné, kterým je hodnota None přiřazena (existuje tedy vždy jen jedno nic, bez ohledu na to, kolik proměnných je obsahuje).\nPravdivostní hodnota None je False:\n&gt;&gt;&gt; bool(None)\nFalse\n\n\n\nV této kapitole jste se seznámili s pravidly práce s proměnnými a se základními datovými typy jazyka Python."
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html#proměnné",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html#proměnné",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "V Pythonu je proměnná odkazem na nějaký objekt v operační paměti. Tento objekt může být různého typu (neboli třídy): může jít o číslo, o textový řetězec, nebo o cokoli jiného (viz dále). Proměnná má nějaký název (zvolený námi) a nějakou hodnotu. Hodnotu do proměnné přiřazujeme operátorem =:\n&gt;&gt;&gt; a = 5\nDatový typ proměnné lze zjistit funkcí type:\n&gt;&gt;&gt; type(a)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; b = \"Ahoj světe\"\n&gt;&gt;&gt; type(b)\n&lt;type 'str'&gt;\n\nPojem funkce si důkladně rozebereme později. Zatím stačí chápat, že při volání nějaké funkce vždy napíšeme její název a do závorky její argumenty, tj. nějaké hodnoty, se kterými daná funkce něco dělá. Funkce pak většinou něco tzv. vrací, tj. jejím výsledkem je nějaká hodnota (objekt). Kdykoli tedy vidíte za nějakým názvem jednoduché závorky, máte co do činění s funkcí.\n\nDo proměnné lze “uložit” hodnotu nějaké jiné proměnné:\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; b\n5\nJe důležité však mít na paměti, že změníme-li hodnotu původní proměnné, hodnota nové proměnné zůstává nezměněna (tato proměnná totiž odkazuje stále na původní objekt - v našem případě číslo 5, kdežto původní proměnná už odkazuje na jiný objekt - např. číslo 100):\n&gt;&gt;&gt; a = 100\n&gt;&gt;&gt; b\n5\nProměnné mohou mít téměř libovolné názvy, je však nutné dodržet následující pravidla:\n\nNázev začíná písmenem anglické abecedy nebo podtržítkem\nNásleduje libovolná posloupnost číslic, písmen angl. abecedy a podtržítek\nNesmí jít o klíčové slovo jazyka (např. and nebo if)\nMalá a velká písmena se rozlišují\n\nPython umožňuje i následující podivnost (vytvoření dvou či více proměnných najednou):\n&gt;&gt;&gt; a, b = 3, 5\n&gt;&gt;&gt; a\n3\n&gt;&gt;&gt; b\n5\n\nÚkol 1. Zkuste si vytvořit několik proměnných různých názvů a ověřit jejich výše uvedené chování.\n\nVytvořenou proměnnou lze také smazat, a to pomocí příkazu del:\n&gt;&gt;&gt; x = 5\n&gt;&gt;&gt; x\n5\n&gt;&gt;&gt; del x\n&gt;&gt;&gt; x\nTraceback (most recent call last):\n  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;\n    x\nNameError: name 'x' is not defined"
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html#čísla",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html#čísla",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "V Pythonu jsou dva základní datové typy pro čísla. Jsou to celá čísla (anglicky integer, zkráceně int):\n&gt;&gt;&gt; 56\n56\n&gt;&gt;&gt; -32586\n-32586\na čísla s desetinnou čárkou (anglicky floating point number, zkráceně float):\n&gt;&gt;&gt; 5.32\n5.32\n&gt;&gt;&gt; -6e-7\n-6e-7\n&gt;&gt;&gt; -5.0E-4\n-0.0005\nS čísly lze provádět běžné matematické operace pomocí aritmetických operátorů:\n&gt;&gt;&gt; 3 + 2 # Sčítání\n5\n&gt;&gt;&gt; 3 – 2 # Odčítání\n1\n&gt;&gt;&gt; 3 * 2 # Násobení\n6\n&gt;&gt;&gt; 3 / 2 # Celočíselní dělení celých čísel\n1\n&gt;&gt;&gt; 3.0 / 2 # Dělení\n1.5\n&gt;&gt;&gt; 3.1 // 2 # Celočíselné dělení\n1.0\n&gt;&gt;&gt; 3**2 # Mocnina\n9\n&gt;&gt;&gt; 3 % 2 # Modulo (zbytek po celočíselném dělení)\n1\nČíselný typ výsledku je vždy určen číselným typem vstupních čísel: jsou-li vstupem pouze celá čísla, je výsledkem celé číslo (při dělení se tedy provede celočíselné dělení); je-li alespoň jeden ze vstupů číslo s desetinnou čárkou, je výsledkem rovněž číslo s desetinnou čárkou.\nPython disponuje řadou vestavěných matematických funkcí (v ukázkou jsou jen některé):\n&gt;&gt;&gt; abs(-5) # Absolutní hodnota\n5\n&gt;&gt;&gt; max(5,3,-5,1) # Maximum\n5\n&gt;&gt;&gt; min(5,3,-5,1) # Minimum\n-5\n&gt;&gt;&gt; pow(2,3) # Mocnina (ekvivalent 2**3)\n8\n&gt;&gt;&gt; round(5.6) # Zaokrouhlení\n6.0\n&gt;&gt;&gt; round(5.627,2) # Zaokrouhlení na dvě desetinná místa\n5.63\nDalší matematické funkce lze nalézt v modulu math:\n&gt;&gt;&gt; import math # Načtení modulu math\n&gt;&gt;&gt; math.pi # Aproximace čísla pí\n3.141592653589793\n&gt;&gt;&gt; math.sqrt(2) # Odmocnina\n1.4142135623730951\n&gt;&gt;&gt; math.log(math.exp(1)) # Logaritmus a exponenciela\n1.0\nMezi jednotlivými číselnými typy lze konvertovat:\n&gt;&gt;&gt; a = 5.6\n&gt;&gt;&gt; type(a)\n&lt;type 'float'&gt;\n&gt;&gt;&gt; b = int(a) # Konverze na celé číslo\n&gt;&gt;&gt; b\n5\n&gt;&gt;&gt; type(b)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; c = float(b) # Konverze na číslo s desetinnou čárkou\n&gt;&gt;&gt; c\n5.0\n&gt;&gt;&gt; type(c)\n&lt;type 'float'&gt;\nPodobně lze konvertovat i mezi jinými datovými typy:\n&gt;&gt;&gt; int(\"56\") # Převod textu na celé číslo\n56\n&gt;&gt;&gt; float(\"56\") # Převod textu na číslo s desetinnou čárkou\n56.0\n&gt;&gt;&gt; str(56) # Převod čísla na text\n'56'\n\nÚkol 2. Vyzkoušejte si všechny výše uvedené operace a příkazy."
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html#textové-řetězce",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html#textové-řetězce",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "Textové řetězce (či krátce jen řetězce, angl. string) se zapisují buď v uvozovkách, nebo v apostrofech:\n&gt;&gt;&gt; a = \"Toto je textovy retezec, ktery muze obsahovat znak ',\"\n&gt;&gt;&gt; b = 'a toto je retezec, ktery muze obsahovat znak \".'\n&gt;&gt;&gt; print(a); print(b)\nToto je textovy retezec, ktery muze obsahovat znak ',\na toto je retezec, ktery muze obsahovat znak \".\nTřetím způsobem, jak vytvořit řetězec, je použití trojitých uvozovek. Do takového řetězce je pak možné vkládat i více řádků (aniž bychom museli použít speciální znak pro konec řádku):\n&gt;&gt;&gt; a = \"\"\"Toto je textovy retezec,\nktery obsahuje\ntri radky\"\"\"\n&gt;&gt;&gt; print a\nToto je textovy retezec,\nktery obsahuje\ntri radky\nŘetězce lze do jisté míry chápat jako posloupnosti jednotlivých znaků. V Pythonu jsou řetězce indexované, to znamená, že lze např. číst přímo konkrétní (třeba pátý) znak:\n&gt;&gt;&gt; a = \"Z tohoto retezce budu cist paty znak:\"\n&gt;&gt;&gt; print a[4]\nh\nIndexování v Pythonu začíná nulou, nikoli jedničkou, proto bylo pro vypsání pátého znaku nutné do hranatých závorek psát index 4.\nVedle přístupu k jednotlivým znakům lze také pomocí hranatých závorek a indexů vytvářet tzv. řezy, neboli číst pouze určitou část řetězce:\n&gt;&gt;&gt; a = \"Z tohoto retezce budu delat rezy:\"\n&gt;&gt;&gt; print a[2:10]\ntohoto r\n&gt;&gt;&gt; print a[:20]\nZ tohoto retezce bud\n&gt;&gt;&gt; print a[7:]\no retezce budu delat rezy:\nTvorba řezů se řídí následujícími pravidly:\n\nŘez začíná znakem na pozici prvního indexu a končí na pozici před posledním indexem (poslední prvek tedy již není součástí řezu). Řez a[2:10] tak obsahuje třetí až desátý znak.\nŘez s prázdným prvním indexem obsahuje celý původní řetězec od začátku až do znaku na pozici před posledním indexem.\nŘez s prázdným druhým indexem obsahuje celý původní řetězec počínaje znakem na pozici prvního indexu.\n\nŘetězce (na rozdíl od seznamů) nelze pomocí indexování a řezů přepisovat. Např. pokud bychom chtěli v textu „kost“ změnit první písmeno na „m“, nelze to provést přímo:\n&gt;&gt;&gt; a = \"kost\"\n&gt;&gt;&gt; a[0] = \"m\"\nTraceback (most recent call last):\n  File \"&lt;pyshell#57&gt;\", line 1, in &lt;module&gt;\n    a[0] = \"m\"\nTypeError: 'str' object does not support item assignment\nŘetězce lze sčítat a násobit přirozeným číslem pomocí operátorů + a *:\n&gt;&gt;&gt; a = \"Ahoj\"\n&gt;&gt;&gt; b = \"Svete\"\n&gt;&gt;&gt; print a + b\nAhojSvete\n&gt;&gt;&gt; print a + \" \" + b + \"!\"\nAhoj Svete!\n&gt;&gt;&gt; print a*5\nAhojAhojAhojAhojAhoj\nZměnit výše zmíněnou „kost“ na „most“ lze tedy např. takto:\n&gt;&gt;&gt; a = \"kost\"\n&gt;&gt;&gt; a = \"m\" + a[1:]\n&gt;&gt;&gt; print a\nmost\nŘetězec může obsahovat tzv. escape sekvence, tj. posloupnosti znaků, nesoucí speciální význam. Escape sekvence je vždy uvozena zpětným lomítkem \\:\n&gt;&gt;&gt; print '\\'' # Znak apostrofu v řetězci uvozeném apostrofy\n'\n&gt;&gt;&gt; print \"\\\"\" # Znak uvozovek v řetězci uvozeném uvozovkami\n\"\n&gt;&gt;&gt; print \"Zde je\\ttabulator\" # Znak tabulátoru\nZde je     tabulator\n&gt;&gt;&gt; print \"Zde je\\nnovy radek\" # Znak konce řádku\nZde je\nnovy radek\nJelikož escape sekvence jsou uvozeny zpětným lomítkem, zpětné lomítko samotné nelze v textu použít:\n&gt;&gt;&gt; print(V tomto textu se snazim pouzit znak \\\")\nSyntaxError: EOL while scanning string literal\nTo lze vyřešit použitím dvojitého zpětného lomítka, což je další z escape sekvencí:\n&gt;&gt;&gt; print(\"V tomto textu znak \\\\ klidne pouziji\")\nV tomto textu znak \\ klidne pouziji\nToto je důležité zejména při psaní adresářových a souborových adres, kde se zpětná lomítka používají:\n&gt;&gt;&gt; print \"C:\\\\Users\\\\Muj_pocitac\\\\Documents\"\nC:\\Users\\Muj_pocitac\\Documents\nJiným způsobem psaní adres je použití dopředného lomítka:\n&gt;&gt;&gt; print \"C:/Users/Muj_pocitac/Documents\"\nC:/Users/Muj_pocitac/Documents\nJeště jiný způsob spočívá v uvození řetězce znakem r (před uvozovkami). Tím dáváme najevo, že se jedná o tzv. surový řetězec (angl. raw string), ve kterém se mají všechny znaky číst svým obvyklým způsobem (zpětné lomítko je proto pouze zpětným lomítkem a žádné escape sekvence zde být nemohou):\n&gt;&gt;&gt; print r\"C:\\Users\\Muj_pocitac\\Documents\"\nC:\\Users\\Muj_pocitac\\Documents"
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html#seznamy",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html#seznamy",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "Seznam je posloupnost libovolných objektů. Definuje se pomocí hranatých závorek a jeho položky se oddělují čárkami:\n&gt;&gt;&gt; seznam1 = [2,-4,56,105,0]\n&gt;&gt;&gt; seznam2 = [\"ahoj\",\"STROM\",\"\",\"guru\"]\nDo jednoho seznamu lze ukládat hodnoty různých datových typů (to v jiných programovacích jazycích nebývá zvykem):\n&gt;&gt;&gt; seznam3 = [0, \"ahoj\",-5.78,2,4]\nPodobně jako tomu bylo v případě textových řetězců, k jednotlivým položkám seznamu lze přistupovat pomocí indexů:\n&gt;&gt;&gt; seznam3[3]\n2\nIndexy začínají nulou (tj. první položka seznamu má index 0, nikoli 1!) a lze používat i záporné indexy. Záporné indexy indexují seznam od konce, tj. poslední prvek seznamu má index -1, předposlední -2 atd. Záporné indexování je zvláště výhodné v tom, že lze rychle přistupovat např. k poslední položce seznamu, aniž bychom znali či se odkazovali na délku seznamu:\n&gt;&gt;&gt; seznam3[-1]\n4\nNa rozdíl od textových řetězců, u seznamů lze pomocí indexů měnit jednotlivé položky:\n&gt;&gt;&gt; seznam1[2] = \"nova hodnota\"\n&gt;&gt;&gt; seznam1\n[2, -4, 'nova hodnota', 105, 0]\nŘez seznamu je seznam sestávající pouze z některých prvků původního seznamu. Vytváří se pomocí hranatých závorek, dvou indexů (začátku a konce řezu) a dvojtečky mezi nimi:\n&gt;&gt;&gt; seznam2[1:4]\n['STROM', '', 'guru']\nJak vyplývá z ukázky, prvek na pozici druhého indexu již do řezu nepatří. V řezu lze používat i záporné indexy, takže např. řez\n&gt;&gt;&gt; seznam2[0:-1]\n['ahoj', 'STROM', '']\nobsahuje všechny prvky od prvního do předposledního.\nPokud necháme některý z indexů prázdný, je příslušný řez proveden od začátku resp. do konce seznamu:\n# toto je rez od zacatku seznamu do tretiho prvku:\n&gt;&gt;&gt; seznam2[:3]\n['ahoj', 'STROM', '']\n\n# toto je rez od druheho prvku do konce seznamu:\n&gt;&gt;&gt; seznam2[1:]\n['STROM', '', 'guru']\n\n# toto je tzv. uplny rez:\n&gt;&gt;&gt; seznam2[:]\n['ahoj', 'STROM', '', 'guru']\nDalší možností, jak vytvářet řezy, je použití třetího „indexu“, lépe řečeno hodnoty, která určuje délku kroku při výběru prvků do řezu. Tímto způsobem lze např. vytvořit řez obsahující každé druhé (či třetí) číslo z určitého rozmezí:\n&gt;&gt;&gt; a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\n&gt;&gt;&gt; a[2:10:2]\n[3, 5, 7, 9]\n&gt;&gt;&gt; a[1:13:2]\n[2, 4, 6, 8, 10, 12]\n&gt;&gt;&gt; a[::3]\n[1, 4, 7, 10, 13, 16]\nPodobně jako u textových řetězců, seznamy lze sčítat a násobit přirozeným číslem (včetně nuly):\n&gt;&gt;&gt; seznam1 + seznam2\n[2, -4, 'nova hodnota', 105, 0, 'ahoj', 'STROM', '', 'guru']\n&gt;&gt;&gt; seznam1 * 2\n[2, -4, 'nova hodnota', 105, 0, 2, -4, 'nova hodnota', 105, 0]\n&gt;&gt;&gt; 0 * seznam2\n[]\nVýsledkem násobení seznamu nulou (a stejně tak i libovolným záporným celým číslem) je prázdný seznam.\nStejně jako lze pomocí indexů přepisovat jednotlivé položky seznamu, lze také přepisovat celé řezy, a to opět libovolným (tj. libovolně dlouhým) seznamem:\n&gt;&gt;&gt; a = [1,2,3,4,5]\n&gt;&gt;&gt; a[:3] = [\"jedna\",\"dva\",\"tri\",\"tri a pul\"]\n&gt;&gt;&gt; a\n['jedna', 'dva', 'tri', 'tri a pul', 4, 5]\nTímto způsobem lze také přidávat libovolné položky na konec seznamu (všimněte si, že v takovém případě lze použít index, který již je mimo rozsah původního seznamu):\n&gt;&gt;&gt; a[6:] = [6]\n&gt;&gt;&gt; a\n['jedna', 'dva', 'tri', 'tri a pul', 4, 5, 6]\nnebo na začátek seznamu:\n&gt;&gt;&gt; a[:0] = [-1,0]\n&gt;&gt;&gt; a\n[-1.0, 'jedna', 'dva', 'tri', 'tri a pul', 4, 5, 6]\npřípadně kamkoli doprostřed seznamu:\n&gt;&gt;&gt; a[3:3] = [1.5]\n&gt;&gt;&gt; a\n[-1, 0, 'jedna', 1.5, 'dva', 'tri', 'tri a pul', 4, 5, 6]\nStejně lze i vymazat část seznamu vložením prázdného seznamu:\n&gt;&gt;&gt; a[4:7] = []\n&gt;&gt;&gt; a\n[-1, 0, 'jedna', 1.5, 4, 5, 6]\nV kapitole “Proměnné” jsme si vysvětlili, že proměnná je odkazem na objekt v operační paměti. Proměnná a = [1,2,3] je tedy odkazem na příslušný objekt-seznam. To ale znamená, že pokud vytvořím proměnnou b = a, bude tato nová proměnná odkazovat na stejný objekt. Pokud nyní nyní tento objekt prostřednictvím jedné z proměnných změním, změna se pochopitelně dotkne i druhé proměnné:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; a[0] = -50\n&gt;&gt;&gt; a\n[-50, 2, 3]\n&gt;&gt;&gt; b\n[-50, 2, 3]\nPokud chceme vytvořit nezávislou kopii daného seznamu, můžeme použít úplný řez:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = a[:]\n&gt;&gt;&gt; a[0] = -50\n&gt;&gt;&gt; a\n[-50, 2, 3]\n&gt;&gt;&gt; b\n[1, 2, 3]\nVedle výše uvedených možností, jak pracovat se seznamy pomocí matematických operátorů a řezů, existují v Pythonu ještě tzv. metody seznamů, což jsou funkce, které se volají pomocí jména seznamu, tečky a jména dané funkce:\n&gt;&gt;&gt; x = [1,2,3]\n\n# Přidání nového prvku na konec seznamu metodou append\n&gt;&gt;&gt; x.append(\"ahoj\")\n&gt;&gt;&gt; x\n[1, 2, 3, 'ahoj']\n\n# Vložení prvku na danou pozici seznamu metodou insert\n&gt;&gt;&gt; x.insert(1, 1.5) # Vloží hodnotu 1.5 na druhou pozici (tj. s indexem 1)\n&gt;&gt;&gt; x\n[1, 1.5, 2, 3, 'ahoj']\n\n# Seřazení seznamu čísel nebo textových řetězců metodou sort\n&gt;&gt;&gt; x = [2,9,-13,0,50]\n&gt;&gt;&gt; x.sort()\n&gt;&gt;&gt; x\n[-13, 0, 2, 9, 50]\n&gt;&gt;&gt; x = [\"ahoj\",\"rohlik\",\"kafe\",\"zapalovac\",\"sirky\",\"snidane\"]\n&gt;&gt;&gt; x.sort()\n&gt;&gt;&gt; x\n['ahoj', 'kafe', 'rohlik', 'sirky', 'snidane', 'zapalovac']\n\n# Zjištění indexu dané hodnoty metodou index\n&gt;&gt;&gt; x.index(\"sirky\")\n4\n\n# Zjištění, kolikrát se daná hodnota v seznamu vyskytuje, metodou count\n&gt;&gt;&gt; x.count(\"sirky\")\n1\n\n# Vymazání prvního výskytu dané hodnoty metodou remove\n&gt;&gt;&gt; x.remove(\"sirky\")\n&gt;&gt;&gt; x\n['ahoj', 'rohlik', 'kafe', 'zapalovac', 'snidane']\n\n# Převrácení pořadí hodnot v seznamu metodou reverse\n&gt;&gt;&gt; x.reverse()\n&gt;&gt;&gt; x\n['snidane', 'zapalovac', 'kafe', 'rohlik', 'ahoj']\nVedle metod seznamů jsou v Pythonu k dispozici další vestavěné funkce, pomocí nichž lze se seznamy pracovat (tyto funkce lze stejně dobře použít i pro řetězce):\n&gt;&gt;&gt; a = [1,2,3]\n\n# Zjištění délky seznamu funkcí len\n&gt;&gt;&gt; len(a)\n3\n\n# Zjištění nejmenšího a největšího prvku seznamu funkcí min a max\n&gt;&gt;&gt; min(a)\n1\n&gt;&gt;&gt; max(a)\n3\n\n# Umazání části seznamu funkcí del\n&gt;&gt;&gt; a = [1,2,3,4,5]\n&gt;&gt;&gt; del(a[2])\n&gt;&gt;&gt; a\n[1, 2, 4, 5]\n&gt;&gt;&gt; del a[:2]\n&gt;&gt;&gt; a\n[4, 5]\nDo pythonovského seznamu lze vkládat i jiné seznamy (tzv. vnořené seznamy) a vytvořit tak seznam seznamů, příp. seznam seznamů seznamů atd.:\n&gt;&gt;&gt; a = [1, \"ahoj\", [1,2,3], [\"a\",\"b\"]]\n&gt;&gt;&gt; a[2]\n[1, 2, 3]\n&gt;&gt;&gt; a[3]\n['a', 'b']\n&gt;&gt;&gt; a[3][0]\n'a'\nHloubka vnoření může být značná (prakticky neomezená):\n&gt;&gt;&gt; a = [[[[[1]]]]]\n&gt;&gt;&gt; a[0]\n[[[[1]]]]\n&gt;&gt;&gt; a[0][0]\n[[[1]]]\n&gt;&gt;&gt; a[0][0][0]\n[[1]]\n&gt;&gt;&gt; a[0][0][0][0]\n[1]\n&gt;&gt;&gt; a[0][0][0][0][0]\n1"
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html#n-tice-a-slovníky",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html#n-tice-a-slovníky",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "n-tice (angl. tuple) je struktura ve všem podobná seznamům, až na to, že ji nelze měnit pomocí indexů. Oproti seznamům se zapisuje pomocí kulatých závorek:\n&gt;&gt;&gt; a = (1,2,3)\n&gt;&gt;&gt; a[1]\n2\n&gt;&gt;&gt; a[1] = 4\nTraceback (most recent call last):\n  File \"&lt;pyshell#43&gt;\", line 1, in &lt;module&gt;\n    a[1] = 4\nTypeError: 'tuple' object does not support item assignment\nDůvod, proč existují n-tice a čím se v praxi liší od seznamů, si vysvětlíme později.\nDalším datovým typem podobným seznamu jsou tzv. slovníky. Slovník si lze představit jako seznam s pojmenovanými položkami. Jménům položek se říká klíče. Každou položku slovníku tak tvoří dvojice klíč-hodnota. Slovník se uvozuje složenými závorkami, jednotlivé položky jsou oddělené čárkami a klíč od příslušné hodnoty je oddělen dvojtečkou:\n&gt;&gt;&gt; person = {\"name\": \"Charles\", \"age\": 60, \"childern\": 3}\n&gt;&gt;&gt; person\n{'age': 60, 'name': 'Charles', 'childern': 3}\nZákladní odlišností slovníků od seznamů je, že ve slovníku se k jednotlivým položkám přistupuje nikoli pomocí indexů, ale právě pomocí klíčů:\n&gt;&gt;&gt; person['name']\n'Charles'\n&gt;&gt;&gt; person['age']\n60\nSeznam hodnot resp. klíčů daného slovníku lze obdržet pomocí metod values a keys:\n&gt;&gt;&gt; person.keys()\n['age', 'name', 'childern']\n&gt;&gt;&gt; person.values()\n[60, 'Charles', 3]\nSlovníky tvoří velmi užitečnou součást jazyka Python a možnosti jejich použití se zdaleka nevyčerpávají uvedenou malou ukázkou. V tomto kurzu s nimi však příliš pracovat nebudeme, proto necháváme hlubší seznámení s nimi na čtenáři."
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html#pravdivostní-hodnoty",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html#pravdivostní-hodnoty",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "Pravdivostní hodnoty jsou jak známo dvě: pravda (anglicky true) a nepravda (anglicky false). Většina programovacích jazyků, Python nevyjímaje, disponuje zvláštním datovým typem pro reprezentaci těchto dvou hodnot. Většinou se takovému datovému typu říká boolovský (anglicky Boolean), na počest slavného britského matematika 19. století George Boola, který se významně zasloužil o rozvoj matematické logiky a někdy bývá označován i za praotce informatiky.\nV pythonu je datový typ bool přímo odvozen od datového typu int, tedy celých čísel. Hodnota True (pravda) je tak vlastně ve skutečnosti celočíselná hodnota 1 (a může být jedničkou i zastoupena), hodnotě False zase odpovídá číslo 0 (a rovněž může být nulou zastoupena). Důsledkem toho je např. to, že hodnoty True a False mohou být součástí aritmetických výrazů s čísly:\n&gt;&gt;&gt; True + 1\n2\n&gt;&gt;&gt; False * 3\n0\nVelkou výhodou Pythonu je, že je schopen interpretovat v podstatě libovolnou hodnotu libovolného datového typu jako hodnotu pravdivostní. Jakou pravdivostní hodnotu má ta která hodnota lze přitom snadno zjistit pomocí konverzní funkce bool:\n&gt;&gt;&gt; bool(0) \nFalse\n&gt;&gt;&gt; bool(5)\nTrue\n&gt;&gt;&gt; bool(0.0) \nFalse \n&gt;&gt;&gt; bool(-7.0)\nTrue\n&gt;&gt;&gt; bool(\"\") \nFalse \n&gt;&gt;&gt; bool(\"Ahoj\")\nTrue\n&gt;&gt;&gt; bool([]) \nFalse \n&gt;&gt;&gt; bool([1,2,3])\nTrue\nPravdivostní hodnota je také výsledkem operací porovnání:\n&gt;&gt;&gt; 5 &gt; 3\nTrue\n&gt;&gt;&gt; 5 &lt;= 3\nFalse\n&gt;&gt;&gt; \"a\" == \"a\"\nTrue"
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html#hodnota-none",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html#hodnota-none",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "V Pythonu, podobně jako ve většině jiných jazyků, existuje zvláštní hodnota reprezentující nic, neboli prázdnou hodnotu. Prázdná hodnota existuje v Pythonu jako datový objekt None, což si lze představit jako hodnotu, kterou lze přiřadit libovolné proměnné:\n&gt;&gt;&gt; a = None\n&gt;&gt;&gt; a\n&gt;&gt;&gt;\nPo zadání jména proměnné se nevypíše „None“, ale opravdu se nevypíše nic. Proměnná sice existuje, ale nic neobsahuje. Ve skutečnosti je při spuštění Pythonu vytvořen v operační paměti počítače datový objekt None, na který se odkazují všechny proměnné, kterým je hodnota None přiřazena (existuje tedy vždy jen jedno nic, bez ohledu na to, kolik proměnných je obsahuje).\nPravdivostní hodnota None je False:\n&gt;&gt;&gt; bool(None)\nFalse"
  },
  {
    "objectID": "material/old_materials/Lekce 4 Proměnné a datové typy.html#shrnutí",
    "href": "material/old_materials/Lekce 4 Proměnné a datové typy.html#shrnutí",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "V této kapitole jste se seznámili s pravidly práce s proměnnými a se základními datovými typy jazyka Python."
  },
  {
    "objectID": "material/old_materials/04_part3.html",
    "href": "material/old_materials/04_part3.html",
    "title": "Programování pro GIS a DPZ",
    "section": "",
    "text": "n-tice (angl. tuple) je struktura ve všem podobná seznamům, až na to, že ji nelze měnit pomocí indexů. Oproti seznamům se zapisuje pomocí kulatých závorek:\n&gt;&gt;&gt; a = (1,2,3)\n&gt;&gt;&gt; a[1]\n2\n&gt;&gt;&gt; a[1] = 4\nTraceback (most recent call last):\n  File \"&lt;pyshell#43&gt;\", line 1, in &lt;module&gt;\n    a[1] = 4\nTypeError: 'tuple' object does not support item assignment\nDůvod, proč existují n-tice a čím se v praxi liší od seznamů, si vysvětlíme později.\nDalším datovým typem podobným seznamu jsou tzv. slovníky. Slovník si lze představit jako seznam s pojmenovanými položkami. Jménům položek se říká klíče. Každou položku slovníku tak tvoří dvojice klíč-hodnota. Slovník se uvozuje složenými závorkami, jednotlivé položky jsou oddělené čárkami a klíč od příslušné hodnoty je oddělen dvojtečkou:\n&gt;&gt;&gt; person = {\"name\": \"Charles\", \"age\": 60, \"childern\": 3}\n&gt;&gt;&gt; person\n{'age': 60, 'name': 'Charles', 'childern': 3}\nZákladní odlišností slovníků od seznamů je, že ve slovníku se k jednotlivým položkám přistupuje nikoli pomocí indexů, ale právě pomocí klíčů:\n&gt;&gt;&gt; person['name']\n'Charles'\n&gt;&gt;&gt; person['age']\n60\nSeznam hodnot resp. klíčů daného slovníku lze obdržet pomocí metod values a keys:\n&gt;&gt;&gt; person.keys()\n['age', 'name', 'childern']\n&gt;&gt;&gt; person.values()\n[60, 'Charles', 3]\nSlovníky tvoří velmi užitečnou součást jazyka Python a možnosti jejich použití se zdaleka nevyčerpávají uvedenou malou ukázkou. V tomto kurzu s nimi však příliš pracovat nebudeme, proto necháváme hlubší seznámení s nimi na čtenáři."
  },
  {
    "objectID": "material/old_materials/04_part3.html#n-tice-a-slovníky",
    "href": "material/old_materials/04_part3.html#n-tice-a-slovníky",
    "title": "Programování pro GIS a DPZ",
    "section": "",
    "text": "n-tice (angl. tuple) je struktura ve všem podobná seznamům, až na to, že ji nelze měnit pomocí indexů. Oproti seznamům se zapisuje pomocí kulatých závorek:\n&gt;&gt;&gt; a = (1,2,3)\n&gt;&gt;&gt; a[1]\n2\n&gt;&gt;&gt; a[1] = 4\nTraceback (most recent call last):\n  File \"&lt;pyshell#43&gt;\", line 1, in &lt;module&gt;\n    a[1] = 4\nTypeError: 'tuple' object does not support item assignment\nDůvod, proč existují n-tice a čím se v praxi liší od seznamů, si vysvětlíme později.\nDalším datovým typem podobným seznamu jsou tzv. slovníky. Slovník si lze představit jako seznam s pojmenovanými položkami. Jménům položek se říká klíče. Každou položku slovníku tak tvoří dvojice klíč-hodnota. Slovník se uvozuje složenými závorkami, jednotlivé položky jsou oddělené čárkami a klíč od příslušné hodnoty je oddělen dvojtečkou:\n&gt;&gt;&gt; person = {\"name\": \"Charles\", \"age\": 60, \"childern\": 3}\n&gt;&gt;&gt; person\n{'age': 60, 'name': 'Charles', 'childern': 3}\nZákladní odlišností slovníků od seznamů je, že ve slovníku se k jednotlivým položkám přistupuje nikoli pomocí indexů, ale právě pomocí klíčů:\n&gt;&gt;&gt; person['name']\n'Charles'\n&gt;&gt;&gt; person['age']\n60\nSeznam hodnot resp. klíčů daného slovníku lze obdržet pomocí metod values a keys:\n&gt;&gt;&gt; person.keys()\n['age', 'name', 'childern']\n&gt;&gt;&gt; person.values()\n[60, 'Charles', 3]\nSlovníky tvoří velmi užitečnou součást jazyka Python a možnosti jejich použití se zdaleka nevyčerpávají uvedenou malou ukázkou. V tomto kurzu s nimi však příliš pracovat nebudeme, proto necháváme hlubší seznámení s nimi na čtenáři."
  },
  {
    "objectID": "material/old_materials/04_part3.html#pravdivostní-hodnoty",
    "href": "material/old_materials/04_part3.html#pravdivostní-hodnoty",
    "title": "Programování pro GIS a DPZ",
    "section": "Pravdivostní hodnoty",
    "text": "Pravdivostní hodnoty\nPravdivostní hodnoty jsou jak známo dvě: pravda (anglicky true) a nepravda (anglicky false). Většina programovacích jazyků, Python nevyjímaje, disponuje zvláštním datovým typem pro reprezentaci těchto dvou hodnot. Většinou se takovému datovému typu říká boolovský (anglicky Boolean), na počest slavného britského matematika 19. století George Boola, který se významně zasloužil o rozvoj matematické logiky a někdy bývá označován i za praotce informatiky.\nV pythonu je datový typ bool přímo odvozen od datového typu int, tedy celých čísel. Hodnota True (pravda) je tak vlastně ve skutečnosti celočíselná hodnota 1 (a může být jedničkou i zastoupena), hodnotě False zase odpovídá číslo 0 (a rovněž může být nulou zastoupena). Důsledkem toho je např. to, že hodnoty True a False mohou být součástí aritmetických výrazů s čísly:\n&gt;&gt;&gt; True + 1\n2\n&gt;&gt;&gt; False * 3\n0\nVelkou výhodou Pythonu je, že je schopen interpretovat v podstatě libovolnou hodnotu libovolného datového typu jako hodnotu pravdivostní. Jakou pravdivostní hodnotu má ta která hodnota lze přitom snadno zjistit pomocí konverzní funkce bool:\n&gt;&gt;&gt; bool(0) \nFalse\n&gt;&gt;&gt; bool(5)\nTrue\n&gt;&gt;&gt; bool(0.0) \nFalse \n&gt;&gt;&gt; bool(-7.0)\nTrue\n&gt;&gt;&gt; bool(\"\") \nFalse \n&gt;&gt;&gt; bool(\"Ahoj\")\nTrue\n&gt;&gt;&gt; bool([]) \nFalse \n&gt;&gt;&gt; bool([1,2,3])\nTrue\nPravdivostní hodnota je také výsledkem operací porovnání:\n&gt;&gt;&gt; 5 &gt; 3\nTrue\n&gt;&gt;&gt; 5 &lt;= 3\nFalse\n&gt;&gt;&gt; \"a\" == \"a\"\nTrue"
  },
  {
    "objectID": "material/old_materials/04_part3.html#hodnota-none",
    "href": "material/old_materials/04_part3.html#hodnota-none",
    "title": "Programování pro GIS a DPZ",
    "section": "Hodnota None",
    "text": "Hodnota None\nV Pythonu, podobně jako ve většině jiných jazyků, existuje zvláštní hodnota reprezentující nic, neboli prázdnou hodnotu. Prázdná hodnota existuje v Pythonu jako datový objekt None, což si lze představit jako hodnotu, kterou lze přiřadit libovolné proměnné:\n&gt;&gt;&gt; a = None\n&gt;&gt;&gt; a\n&gt;&gt;&gt;\nPo zadání jména proměnné se nevypíše „None“, ale opravdu se nevypíše nic. Proměnná sice existuje, ale nic neobsahuje. Ve skutečnosti je při spuštění Pythonu vytvořen v operační paměti počítače datový objekt None, na který se odkazují všechny proměnné, kterým je hodnota None přiřazena (existuje tedy vždy jen jedno nic, bez ohledu na to, kolik proměnných je obsahuje).\nPravdivostní hodnota None je False:\n&gt;&gt;&gt; bool(None)\nFalse"
  },
  {
    "objectID": "material/old_materials/04_part3.html#shrnutí",
    "href": "material/old_materials/04_part3.html#shrnutí",
    "title": "Programování pro GIS a DPZ",
    "section": "Shrnutí",
    "text": "Shrnutí\nV této kapitole jste se seznámili s pravidly práce s proměnnými a se základními datovými typy jazyka Python."
  },
  {
    "objectID": "material/old_materials/04_part3.html#úlohy",
    "href": "material/old_materials/04_part3.html#úlohy",
    "title": "Programování pro GIS a DPZ",
    "section": "Úlohy",
    "text": "Úlohy"
  },
  {
    "objectID": "material/old_materials/04_part1.html",
    "href": "material/old_materials/04_part1.html",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "V Pythonu je proměnná odkazem na nějaký objekt v operační paměti. Tento objekt může být různého typu (neboli třídy): může jít o číslo, o textový řetězec, nebo o cokoli jiného (viz dále). Proměnná má nějaký název (zvolený námi) a nějakou hodnotu. Hodnotu do proměnné přiřazujeme operátorem =:\n&gt;&gt;&gt; a = 5\nDatový typ proměnné lze zjistit funkcí type:\n&gt;&gt;&gt; type(a)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; b = \"Ahoj světe\"\n&gt;&gt;&gt; type(b)\n&lt;type 'str'&gt;\n\nPojem funkce si důkladně rozebereme později. Zatím stačí chápat, že při volání nějaké funkce vždy napíšeme její název a do závorky její argumenty, tj. nějaké hodnoty, se kterými daná funkce něco dělá. Funkce pak většinou něco tzv. vrací, tj. jejím výsledkem je nějaká hodnota (objekt). Kdykoli tedy vidíte za nějakým názvem jednoduché závorky, máte co do činění s funkcí.\n\nDo proměnné lze “uložit” hodnotu nějaké jiné proměnné:\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; b\n5\nJe důležité však mít na paměti, že změníme-li hodnotu původní proměnné, hodnota nové proměnné zůstává nezměněna (tato proměnná totiž odkazuje stále na původní objekt - v našem případě číslo 5, kdežto původní proměnná už odkazuje na jiný objekt - např. číslo 100):\n&gt;&gt;&gt; a = 100\n&gt;&gt;&gt; b\n5\nProměnné mohou mít téměř libovolné názvy, je však nutné dodržet následující pravidla:\n\nNázev začíná písmenem anglické abecedy nebo podtržítkem\nNásleduje libovolná posloupnost číslic, písmen angl. abecedy a podtržítek\nNesmí jít o klíčové slovo jazyka (např. and nebo if)\nMalá a velká písmena se rozlišují\n\nPython umožňuje i následující podivnost (vytvoření dvou či více proměnných najednou):\n&gt;&gt;&gt; a, b = 3, 5\n&gt;&gt;&gt; a\n3\n&gt;&gt;&gt; b\n5\n\nÚkol 1. Zkuste si vytvořit několik proměnných různých názvů a ověřit jejich výše uvedené chování.\n\nVytvořenou proměnnou lze také smazat, a to pomocí příkazu del:\n&gt;&gt;&gt; x = 5\n&gt;&gt;&gt; x\n5\n&gt;&gt;&gt; del x\n&gt;&gt;&gt; x\nTraceback (most recent call last):\n  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;\n    x\nNameError: name 'x' is not defined\n\n\n\nV Pythonu jsou dva základní datové typy pro čísla. Jsou to celá čísla (anglicky integer, zkráceně int):\n&gt;&gt;&gt; 56\n56\n&gt;&gt;&gt; -32586\n-32586\na čísla s desetinnou čárkou (anglicky floating point number, zkráceně float):\n&gt;&gt;&gt; 5.32\n5.32\n&gt;&gt;&gt; -6e-7\n-6e-7\n&gt;&gt;&gt; -5.0E-4\n-0.0005\nS čísly lze provádět běžné matematické operace pomocí aritmetických operátorů:\n&gt;&gt;&gt; 3 + 2 # Sčítání\n5\n&gt;&gt;&gt; 3 – 2 # Odčítání\n1\n&gt;&gt;&gt; 3 * 2 # Násobení\n6\n&gt;&gt;&gt; 3 / 2 # Celočíselní dělení celých čísel\n1\n&gt;&gt;&gt; 3.0 / 2 # Dělení\n1.5\n&gt;&gt;&gt; 3.1 // 2 # Celočíselné dělení\n1.0\n&gt;&gt;&gt; 3**2 # Mocnina\n9\n&gt;&gt;&gt; 3 % 2 # Modulo (zbytek po celočíselném dělení)\n1\nČíselný typ výsledku je vždy určen číselným typem vstupních čísel: jsou-li vstupem pouze celá čísla, je výsledkem celé číslo (při dělení se tedy provede celočíselné dělení); je-li alespoň jeden ze vstupů číslo s desetinnou čárkou, je výsledkem rovněž číslo s desetinnou čárkou.\nPython disponuje řadou vestavěných matematických funkcí (v ukázkou jsou jen některé):\n&gt;&gt;&gt; abs(-5) # Absolutní hodnota\n5\n&gt;&gt;&gt; max(5,3,-5,1) # Maximum\n5\n&gt;&gt;&gt; min(5,3,-5,1) # Minimum\n-5\n&gt;&gt;&gt; pow(2,3) # Mocnina (ekvivalent 2**3)\n8\n&gt;&gt;&gt; round(5.6) # Zaokrouhlení\n6.0\n&gt;&gt;&gt; round(5.627,2) # Zaokrouhlení na dvě desetinná místa\n5.63\nDalší matematické funkce lze nalézt v modulu math:\n&gt;&gt;&gt; import math # Načtení modulu math\n&gt;&gt;&gt; math.pi # Aproximace čísla pí\n3.141592653589793\n&gt;&gt;&gt; math.sqrt(2) # Odmocnina\n1.4142135623730951\n&gt;&gt;&gt; math.log(math.exp(1)) # Logaritmus a exponenciela\n1.0\nMezi jednotlivými číselnými typy lze konvertovat:\n&gt;&gt;&gt; a = 5.6\n&gt;&gt;&gt; type(a)\n&lt;type 'float'&gt;\n&gt;&gt;&gt; b = int(a) # Konverze na celé číslo\n&gt;&gt;&gt; b\n5\n&gt;&gt;&gt; type(b)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; c = float(b) # Konverze na číslo s desetinnou čárkou\n&gt;&gt;&gt; c\n5.0\n&gt;&gt;&gt; type(c)\n&lt;type 'float'&gt;\nPodobně lze konvertovat i mezi jinými datovými typy:\n&gt;&gt;&gt; int(\"56\") # Převod textu na celé číslo\n56\n&gt;&gt;&gt; float(\"56\") # Převod textu na číslo s desetinnou čárkou\n56.0\n&gt;&gt;&gt; str(56) # Převod čísla na text\n'56'\n\nÚkol 2. Vyzkoušejte si všechny výše uvedené operace a příkazy.\n\n\n\n\nTextové řetězce (či krátce jen řetězce, angl. string) se zapisují buď v uvozovkách, nebo v apostrofech:\n&gt;&gt;&gt; a = \"Toto je textovy retezec, ktery muze obsahovat znak ',\"\n&gt;&gt;&gt; b = 'a toto je retezec, ktery muze obsahovat znak \".'\n&gt;&gt;&gt; print(a); print(b)\nToto je textovy retezec, ktery muze obsahovat znak ',\na toto je retezec, ktery muze obsahovat znak \".\nTřetím způsobem, jak vytvořit řetězec, je použití trojitých uvozovek. Do takového řetězce je pak možné vkládat i více řádků (aniž bychom museli použít speciální znak pro konec řádku):\n&gt;&gt;&gt; a = \"\"\"Toto je textovy retezec,\nktery obsahuje\ntri radky\"\"\"\n&gt;&gt;&gt; print a\nToto je textovy retezec,\nktery obsahuje\ntri radky\nŘetězce lze do jisté míry chápat jako posloupnosti jednotlivých znaků. V Pythonu jsou řetězce indexované, to znamená, že lze např. číst přímo konkrétní (třeba pátý) znak:\n&gt;&gt;&gt; a = \"Z tohoto retezce budu cist paty znak:\"\n&gt;&gt;&gt; print a[4]\nh\nIndexování v Pythonu začíná nulou, nikoli jedničkou, proto bylo pro vypsání pátého znaku nutné do hranatých závorek psát index 4.\nVedle přístupu k jednotlivým znakům lze také pomocí hranatých závorek a indexů vytvářet tzv. řezy, neboli číst pouze určitou část řetězce:\n&gt;&gt;&gt; a = \"Z tohoto retezce budu delat rezy:\"\n&gt;&gt;&gt; print a[2:10]\ntohoto r\n&gt;&gt;&gt; print a[:20]\nZ tohoto retezce bud\n&gt;&gt;&gt; print a[7:]\no retezce budu delat rezy:\nTvorba řezů se řídí následujícími pravidly:\n\nŘez začíná znakem na pozici prvního indexu a končí na pozici před posledním indexem (poslední prvek tedy již není součástí řezu). Řez a[2:10] tak obsahuje třetí až desátý znak.\nŘez s prázdným prvním indexem obsahuje celý původní řetězec od začátku až do znaku na pozici před posledním indexem.\nŘez s prázdným druhým indexem obsahuje celý původní řetězec počínaje znakem na pozici prvního indexu.\n\nŘetězce (na rozdíl od seznamů) nelze pomocí indexování a řezů přepisovat. Např. pokud bychom chtěli v textu „kost“ změnit první písmeno na „m“, nelze to provést přímo:\n&gt;&gt;&gt; a = \"kost\"\n&gt;&gt;&gt; a[0] = \"m\"\nTraceback (most recent call last):\n  File \"&lt;pyshell#57&gt;\", line 1, in &lt;module&gt;\n    a[0] = \"m\"\nTypeError: 'str' object does not support item assignment\nŘetězce lze sčítat a násobit přirozeným číslem pomocí operátorů + a *:\n&gt;&gt;&gt; a = \"Ahoj\"\n&gt;&gt;&gt; b = \"Svete\"\n&gt;&gt;&gt; print a + b\nAhojSvete\n&gt;&gt;&gt; print a + \" \" + b + \"!\"\nAhoj Svete!\n&gt;&gt;&gt; print a*5\nAhojAhojAhojAhojAhoj\nZměnit výše zmíněnou „kost“ na „most“ lze tedy např. takto:\n&gt;&gt;&gt; a = \"kost\"\n&gt;&gt;&gt; a = \"m\" + a[1:]\n&gt;&gt;&gt; print a\nmost\nŘetězec může obsahovat tzv. escape sekvence, tj. posloupnosti znaků, nesoucí speciální význam. Escape sekvence je vždy uvozena zpětným lomítkem \\:\n&gt;&gt;&gt; print '\\'' # Znak apostrofu v řetězci uvozeném apostrofy\n'\n&gt;&gt;&gt; print \"\\\"\" # Znak uvozovek v řetězci uvozeném uvozovkami\n\"\n&gt;&gt;&gt; print \"Zde je\\ttabulator\" # Znak tabulátoru\nZde je     tabulator\n&gt;&gt;&gt; print \"Zde je\\nnovy radek\" # Znak konce řádku\nZde je\nnovy radek\nJelikož escape sekvence jsou uvozeny zpětným lomítkem, zpětné lomítko samotné nelze v textu použít:\n&gt;&gt;&gt; print(V tomto textu se snazim pouzit znak \\\")\nSyntaxError: EOL while scanning string literal\nTo lze vyřešit použitím dvojitého zpětného lomítka, což je další z escape sekvencí:\n&gt;&gt;&gt; print(\"V tomto textu znak \\\\ klidne pouziji\")\nV tomto textu znak \\ klidne pouziji\nToto je důležité zejména při psaní adresářových a souborových adres, kde se zpětná lomítka používají:\n&gt;&gt;&gt; print \"C:\\\\Users\\\\Muj_pocitac\\\\Documents\"\nC:\\Users\\Muj_pocitac\\Documents\nJiným způsobem psaní adres je použití dopředného lomítka:\n&gt;&gt;&gt; print \"C:/Users/Muj_pocitac/Documents\"\nC:/Users/Muj_pocitac/Documents\nJeště jiný způsob spočívá v uvození řetězce znakem r (před uvozovkami). Tím dáváme najevo, že se jedná o tzv. surový řetězec (angl. raw string), ve kterém se mají všechny znaky číst svým obvyklým způsobem (zpětné lomítko je proto pouze zpětným lomítkem a žádné escape sekvence zde být nemohou):\n&gt;&gt;&gt; print r\"C:\\Users\\Muj_pocitac\\Documents\"\nC:\\Users\\Muj_pocitac\\Documents\n\n\n\nSeznam je posloupnost libovolných objektů. Definuje se pomocí hranatých závorek a jeho položky se oddělují čárkami:\n&gt;&gt;&gt; seznam1 = [2,-4,56,105,0]\n&gt;&gt;&gt; seznam2 = [\"ahoj\",\"STROM\",\"\",\"guru\"]\nDo jednoho seznamu lze ukládat hodnoty různých datových typů (to v jiných programovacích jazycích nebývá zvykem):\n&gt;&gt;&gt; seznam3 = [0, \"ahoj\",-5.78,2,4]\nPodobně jako tomu bylo v případě textových řetězců, k jednotlivým položkám seznamu lze přistupovat pomocí indexů:\n&gt;&gt;&gt; seznam3[3]\n2\nIndexy začínají nulou (tj. první položka seznamu má index 0, nikoli 1!) a lze používat i záporné indexy. Záporné indexy indexují seznam od konce, tj. poslední prvek seznamu má index -1, předposlední -2 atd. Záporné indexování je zvláště výhodné v tom, že lze rychle přistupovat např. k poslední položce seznamu, aniž bychom znali či se odkazovali na délku seznamu:\n&gt;&gt;&gt; seznam3[-1]\n4"
  },
  {
    "objectID": "material/old_materials/04_part1.html#proměnné",
    "href": "material/old_materials/04_part1.html#proměnné",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "V Pythonu je proměnná odkazem na nějaký objekt v operační paměti. Tento objekt může být různého typu (neboli třídy): může jít o číslo, o textový řetězec, nebo o cokoli jiného (viz dále). Proměnná má nějaký název (zvolený námi) a nějakou hodnotu. Hodnotu do proměnné přiřazujeme operátorem =:\n&gt;&gt;&gt; a = 5\nDatový typ proměnné lze zjistit funkcí type:\n&gt;&gt;&gt; type(a)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; b = \"Ahoj světe\"\n&gt;&gt;&gt; type(b)\n&lt;type 'str'&gt;\n\nPojem funkce si důkladně rozebereme později. Zatím stačí chápat, že při volání nějaké funkce vždy napíšeme její název a do závorky její argumenty, tj. nějaké hodnoty, se kterými daná funkce něco dělá. Funkce pak většinou něco tzv. vrací, tj. jejím výsledkem je nějaká hodnota (objekt). Kdykoli tedy vidíte za nějakým názvem jednoduché závorky, máte co do činění s funkcí.\n\nDo proměnné lze “uložit” hodnotu nějaké jiné proměnné:\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; b\n5\nJe důležité však mít na paměti, že změníme-li hodnotu původní proměnné, hodnota nové proměnné zůstává nezměněna (tato proměnná totiž odkazuje stále na původní objekt - v našem případě číslo 5, kdežto původní proměnná už odkazuje na jiný objekt - např. číslo 100):\n&gt;&gt;&gt; a = 100\n&gt;&gt;&gt; b\n5\nProměnné mohou mít téměř libovolné názvy, je však nutné dodržet následující pravidla:\n\nNázev začíná písmenem anglické abecedy nebo podtržítkem\nNásleduje libovolná posloupnost číslic, písmen angl. abecedy a podtržítek\nNesmí jít o klíčové slovo jazyka (např. and nebo if)\nMalá a velká písmena se rozlišují\n\nPython umožňuje i následující podivnost (vytvoření dvou či více proměnných najednou):\n&gt;&gt;&gt; a, b = 3, 5\n&gt;&gt;&gt; a\n3\n&gt;&gt;&gt; b\n5\n\nÚkol 1. Zkuste si vytvořit několik proměnných různých názvů a ověřit jejich výše uvedené chování.\n\nVytvořenou proměnnou lze také smazat, a to pomocí příkazu del:\n&gt;&gt;&gt; x = 5\n&gt;&gt;&gt; x\n5\n&gt;&gt;&gt; del x\n&gt;&gt;&gt; x\nTraceback (most recent call last):\n  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;\n    x\nNameError: name 'x' is not defined"
  },
  {
    "objectID": "material/old_materials/04_part1.html#čísla",
    "href": "material/old_materials/04_part1.html#čísla",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "V Pythonu jsou dva základní datové typy pro čísla. Jsou to celá čísla (anglicky integer, zkráceně int):\n&gt;&gt;&gt; 56\n56\n&gt;&gt;&gt; -32586\n-32586\na čísla s desetinnou čárkou (anglicky floating point number, zkráceně float):\n&gt;&gt;&gt; 5.32\n5.32\n&gt;&gt;&gt; -6e-7\n-6e-7\n&gt;&gt;&gt; -5.0E-4\n-0.0005\nS čísly lze provádět běžné matematické operace pomocí aritmetických operátorů:\n&gt;&gt;&gt; 3 + 2 # Sčítání\n5\n&gt;&gt;&gt; 3 – 2 # Odčítání\n1\n&gt;&gt;&gt; 3 * 2 # Násobení\n6\n&gt;&gt;&gt; 3 / 2 # Celočíselní dělení celých čísel\n1\n&gt;&gt;&gt; 3.0 / 2 # Dělení\n1.5\n&gt;&gt;&gt; 3.1 // 2 # Celočíselné dělení\n1.0\n&gt;&gt;&gt; 3**2 # Mocnina\n9\n&gt;&gt;&gt; 3 % 2 # Modulo (zbytek po celočíselném dělení)\n1\nČíselný typ výsledku je vždy určen číselným typem vstupních čísel: jsou-li vstupem pouze celá čísla, je výsledkem celé číslo (při dělení se tedy provede celočíselné dělení); je-li alespoň jeden ze vstupů číslo s desetinnou čárkou, je výsledkem rovněž číslo s desetinnou čárkou.\nPython disponuje řadou vestavěných matematických funkcí (v ukázkou jsou jen některé):\n&gt;&gt;&gt; abs(-5) # Absolutní hodnota\n5\n&gt;&gt;&gt; max(5,3,-5,1) # Maximum\n5\n&gt;&gt;&gt; min(5,3,-5,1) # Minimum\n-5\n&gt;&gt;&gt; pow(2,3) # Mocnina (ekvivalent 2**3)\n8\n&gt;&gt;&gt; round(5.6) # Zaokrouhlení\n6.0\n&gt;&gt;&gt; round(5.627,2) # Zaokrouhlení na dvě desetinná místa\n5.63\nDalší matematické funkce lze nalézt v modulu math:\n&gt;&gt;&gt; import math # Načtení modulu math\n&gt;&gt;&gt; math.pi # Aproximace čísla pí\n3.141592653589793\n&gt;&gt;&gt; math.sqrt(2) # Odmocnina\n1.4142135623730951\n&gt;&gt;&gt; math.log(math.exp(1)) # Logaritmus a exponenciela\n1.0\nMezi jednotlivými číselnými typy lze konvertovat:\n&gt;&gt;&gt; a = 5.6\n&gt;&gt;&gt; type(a)\n&lt;type 'float'&gt;\n&gt;&gt;&gt; b = int(a) # Konverze na celé číslo\n&gt;&gt;&gt; b\n5\n&gt;&gt;&gt; type(b)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; c = float(b) # Konverze na číslo s desetinnou čárkou\n&gt;&gt;&gt; c\n5.0\n&gt;&gt;&gt; type(c)\n&lt;type 'float'&gt;\nPodobně lze konvertovat i mezi jinými datovými typy:\n&gt;&gt;&gt; int(\"56\") # Převod textu na celé číslo\n56\n&gt;&gt;&gt; float(\"56\") # Převod textu na číslo s desetinnou čárkou\n56.0\n&gt;&gt;&gt; str(56) # Převod čísla na text\n'56'\n\nÚkol 2. Vyzkoušejte si všechny výše uvedené operace a příkazy."
  },
  {
    "objectID": "material/old_materials/04_part1.html#textové-řetězce",
    "href": "material/old_materials/04_part1.html#textové-řetězce",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "Textové řetězce (či krátce jen řetězce, angl. string) se zapisují buď v uvozovkách, nebo v apostrofech:\n&gt;&gt;&gt; a = \"Toto je textovy retezec, ktery muze obsahovat znak ',\"\n&gt;&gt;&gt; b = 'a toto je retezec, ktery muze obsahovat znak \".'\n&gt;&gt;&gt; print(a); print(b)\nToto je textovy retezec, ktery muze obsahovat znak ',\na toto je retezec, ktery muze obsahovat znak \".\nTřetím způsobem, jak vytvořit řetězec, je použití trojitých uvozovek. Do takového řetězce je pak možné vkládat i více řádků (aniž bychom museli použít speciální znak pro konec řádku):\n&gt;&gt;&gt; a = \"\"\"Toto je textovy retezec,\nktery obsahuje\ntri radky\"\"\"\n&gt;&gt;&gt; print a\nToto je textovy retezec,\nktery obsahuje\ntri radky\nŘetězce lze do jisté míry chápat jako posloupnosti jednotlivých znaků. V Pythonu jsou řetězce indexované, to znamená, že lze např. číst přímo konkrétní (třeba pátý) znak:\n&gt;&gt;&gt; a = \"Z tohoto retezce budu cist paty znak:\"\n&gt;&gt;&gt; print a[4]\nh\nIndexování v Pythonu začíná nulou, nikoli jedničkou, proto bylo pro vypsání pátého znaku nutné do hranatých závorek psát index 4.\nVedle přístupu k jednotlivým znakům lze také pomocí hranatých závorek a indexů vytvářet tzv. řezy, neboli číst pouze určitou část řetězce:\n&gt;&gt;&gt; a = \"Z tohoto retezce budu delat rezy:\"\n&gt;&gt;&gt; print a[2:10]\ntohoto r\n&gt;&gt;&gt; print a[:20]\nZ tohoto retezce bud\n&gt;&gt;&gt; print a[7:]\no retezce budu delat rezy:\nTvorba řezů se řídí následujícími pravidly:\n\nŘez začíná znakem na pozici prvního indexu a končí na pozici před posledním indexem (poslední prvek tedy již není součástí řezu). Řez a[2:10] tak obsahuje třetí až desátý znak.\nŘez s prázdným prvním indexem obsahuje celý původní řetězec od začátku až do znaku na pozici před posledním indexem.\nŘez s prázdným druhým indexem obsahuje celý původní řetězec počínaje znakem na pozici prvního indexu.\n\nŘetězce (na rozdíl od seznamů) nelze pomocí indexování a řezů přepisovat. Např. pokud bychom chtěli v textu „kost“ změnit první písmeno na „m“, nelze to provést přímo:\n&gt;&gt;&gt; a = \"kost\"\n&gt;&gt;&gt; a[0] = \"m\"\nTraceback (most recent call last):\n  File \"&lt;pyshell#57&gt;\", line 1, in &lt;module&gt;\n    a[0] = \"m\"\nTypeError: 'str' object does not support item assignment\nŘetězce lze sčítat a násobit přirozeným číslem pomocí operátorů + a *:\n&gt;&gt;&gt; a = \"Ahoj\"\n&gt;&gt;&gt; b = \"Svete\"\n&gt;&gt;&gt; print a + b\nAhojSvete\n&gt;&gt;&gt; print a + \" \" + b + \"!\"\nAhoj Svete!\n&gt;&gt;&gt; print a*5\nAhojAhojAhojAhojAhoj\nZměnit výše zmíněnou „kost“ na „most“ lze tedy např. takto:\n&gt;&gt;&gt; a = \"kost\"\n&gt;&gt;&gt; a = \"m\" + a[1:]\n&gt;&gt;&gt; print a\nmost\nŘetězec může obsahovat tzv. escape sekvence, tj. posloupnosti znaků, nesoucí speciální význam. Escape sekvence je vždy uvozena zpětným lomítkem \\:\n&gt;&gt;&gt; print '\\'' # Znak apostrofu v řetězci uvozeném apostrofy\n'\n&gt;&gt;&gt; print \"\\\"\" # Znak uvozovek v řetězci uvozeném uvozovkami\n\"\n&gt;&gt;&gt; print \"Zde je\\ttabulator\" # Znak tabulátoru\nZde je     tabulator\n&gt;&gt;&gt; print \"Zde je\\nnovy radek\" # Znak konce řádku\nZde je\nnovy radek\nJelikož escape sekvence jsou uvozeny zpětným lomítkem, zpětné lomítko samotné nelze v textu použít:\n&gt;&gt;&gt; print(V tomto textu se snazim pouzit znak \\\")\nSyntaxError: EOL while scanning string literal\nTo lze vyřešit použitím dvojitého zpětného lomítka, což je další z escape sekvencí:\n&gt;&gt;&gt; print(\"V tomto textu znak \\\\ klidne pouziji\")\nV tomto textu znak \\ klidne pouziji\nToto je důležité zejména při psaní adresářových a souborových adres, kde se zpětná lomítka používají:\n&gt;&gt;&gt; print \"C:\\\\Users\\\\Muj_pocitac\\\\Documents\"\nC:\\Users\\Muj_pocitac\\Documents\nJiným způsobem psaní adres je použití dopředného lomítka:\n&gt;&gt;&gt; print \"C:/Users/Muj_pocitac/Documents\"\nC:/Users/Muj_pocitac/Documents\nJeště jiný způsob spočívá v uvození řetězce znakem r (před uvozovkami). Tím dáváme najevo, že se jedná o tzv. surový řetězec (angl. raw string), ve kterém se mají všechny znaky číst svým obvyklým způsobem (zpětné lomítko je proto pouze zpětným lomítkem a žádné escape sekvence zde být nemohou):\n&gt;&gt;&gt; print r\"C:\\Users\\Muj_pocitac\\Documents\"\nC:\\Users\\Muj_pocitac\\Documents"
  },
  {
    "objectID": "material/old_materials/04_part1.html#seznamy",
    "href": "material/old_materials/04_part1.html#seznamy",
    "title": "Lekce 4: Proměnné a datové typy",
    "section": "",
    "text": "Seznam je posloupnost libovolných objektů. Definuje se pomocí hranatých závorek a jeho položky se oddělují čárkami:\n&gt;&gt;&gt; seznam1 = [2,-4,56,105,0]\n&gt;&gt;&gt; seznam2 = [\"ahoj\",\"STROM\",\"\",\"guru\"]\nDo jednoho seznamu lze ukládat hodnoty různých datových typů (to v jiných programovacích jazycích nebývá zvykem):\n&gt;&gt;&gt; seznam3 = [0, \"ahoj\",-5.78,2,4]\nPodobně jako tomu bylo v případě textových řetězců, k jednotlivým položkám seznamu lze přistupovat pomocí indexů:\n&gt;&gt;&gt; seznam3[3]\n2\nIndexy začínají nulou (tj. první položka seznamu má index 0, nikoli 1!) a lze používat i záporné indexy. Záporné indexy indexují seznam od konce, tj. poslední prvek seznamu má index -1, předposlední -2 atd. Záporné indexování je zvláště výhodné v tom, že lze rychle přistupovat např. k poslední položce seznamu, aniž bychom znali či se odkazovali na délku seznamu:\n&gt;&gt;&gt; seznam3[-1]\n4"
  },
  {
    "objectID": "lessons/lesson_01.html",
    "href": "lessons/lesson_01.html",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "",
    "text": "NoteInformace o lekci\n\n\n\nČasová dotace: 90 minut (1,5 hodiny)\nPředpoklady: Základní znalost ArcGIS Pro a Model Builderu (GIS 1, GIS 2)\nMateriály: ArcGIS Pro projekt ke stažení na [odkaz]"
  },
  {
    "objectID": "lessons/lesson_01.html#co-se-v-tomto-kurzu-naučíte",
    "href": "lessons/lesson_01.html#co-se-v-tomto-kurzu-naučíte",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "1.1 Co se v tomto kurzu naučíte",
    "text": "1.1 Co se v tomto kurzu naučíte\nTento kurz vás provede cestou od vizuálního programování v Model Builderu k psaní vlastních Python skriptů pro automatizaci GIS úloh.\n\nTýdny 1-2Týdny 3-5Týdny 6-9Týdny 10-11Týden 12\n\n\nModel Builder → Python\n\nÚvod do automatizace\nPrvní pohled na Python kód\nExport modelů\nIterátory a limity Model Builderu\n\n\n\nZáklady programování v Pythonu\n\nProměnné, cykly, funkce\nPráce se soubory a CSV\nAlgoritmické myšlení\nTřídící algoritmy\n\n\n\nArcPy - Python pro GIS\n\nAutomatizace analýz\nTabulkové operace\nVektorové a rastrové analýzy\nKurzory a geometrie\n\n\n\nPokročilé techniky\n\nPráce s geometriemi\nPython Toolboxy\nTvorba nástrojů s GUI\nOptimalizace kódu\n\n\n\nZávěrečný projekt\n\nVlastní nástroj\nŘešení reálného problému\nDokumentace"
  },
  {
    "objectID": "lessons/lesson_01.html#proč-tento-kurz",
    "href": "lessons/lesson_01.html#proč-tento-kurz",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "1.2 Proč tento kurz?",
    "text": "1.2 Proč tento kurz?\nUž umíte pracovat s ArcGIS Pro - znáte nástroje, dokážete provádět analýzy, vytvářet mapy. Nyní se naučíte GIS automatizovat a programovat.\n\n\n\n\n\n\nTipPříklady z praxe\n\n\n\n🔄 Opakující se úlohy\n“Každý měsíc musíme aktualizovat mapy dostupnosti zdravotnických zařízení pro 14 krajů.”\n→ Řešení: Napsat skript, který to udělá automaticky za 5 minut.\n📊 Velké množství dat\n“Potřebujeme zpracovat 500 rastrových snímků z družice.”\n→ Řešení: Python skript běžící přes noc, vy ráno kontrolujete výsledky.\n🎯 Složité analýzy\n“Chceme optimalizovat umístění větrných elektráren na základě 10 různých kritérií.”\n→ Řešení: Vlastní nástroj s GUI, který může používat kdokoli v týmu."
  },
  {
    "objectID": "lessons/lesson_01.html#struktura-výuky",
    "href": "lessons/lesson_01.html#struktura-výuky",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "1.3 Struktura výuky",
    "text": "1.3 Struktura výuky\nKaždý týden:\n\n2× 1,5 hodiny praktických cvičení\nKombinace výkladu + samostatné práce\nVolitelné úkoly k procvičení\n\nHodnocení:\n\nAktivita na cvičeních\nPrůběžné úkoly (malé, týdenní)\nZávěrečný projekt (hlavní část hodnocení)\n\nFunkční Python nástroj\nŘeší reálný GIS problém\nS dokumentací\n\n\nNástroje:\n\nArcGIS Pro (máte nainstalované?)\nPython 3.x (součást ArcGIS Pro)\nTextový editor (Notepad++, VS Code)\nPozději: Jupyter Notebook"
  },
  {
    "objectID": "lessons/lesson_01.html#zadání",
    "href": "lessons/lesson_01.html#zadání",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "2.1 Zadání",
    "text": "2.1 Zadání\n\n\n\n\n\n\nImportantAnalytická úloha\n\n\n\nJaké je zastoupení lesů v ochranném pásmu 500 metrů kolem železnic v okrese Jindřichův Hradec?\n\n\n\n2.1.1 Proč tato úloha?\n\n✅ Realistická - ochranná pásma, hlukové mapování, dostupnost\n✅ Jednoduchá - pochopitelné kroky\n✅ Rozšiřitelná - později přidáme iterátory a Python\n✅ Ukáže limity Model Builderu → motivace pro Python"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-data",
    "href": "lessons/lesson_01.html#sec-data",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "2.2 Data",
    "text": "2.2 Data\nVšechna data jsou připravena v projektu ArcGIS Pro, který si stáhnete z [odkaz].\n\nOkresyŽelezniceKrajinný pokryv\n\n\nokresy - polygony okresů ČR\n\nSouřadnicový systém: EPSG:3035\nKlíčové pole: NAZ_LAU1 (název okresu)\n\n\n\nzeleznice - linie železnic ČR\n\nSouřadnicový systém: EPSG:3035\nGeometrie: polyline\n\n\n\nclc_2018 - rastr Corine Land Cover\n\nSouřadnicový systém: EPSG:3035\nHodnoty:\n\n1xx = Urbanizované plochy\n2xx = Zemědělská půda\n3xx = Lesy ⭐\n4xx = Mokřady\n5xx = Vodní plochy\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nPoznámka: Data jsou už transformována do jednotného souřadnicového systému ETRS89 LAEA (EPSG: 3035)."
  },
  {
    "objectID": "lessons/lesson_01.html#analytický-postup",
    "href": "lessons/lesson_01.html#analytický-postup",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "2.3 Analytický postup",
    "text": "2.3 Analytický postup\nCíl: Zjistit, kolik procent plochy v pásmu 500m od železnic v okrese Jindřichův Hradec tvoří lesy.\n\nflowchart TD\n    A[Okresy] --&gt; B[Vybrat JH]\n    B --&gt; C[Okres JH]\n    D[železnice] --&gt; E[Oříznout okresem]\n    C --&gt; E\n    E --&gt; F[železnice v JH]\n    F --&gt; G[Buffer 500m]\n    G --&gt; H[Pásmo 500m]\n    I[CLC rastr] --&gt; J[Binární rastr lesů]\n    H --&gt; K[Zónální statistika]\n    J --&gt; K\n    K --&gt; L[Výsledek]\n    \n    style C fill:#6baed6\n    style F fill:#6baed6\n    style H fill:#6baed6\n    style J fill:#74c476\n    style L fill:#fd8d3c\n\n\n\n\n\nflowchart TD\n    A[Okresy] --&gt; B[Vybrat JH]\n    B --&gt; C[Okres JH]\n    D[železnice] --&gt; E[Oříznout okresem]\n    C --&gt; E\n    E --&gt; F[železnice v JH]\n    F --&gt; G[Buffer 500m]\n    G --&gt; H[Pásmo 500m]\n    I[CLC rastr] --&gt; J[Binární rastr lesů]\n    H --&gt; K[Zónální statistika]\n    J --&gt; K\n    K --&gt; L[Výsledek]\n    \n    style C fill:#6baed6\n    style F fill:#6baed6\n    style H fill:#6baed6\n    style J fill:#74c476\n    style L fill:#fd8d3c\n\n\n\n\nFigure 1: Workflow analytického postupu"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-kroky",
    "href": "lessons/lesson_01.html#sec-kroky",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "2.4 Krok za krokem",
    "text": "2.4 Krok za krokem\n\n2.4.1 Příprava\n\nOtevřete ArcGIS Pro projekt Lekce1_AutomatizaceGIS.aprx\nProhlédněte si data v mapě\nVytvořte nový toolbox:\n\nPravý klik v Catalog Pane → New → Toolbox\nPojmenujte: Lekce1_Tools.atbx\n\nVytvořte nový model:\n\nPravý klik na toolbox → New → Model\nPojmenujte: Analyza_Lesu_v_Pasmu\n\n\n\n\n2.4.2 Krok 1: Výběr okresu Jindřichův Hradec\nNástroj: Make Feature Layer\n\n\n\n\n\n\nTipProč Make Feature Layer?\n\n\n\nNástroj Select vytváří novou datovou sadu na disku. Make Feature Layer vytváří pouze dočasnou vrstvu v paměti, což je rychlejší a efektivnější.\n\n\nPostup:\n\nV modelu: Insert → Tool → vyhledat “Make Feature Layer”\nPřetáhněte vrstvu okresy do modelu\nPropojte okresy s nástrojem Make Feature Layer\nDvojklik na nástroj → nastavit parametry:\n\nInput Features: okresy\nOutput Layer: okres_jh_layer\nExpression: Klikněte SQL 🔧\n\n\nNAZ_LAU1 = 'Jindřichův Hradec'\n\nOK\n\nKontrola: 🔵 okresy → 🟡 Make Feature Layer → 🔵 okres_jh_layer\n\n\n2.4.3 Krok 2: Ořezání železnic na okres\nNástroj: Clip\nÚčel: Z celé vrstvy železnic chceme jen úseky, které jsou v okrese JH.\nPostup:\n\nInsert → Tool → “Clip”\nPřetáhněte vrstvu dalnice do modelu\nPropojte:\n\ndalnice → Clip (jako Input Features)\nokres_jh_layer → Clip (jako Clip Features)\n\nDvojklik na Clip → parametry:\n\nInput Features: dalnice\nClip Features: okres_jh_layer\nOutput: dalnice_clip\n\nOK\n\n\n\n2.4.4 Krok 3: Vytvoření ochranného pásma (buffer)\nNástroj: Buffer\n\n\n\n\n\n\nImportantDůležité nastavení\n\n\n\nDissolve Type = ALL (spojí všechny buffery do jednoho)\n\n\nPostup:\n\nInsert → Tool → “Buffer”\nPropojte dalnice_clip → Buffer\nDvojklik na Buffer → parametry:\n\nInput Features: dalnice_clip\nOutput: buffer_500m\nDistance: 500 Meters\nDissolve Type: ALL ← důležité!\nSide Type: FULL\nEnd Type: ROUND\n\nOK\n\n\n\n\n\n\n\nNoteProč Dissolve ALL?\n\n\n\n\n\nBez dissolve bychom měli desítky překrývajících se bufferů (jeden pro každý úsek železnice). S ALL se všechny spojí do jednoho (multi)polygonu.\nDíky tomu dostaneme v zonální statistice přímo jeden výsledek - jedno číslo představující průměr z celého pásma.\n\n\n\n\n\n2.4.5 Krok 4: Vytvoření binárního rastru lesů\nNástroj: Equal To (Spatial Analyst)\nÚčel: Z CLC rastru (hodnoty 1,2,3,4,5) vytvořit rastr s hodnotami 0/1, kde 1 = les.\nPostup:\n\nInsert → Tool → “Equal To” (v kategorii Spatial Analyst → Math → Logical)\nPřetáhněte rastr clc_2018 do modelu\nPropojte clc_2018 → Equal To\nDvojklik na Equal To:\n\nInput raster: clc_2018\nInput value: 3 (kód pro lesy)\nOutput: lesy_binarni\n\nOK\n\n\n\n\n\n\n\nNoteCo se stane?\n\n\n\nRastr bude mít hodnotu 1 tam, kde je les (CLC=3), a hodnotu 0 všude jinde.\n\n\n\n\n2.4.6 Krok 5: Zonální statistika\nNástroj: Zonal Statistics as Table\nÚčel: Spočítat průměr z binárního rastru v rámci bufferu.\n\n\n\n\n\n\nTipMatematický trik\n\n\n\nPrůměr z nul a jedniček = podíl jedniček = relativní plocha lesů!\nPokud je průměr 0.35, znamená to, že 35% pixelů má hodnotu 1 (les).\n\n\nPostup:\n\nInsert → Tool → “Zonal Statistics as Table”\nPropojte:\n\nbuffer_500m → Zonal Statistics (jako Input Zone Data)\nlesy_binarni → Zonal Statistics (jako Input Value Raster)\n\nDvojklik na Zonal Statistics:\n\nInput Zone Data: buffer_500m\nZone Field: OBJECTID\nInput Value Raster: lesy_binarni\nOutput Table: vysledek_lesy.dbf\nStatistics Type: MEAN (průměr)\nIgnore NoData: zaškrtnuto\n\nOK\n\n\n\n2.4.7 Uložení a spuštění modelu\n\n1. Uložit2. Ověřit3. Spustit4. Počkat5. Výsledek\n\n\nFile → Save (Ctrl+S)\n\n\nModel → Validate Entire Model\nPokud je vše OK, všechny nástroje budou barevné (ne šedé)\n\n\nKlikněte na ▶️ Run\n\n\nModel běží, sledujte progress\n\n\nOtevřete vysledek_lesy.dbf"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-vysledek",
    "href": "lessons/lesson_01.html#sec-vysledek",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "2.5 Interpretace výsledku",
    "text": "2.5 Interpretace výsledku\nV tabulce vysledek_lesy.dbf najdete sloupec MEAN.\nVýznam:\n\nMEAN = 0.354 → 35.4% plochy v pásmu tvoří lesy\nMEAN = 0.205 → 20.5% plochy v pásmu tvoří lesy\n\n\n\n\n\n\n\nNoteProč to funguje?\n\n\n\nPrůměr z binárního rastru (0/1) v dané zóně = podíl pixelů s hodnotou 1 = relativní plocha lesů.\nDíky nastavení Dissolve ALL v bufferu máme jeden (multi)polygon, takže dostaneme přímo jedno číslo - procento lesů v celém pásmu kolem železnic v okrese.\n\n\n\n2.5.1 A co kdyby více vzdáleností?\nSituace:\n“Váš šéf říká: ‘Chci vidět, jak se to mění s vzdáleností. Spočítej to pro 100m, 300m, 500m a 1000m.’”\n\n\n\n\n\n\nWarningProblém\n\n\n\nCo byste museli udělat?\n\nZměnit Buffer distance na 100m → spustit\nZměnit na 300m → spustit\nZměnit na 500m → spustit (už máme)\nZměnit na 1000m → spustit\n\n= 4× ručně spustit model, pokaždé změnit parametr\nA pak: 4 samostatné tabulky → jak je dát dohromady pro porovnání?\n\n\n\n\n\n\n\n\nTipŘešení\n\n\n\nPříští týden: Naučíme se ITERÁTORY - automatické procházení různých hodnot\nZa měsíc: Naučíme se PYTHON - elegantní řešení s vnořenými cykly"
  },
  {
    "objectID": "lessons/lesson_01.html#proč-exportovat",
    "href": "lessons/lesson_01.html#proč-exportovat",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "3.1 Proč exportovat?",
    "text": "3.1 Proč exportovat?\nModel Builder je skvělý pro vizualizaci workflow, ale má limity:\n\nTěžko se verzuje (Git, SVN)\nSložité sdílení (musíte sdílet celý toolbox)\nOmezené možnosti logiky (podmínky, cykly)\n\nPython nám dává:\n\n✅ Textový soubor (snadno sdílitelný, verzovatelný)\n✅ Možnost úprav v textovém editoru\n✅ Přidání vlastní logiky\n✅ Spuštění mimo ArcGIS Pro (automatizace)"
  },
  {
    "objectID": "lessons/lesson_01.html#jak-exportovat",
    "href": "lessons/lesson_01.html#jak-exportovat",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "3.2 Jak exportovat",
    "text": "3.2 Jak exportovat\n\nV Model Builderu: Model → Export → To Python Script\nUložit jako: model_export.py\nVybrat lokaci a uložit"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-python-kod",
    "href": "lessons/lesson_01.html#sec-python-kod",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "3.3 Prohlédnutí Python kódu",
    "text": "3.3 Prohlédnutí Python kódu\nOtevřete exportovaný soubor v textovém editoru:\n\nNotepad++ (doporučeno - zvýrazňuje syntax)\nVS Code (pokud máte)\nPoznámkový blok (funguje, ale bez barev)\n\n\n3.3.1 Struktura kódu\n\n\nmodel_export.py\n\n# -*- coding: utf-8 -*-\n# ---------------------------------------------------------------------------\n# model_export.py\n# Created on: 2025-01-15\n# Description: Analýza lesů v pásmu kolem železnic\n# ---------------------------------------------------------------------------\n\n# Import knihovny ArcPy\nimport arcpy\n\n# Lokální proměnné (cesty k datům)\nokresy = \"okresy\"\ndalnice = \"dalnice\"\nclc_2018 = \"clc_2018\"\nokres_jh_layer = \"okres_jh_layer\"\ndalnice_clip = \"C:\\\\Data\\\\dalnice_clip.shp\"\nbuffer_500m = \"C:\\\\Data\\\\buffer_500m.shp\"\nlesy_binarni = \"C:\\\\Data\\\\lesy_binarni.tif\"\nvysledek_lesy = \"C:\\\\Data\\\\vysledek_lesy.dbf\"\n\n# PROCES 1: Make Feature Layer - výběr okresu\narcpy.MakeFeatureLayer_management(\n    in_features=okresy,\n    out_layer=okres_jh_layer,\n    where_clause=\"NAZ_LAU1 = 'Jindřichův Hradec'\"\n)\n\n# PROCES 2: Clip - ořezání železnic\narcpy.Clip_analysis(\n    in_features=dalnice,\n    clip_features=okres_jh_layer,\n    out_feature_class=dalnice_clip\n)\n\n# PROCES 3: Buffer - ochranné pásmo\narcpy.Buffer_analysis(\n    in_features=dalnice_clip,\n    out_feature_class=buffer_500m,\n    buffer_distance_or_field=\"500 Meters\",\n    dissolve_option=\"ALL\"\n)\n\n# PROCES 4: Equal To - binární rastr lesů\narcpy.gp.EqualTo_sa(\n    in_raster_or_constant1=clc_2018,\n    in_raster_or_constant2=\"3\",\n    out_raster=lesy_binarni\n)\n\n# PROCES 5: Zonal Statistics as Table\narcpy.gp.ZonalStatisticsAsTable_sa(\n    in_zone_data=buffer_500m,\n    zone_field=\"OBJECTID\",\n    in_value_raster=lesy_binarni,\n    out_table=vysledek_lesy,\n    statistics_type=\"MEAN\"\n)\n\nprint(\"Model dokončen!\")"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-rozbor-kodu",
    "href": "lessons/lesson_01.html#sec-rozbor-kodu",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "3.4 Co vidíme v kódu?",
    "text": "3.4 Co vidíme v kódu?\n\n3.4.1 1. Import ArcPy\nimport arcpy\n\n\n\n\n\n\nNote\n\n\n\nVýznam: “Chci použít nástroje ArcGIS v Pythonu”\nAnalogie: Jako když v ArcGIS Pro otevřete ArcToolbox - získáte přístup k nástrojům.\n\n\n\n\n3.4.2 2. Proměnné\nokresy = \"okresy\"\nvzdalenost = \"500 Meters\"\n\n\n\n\n\n\nTip\n\n\n\nVýhoda proměnných: Můžeme snadno změnit na jednom místě:\nvzdalenost = \"1000 Meters\"  # Změna parametru!\n\n\n\n\n3.4.3 3. Volání nástroje\narcpy.Buffer_analysis(\n    in_features=dalnice_clip,\n    out_feature_class=buffer_500m,\n    buffer_distance_or_field=\"500 Meters\",\n    dissolve_option=\"ALL\"\n)\nSrovnání s Model Builderem:\n\n\n\nTable 1: Srovnání Model Builder vs. Python\n\n\n\n\n\nModel Builder\nPython\n\n\n\n\nŽlutý obdélník “Buffer”\narcpy.Buffer_analysis()\n\n\nDialog s parametry\nParametry v závorkách\n\n\nPropojení šipkou\nProměnné jako parametry\n\n\nKliknutí na Run\npython script.py\n\n\n\n\n\n\n\n\n\n\n\n\nImportantKlíčové poznání\n\n\n\nJe to STEJNÉ, jen jinak zapsané!"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-prozkoumani",
    "href": "lessons/lesson_01.html#sec-prozkoumani",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "3.5 Interaktivní prozkoumání",
    "text": "3.5 Interaktivní prozkoumání\n\n\n\n\n\n\nNoteÚkol 1: Najděte v kódu\n\n\n\n\n\nKde je napsáno “Jindřichův Hradec”?\nwhere_clause=\"NAZ_LAU1 = 'Jindřichův Hradec'\"\n\n\n\n\n\n\n\n\n\nNoteÚkol 2: Najděte v kódu\n\n\n\n\n\nKde je vzdálenost bufferu?\nbuffer_distance_or_field=\"500 Meters\"\n\n\n\n\n\n\n\n\n\nNoteÚkol 3: Najděte v kódu\n\n\n\n\n\nKde se vytváří binární rastr lesů?\narcpy.gp.EqualTo_sa(\n    in_raster_or_constant1=clc_2018,\n    in_raster_or_constant2=\"3\",  # ← tady je kód pro lesy\n    out_raster=lesy_binarni\n)"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-zmeny",
    "href": "lessons/lesson_01.html#sec-zmeny",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "3.6 Co by se dalo snadno změnit v Pythonu?",
    "text": "3.6 Co by se dalo snadno změnit v Pythonu?\n\nZměna vzdálenostiJiný okresVíce vzdáleností najednou\n\n\n# Místo:\nbuffer_distance_or_field=\"500 Meters\"\n\n# Můžeme:\nvzdalenost = 1000  # metry\nbuffer_distance_or_field=f\"{vzdalenost} Meters\"\n\n\n# Místo:\nwhere_clause=\"NAZ_LAU1 = 'Jindřichův Hradec'\"\n\n# Můžeme:\nokres = \"Praha-východ\"\nwhere_clause=f\"NAZ_LAU1 = '{okres}'\"\n\n\n# V Pythonu bychom mohli:\nvzdalenosti = [100, 300, 500, 1000]\nvysledky = []\n\nfor vzd in vzdalenosti:\n    # Buffer\n    buffer = arcpy.Buffer_analysis(..., f\"{vzd} Meters\")\n    \n    # Zonal Statistics\n    vysledek = arcpy.ZonalStatisticsAsTable(...)\n    \n    # Uložit výsledek\n    vysledky.append(vysledek)\n\n# Hotovo! Všechny vzdálenosti v jednom běhu!\n\n\n\n\n\n\n\n\n\nTipVidíte?\n\n\n\nV Pythonu můžeme snadno:\n\nMěnit parametry\nPřidávat výpočty\nAutomatizovat opakování\nSpojovat výsledky do jedné struktury!"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-srovnani-vyhod",
    "href": "lessons/lesson_01.html#sec-srovnani-vyhod",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "3.7 Výhody Pythonu vs. Model Builder",
    "text": "3.7 Výhody Pythonu vs. Model Builder\n\n\n\nTable 2: Srovnání Model Builder vs. Python\n\n\n\n\n\nAspekt\nModel Builder\nPython\n\n\n\n\nVizualizace\n✅ Výborná\n❌ Žádná (jen text)\n\n\nRychlé vytvoření\n✅ Drag & drop\n❌ Musíte psát\n\n\nSdílení\n⚠️ Toolbox soubor\n✅ Textový .py soubor\n\n\nVerzování (Git)\n❌ Binární formát\n✅ Textový formát\n\n\nPodmínky (IF)\n⚠️ Omezené\n✅ Plná podpora\n\n\nCykly (FOR)\n⚠️ Jen iterátory\n✅ Plná flexibilita\n\n\nVýpočty\n⚠️ Calculate Field\n✅ Jakékoli operace\n\n\nDebugging\n⚠️ Obtížné\n✅ Snadné\n\n\nRychlost běhu\n⚠️ Pomalejší\n✅ Rychlejší\n\n\nSpojování výsledků\n⚠️ Velmi složité\n✅ Jednoduché (seznamy)\n\n\n\n\n\n\n\n\n\n\n\n\nImportantZávěr\n\n\n\nModel Builder = skvělý start, vizuální, rychlý pro jednoduché úlohy\nPython = mocný nástroj pro opakování, složitou logiku, automatizaci"
  },
  {
    "objectID": "lessons/lesson_01.html#různé-vzdálenosti---motivace-pro-iterátory",
    "href": "lessons/lesson_01.html#různé-vzdálenosti---motivace-pro-iterátory",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "4.1 Různé vzdálenosti - motivace pro iterátory",
    "text": "4.1 Různé vzdálenosti - motivace pro iterátory\nScénář: Chceme analyzovat 4 různé vzdálenosti: 100m, 300m, 500m, 1000m\n\n4.1.1 V Model Builderu bez iterátoru\nMuseli byste:\n\nZměnit Buffer distance na 100m → Spustit → vysledek_100.dbf\nZměnit na 300m → Spustit → vysledek_300.dbf\nZměnit na 500m → Spustit → vysledek_500.dbf\nZměnit na 1000m → Spustit → vysledek_1000.dbf\n\n⏱️ Čas: 15-20 minut\n😫 Problém: Nudné, náchylné k chybě, 4 samostatné tabulky\n\n\n4.1.2 S iterátorem (příští týden)\n\nflowchart TD\n    A[Tabulka vzdáleností:&lt;br/&gt;100, 300, 500, 1000] --&gt; B[ITERÁTOR]\n    B --&gt; C[Buffer %Distance%]\n    C --&gt; D[Zonal Statistics]\n    D --&gt; E[vysledek_%Distance%.dbf]\n    \n    style B fill:#fd8d3c\n    style E fill:#6baed6\n\n\n\n\nflowchart TD\n    A[Tabulka vzdáleností:&lt;br/&gt;100, 300, 500, 1000] --&gt; B[ITERÁTOR]\n    B --&gt; C[Buffer %Distance%]\n    C --&gt; D[Zonal Statistics]\n    D --&gt; E[vysledek_%Distance%.dbf]\n    \n    style B fill:#fd8d3c\n    style E fill:#6baed6\n\n\n Model s iterátorem \n\n\n\n\n\n\n\n\n\nTipVýhoda\n\n\n\nSpustíte jednou, iterator automaticky projde všechny vzdálenosti!\n\n\n\n\n\n\n\n\nWarningAle…\n\n\n\nDostanete 4 samostatné tabulky:\n\nvysledek_100.dbf → MEAN = 0.42\nvysledek_300.dbf → MEAN = 0.38\nvysledek_500.dbf → MEAN = 0.35\nvysledek_1000.dbf → MEAN = 0.31\n\nJak je spojíte do jedné pro porovnání?\nV Model Builderu složité (Add Field + Calculate Field + Merge pro každou tabulku).\nV Pythonu jednoduché (seznam)!"
  },
  {
    "objectID": "lessons/lesson_01.html#kombinace-parametrů---motivace-pro-python",
    "href": "lessons/lesson_01.html#kombinace-parametrů---motivace-pro-python",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "4.2 Kombinace parametrů - motivace pro Python",
    "text": "4.2 Kombinace parametrů - motivace pro Python\nScénář: Chceme analyzovat:\n\n2 typy komunikací (železnice, silnice I. třídy)\n× 4 vzdálenosti (100, 300, 500, 1000)\n= 8 kombinací\n\n\n4.2.1 V Model Builderu\n\nflowchart TD\n    A[Model 1: Iterátor komunikací] --&gt; B[železnice]\n    A --&gt; C[Silnice I.]\n    B --&gt; D[Model 2: Iterátor vzdáleností]\n    C --&gt; E[Model 2: Iterátor vzdáleností]\n    D --&gt; F[4 tabulky]\n    E --&gt; G[4 tabulky]\n    \n    style A fill:#fd8d3c\n    style D fill:#fee391\n    style E fill:#fee391\n\n\n\n\nflowchart TD\n    A[Model 1: Iterátor komunikací] --&gt; B[železnice]\n    A --&gt; C[Silnice I.]\n    B --&gt; D[Model 2: Iterátor vzdáleností]\n    C --&gt; E[Model 2: Iterátor vzdáleností]\n    D --&gt; F[4 tabulky]\n    E --&gt; G[4 tabulky]\n    \n    style A fill:#fd8d3c\n    style D fill:#fee391\n    style E fill:#fee391\n\n\n Vnořené modely (složité!) \n\n\n\n\n\n\n\n\n\nWarningProblémy\n\n\n\n\nPotřebujete 2 vnořené modely (složité nastavení!)\nModel 1 (vnější) volá Model 2 (vnitřní)\nVýsledek: 8 samostatných tabulek\nJak je spojit? Velmi složité…\n\n\n\n\n\n4.2.2 V Pythonu\nkomunikace = ['dalnice', 'silnice1']\nvzdalenosti = [100, 300, 500, 1000]\n\nvysledky = []\n\nfor kom in komunikace:\n    for vzd in vzdalenosti:\n        vysledek = analyzuj(kom, vzd)\n        vysledky.append({\n            'Komunikace': kom,\n            'Vzdalenost': vzd,\n            'Procento_lesu': vysledek\n        })\n\n# Jedna tabulka, 8 řádků!\nuloz_tabulku(vysledky, 'vsechny_vysledky.csv')\n\n\n\n\n\n\nImportantVidíte rozdíl?\n\n\n\nModel Builder: 2 modely, 8 tabulek, složité spojování\nPython: Vnořený for cyklus (5 řádků), hotovo!"
  },
  {
    "objectID": "lessons/lesson_01.html#co-jsme-se-dnes-naučili",
    "href": "lessons/lesson_01.html#co-jsme-se-dnes-naučili",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "5.1 Co jsme se dnes naučili",
    "text": "5.1 Co jsme se dnes naučili\n\n\n\n\n\n\nTipPřehled lekce\n\n\n\n✅ Struktura kurzu\n\n12 týdnů od Model Builderu k Pythonu\nPraktické příklady motivace\n\n✅ Praktická úloha\n\nAnalýza krajinného pokryvu v ochranných pásmech\n5 kroků: výběr → clip → buffer → binární rastr → zonální statistika\nVýsledek: procento lesů v pásmu 500m kolem železnic\n\n✅ Export do Pythonu\n\nModel = Python kód\nPrvní pohled na Python syntax\nSrovnání Model Builder vs. Python\n\n✅ Limity Model Builderu\n\nOpakování = ruční spouštění nebo iterátory\nVíce tabulek = složité spojování\nVnořené cykly = velmi složité\nMotivace pro Python!"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-priste",
    "href": "lessons/lesson_01.html#sec-priste",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "5.2 Co nás čeká příště (Lekce 2)",
    "text": "5.2 Co nás čeká příště (Lekce 2)\n\nPrvní část - IterátoryDruhá část - Model ToolTřetí část - Vnořené modely\n\n\n\nITERÁTORY v Model Builderu\nIterate Field Values - procházení různých vzdáleností\nAutomatické opakování\nProblém: 4 samostatné tabulky - jak spojit?\n\n\n\n\nZ modelu vytvoříme nástroj s GUI\nParametry: uživatel si vybere vzdálenost\nNástroj můžete sdílet s kolegy\nPoužití v dalších modelech\n\n\n\n\nModel volá jiný model\nZpůsob, jak obejít “max 1 iterátor”\nUkáže limity Model Builderu\nMotivace pro Python vnořené cykly"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-pojmy",
    "href": "lessons/lesson_01.html#sec-pojmy",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "5.3 Klíčové pojmy",
    "text": "5.3 Klíčové pojmy\n\n\n\nTable 3: Klíčové pojmy z lekce\n\n\n\n\n\nPojem\nVýznam\n\n\n\n\nAutomatizace\nOpakované spouštění úloh bez lidského zásahu\n\n\nModel Builder\nNástroj pro vizuální tvorbu workflow\n\n\nWorkflow\nPosloupnost kroků vedoucí k výsledku\n\n\nIterator\nMechanismus pro automatické opakování (příště)\n\n\nArcPy\nPython knihovna pro ArcGIS\n\n\nZonální statistika\nVýpočet statistik v definovaných zónách\n\n\nBinární rastr\nRastr s hodnotami 0/1 (ano/ne)\n\n\nDissolve\nSpojení více prvků do jednoho"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-ukol",
    "href": "lessons/lesson_01.html#sec-ukol",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "5.4 Domácí úkol (volitelný)",
    "text": "5.4 Domácí úkol (volitelný)\nProcvičte si látku pomocě volitelných úkolů níže.\n\n\n\n\n\n\nTipDoporučení\n\n\n\n\nZačněte Úkolem 1 (lehký) - určitě zvládnete!\nPokud vás to baví, zkuste Úkol 2 nebo 3\nÚkol 4 je pro prozkoumání Python kódu\nÚkol 5 (BONUS) je záměrně velmi těžký - ukáže vám limity MB"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-ukol1",
    "href": "lessons/lesson_01.html#sec-ukol1",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "6.1 Úkol 1: Změna parametrů modelu ⭐",
    "text": "6.1 Úkol 1: Změna parametrů modelu ⭐\n\n\n\n\n\n\nNoteObtížnost: Lehká\n\n\n\nCíl: Naučit se měnit parametry v modelu a vidět, jak to ovlivní výsledky.\n\n\nZadání:\nUpravte svůj model tak, aby analyzoval pásmo 300 metrů (místo 500m) kolem železnic v okrese Jindřichův Hradec.\nOčekávaný výsledek:\n\nUpravený model s bufferem 300m\nNová výsledná tabulka\nPorovnání: je procento lesů v pásmu 300m vyšší nebo nižší než v 500m? Proč?\n\n\n\n\n\n\n\nTipPostup\n\n\n\n\n\n\nOtevřete svůj model Analyza_Lesu_v_Pasmu\nDvojklik na nástroj Buffer\nZměňte Distance: 500 Meters → 300 Meters\nZměňte název výstupu: buffer_500m → buffer_300m\nZměňte název výsledné tabulky: vysledek_lesy.dbf → vysledek_lesy_300m.dbf\nUložte a spusťte model\nPorovnejte výsledky (MEAN hodnoty)\n\n\n\n\nOtázky k zamyšlení:\n\nJe procento lesů v užším pásmu (300m) jiné než v širším (500m)?\nJak byste to vysvětlili? (Nápověda: rozmístění lesů vs. železnic)\n\n\n\n\n\n\n\nTipBonus\n\n\n\n\n\nVytvořte tabulku v Excelu s porovnáním:\n\n\n\nVzdálenost\nProcento lesů\n\n\n\n\n300m\nX.X%\n\n\n500m\nY.Y%\n\n\n\nVytvořte graf závislosti procenta lesů na vzdálenosti od železnic."
  },
  {
    "objectID": "lessons/lesson_01.html#sec-ukol2",
    "href": "lessons/lesson_01.html#sec-ukol2",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "6.2 Úkol 2: Jiný okres ⭐⭐",
    "text": "6.2 Úkol 2: Jiný okres ⭐⭐\n\n\n\n\n\n\nNoteObtížnost: Střední\n\n\n\nCíl: Pochopit, jak změnit atributový dotaz v modelu.\n\n\nZadání:\nUpravte model tak, aby analyzoval okres Praha-východ (místo Jindřichův Hradec).\nOčekávaný výsledek:\n\nModel fungující pro okres Praha-východ\nVýsledná tabulka s procentem lesů\nPorovnání: má Praha-východ více nebo méně lesů v pásmech kolem železnic než JH?\n\n\n\n\n\n\n\nTipPostup\n\n\n\n\n\n\nNejdřív zjistěte přesný název okresu:\n\nOtevřete atributovou tabulku vrstvy okresy\nNajděte pole NAZ_LAU1\nNajděte řádek s Prahou-východ (může být “Praha-východ” nebo “Praha - východ”)\n\nV modelu: dvojklik na Make Feature Layer\nZměňte Expression:\nNAZ_LAU1 = 'Praha-východ'\n(Pozor na přesný zápis!)\nZměňte názvy výstupů, aby bylo jasné, že jde o jiný okres\nSpusťte model\n\n\n\n\n\n\n\n\n\n\nWarningNápověda\n\n\n\n\n\n\nPokud model hlásí “0 features selected”, zkontrolujte přesný název okresu v datech\nMůže být potřeba použít LIKE místo =:\nNAZ_LAU1 LIKE '%Praha%východ%'\n\n\n\n\n\n\n\n\n\n\nTipBonus\n\n\n\n\n\nVytvořte srovnávací tabulku pro 3-5 různých okresů:\n\n\n\nOkres\nProcento lesů\n\n\n\n\nJindřichův Hradec\n35.4%\n\n\nPraha-východ\n?\n\n\nPrachatice\n?\n\n\n…\n…\n\n\n\nKterý okres má nejvíce lesů kolem železnic?"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-ukol3",
    "href": "lessons/lesson_01.html#sec-ukol3",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "6.3 Úkol 3: Jiný typ krajinného pokryvu ⭐⭐",
    "text": "6.3 Úkol 3: Jiný typ krajinného pokryvu ⭐⭐\n\n\n\n\n\n\nNoteObtížnost: Střední\n\n\n\nCíl: Naučit se analyzovat různé kategorie dat změnou jednoho parametru.\n\n\nZadání:\nAnalyzujte zastoupení zemědělské půdy (CLC kód 2) místo lesů v pásmu 500m kolem železnic v okrese JH.\nOčekávaný výsledek:\n\nModel analyzující zemědělskou půdu\nPorovnání: je v pásmu více lesů nebo zemědělské půdy?\n\n\n\n\n\n\n\nTipPostup\n\n\n\n\n\n\nV modelu: dvojklik na nástroj Equal To\nZměňte Input value: 3 → 2\nZměňte názvy výstupů:\n\nlesy_binarni → zempuda_binarni\nvysledek_lesy.dbf → vysledek_zempuda.dbf\n\nSpusťte model\n\n\n\n\n\n\n\n\n\n\nTipRozšíření\n\n\n\n\n\nVytvořte tabulku se všemi typy krajinného pokryvu:\n\n\n\nCLC kód\nTyp\nProcento\n\n\n\n\n1\nUrbanizované plochy\n?\n\n\n2\nZemědělská půda\n?\n\n\n3\nLesy\n35.4%\n\n\n4\nMokřady\n?\n\n\n5\nVodní plochy\n?\n\n\n\n(Musíte spustit model 5× s různými kódy)\n\n\n\n\n\n\n\n\n\nImportantOtázka k zamyšlení\n\n\n\nJe tento postup efektivní? Co kdybyste chtěli 10 kategorií? 50?\nOdpověď: Proto se naučíme iterátory (příště) a Python (za měsíc)!"
  },
  {
    "objectID": "lessons/lesson_01.html#sec-ukol4",
    "href": "lessons/lesson_01.html#sec-ukol4",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "6.4 Úkol 4: Export a zkoumání Python kódu ⭐",
    "text": "6.4 Úkol 4: Export a zkoumání Python kódu ⭐\n\n\n\n\n\n\nNoteObtížnost: Lehká\n\n\n\nCíl: Seznámit se s Python syntaxí na vašem vlastním modelu.\n\n\nZadání:\nExportujte váš model do Pythonu a prozkoumejte kód.\n\n\n\n\n\n\nTipPostup\n\n\n\n\n\n\nV Model Builderu: Model → Export → To Python Script\nUložte jako muj_model.py\nOtevřete v textovém editoru (Notepad++, VS Code, nebo Poznámkový blok)\n\n\n\n\nÚkoly v kódu:\n\nA) NajděteB) ExperimentujteC) Přemýšlejte\n\n\nNajděte a zvýrazněte:\n\nŘádek s importem arcpy\nŘádek, kde se vytváří buffer 500m\nŘádek s SQL dotazem pro okres\nŘádek s hodnotou pro lesy (3)\n\n\n\nExperimentujte (bez spouštění!):\n\nZkuste změnit \"500 Meters\" na \"1000 Meters\" - na kterém řádku?\nNajděte místo, kde byste změnili okres na jiný\nKolik řádků by bylo potřeba změnit, abyste změnili vzdálenost? A v modelu?\n\n\n\nPřemýšlejte:\n\nJe kód čitelný? Rozumíte alespoň trochu, co dělá?\nKteré části jsou jasné, které ne?\nVidíte výhody textové podoby vs. grafické?\nJak by se v Pythonu řešilo 4 různé vzdálenosti?\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nPoznámka: Kód zatím nespouštějte - to se naučíme příště. Teď jen pozorujte strukturu."
  },
  {
    "objectID": "lessons/lesson_01.html#sec-ukol5",
    "href": "lessons/lesson_01.html#sec-ukol5",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "6.5 Úkol 5 (BONUS): Čtyři vzdálenosti - ukázka problému ⭐⭐⭐",
    "text": "6.5 Úkol 5 (BONUS): Čtyři vzdálenosti - ukázka problému ⭐⭐⭐\n\n\n\n\n\n\nWarningObtížnost: Velmi těžká\n\n\n\nVAROVÁNÍ: Tento úkol je záměrně obtížný! Jeho cílem je ukázat vám problém, který v příští lekci vyřešíme iterátorem, a za měsíc elegantně v Pythonu.\nNebojte se, pokud se vám to nepodaří - právě proto se učíme Python! 😊\n\n\nZadání:\nSpočítejte procento lesů pro 4 různé vzdálenosti: 100m, 300m, 500m, 1000m\nOčekávaný výsledek:\nTabulka (v Excelu nebo jako poznámky):\n\n\n\nVzdálenost\nProcento lesů\n\n\n\n\n100m\n?\n\n\n300m\n?\n\n\n500m\n35.4%\n\n\n1000m\n?\n\n\n\n\nPřístup A (manuální)Přístup B (preview iterátoru)\n\n\nPřístup A (nejjednodušší, ale nudný):\n\nSpusťte model s 100m → zapište výsledek\nZměňte na 300m, spusťte → zapište výsledek\nZměňte na 500m, spusťte → zapište výsledek (už máte)\nZměňte na 1000m, spusťte → zapište výsledek\n\nMěřte čas: Kolik celkem trvalo všech 4 spuštění?\n\n\nPřístup B (pokročilý - preview na příští týden):\nPokud se chcete pokusit o iterátor již nyní:\n\nVytvořte v Excelu nebo jako DBF tabulku se vzdálenostmi:\nDistance\n100\n300\n500\n1000\nPřidejte do modelu Iterate Field Values\nZkuste propojit s bufferem…\n\nPoznámka: Pravděpodobně narazíte na problémy! To je v pořádku - příští týden to společně vyřešíme.\n\n\n\n\n6.5.1 Reflexe (důležitější než řešení!)\nPo dokončení napište:\n\nKolik času vám to zabralo?\nKolik chyb jste udělali? (zapomenuté změny parametru, špatné názvy…)\nJak byste se cítili, kdyby zadání bylo 20 vzdáleností?\nVidíte potřebu automatizace?\n\n\n\n\n\n\n\nImportantUkázka Python řešení (jen se podívejte)\n\n\n\n\n\n# V Pythonu by to vypadalo takto (nemusíte rozumět detailům):\n\nvzdalenosti = [100, 300, 500, 1000]\nvysledky = []\n\nfor vzd in vzdalenosti:\n    # Buffer\n    buffer = arcpy.Buffer_analysis(\n        dalnice_clip, \n        f\"buffer_{vzd}m\",\n        f\"{vzd} Meters\",\n        dissolve_option=\"ALL\"\n    )\n    \n    # Equal To\n    binary = arcpy.sa.EqualTo(clc_2018, 3)\n    \n    # Zonal Statistics\n    stats = arcpy.sa.ZonalStatisticsAsTable(\n        buffer, \"OBJECTID\", binary,\n        f\"stats_{vzd}.dbf\", statistics_type=\"MEAN\"\n    )\n    \n    # Přečíst výsledek\n    with arcpy.da.SearchCursor(stats, [\"MEAN\"]) as cursor:\n        mean_value = next(cursor)[0]\n    \n    # Uložit\n    vysledky.append({\n        'Vzdalenost': vzd,\n        'Procento': mean_value * 100\n    })\n\n# Vytvoř jednu tabulku se všemi výsledky\nimport pandas as pd\ndf = pd.DataFrame(vysledky)\ndf.to_csv('vysledky_vsechny.csv')\n\nprint(\"Hotovo! Všechny 4 vzdálenosti zpracovány.\")\nprint(df)\nVýstup:\n   Vzdalenost  Procento\n0         100     42.3\n1         300     38.1\n2         500     35.4\n3        1000     31.2\n\nHotovo! Všechny 4 vzdálenosti zpracovány.\nPonaučení: Vidíte, proč se učíme Python? 😊"
  },
  {
    "objectID": "lessons/lesson_01.html#dokumentace",
    "href": "lessons/lesson_01.html#dokumentace",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "7.1 Dokumentace",
    "text": "7.1 Dokumentace\n\n\n\n\n\n\nTipArcGIS Pro\n\n\n\n\nModel Builder dokumentace\nGeoprocessing nástroje\nIterators in ModelBuilder\n\n\n\n\n\n\n\n\n\nTipArcPy (Python)\n\n\n\n\nArcPy dokumentace\nArcPy Get Started"
  },
  {
    "objectID": "lessons/lesson_01.html#corine-land-cover",
    "href": "lessons/lesson_01.html#corine-land-cover",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "7.2 Corine Land Cover",
    "text": "7.2 Corine Land Cover\n\nCorine Land Cover - dokumentace\nCLC Nomenclature"
  },
  {
    "objectID": "lessons/lesson_01.html#tipy-na-další-studium",
    "href": "lessons/lesson_01.html#tipy-na-další-studium",
    "title": "Lekce 1: Úvod do automatizace GIS pomocí Model Builderu",
    "section": "7.3 Tipy na další studium",
    "text": "7.3 Tipy na další studium\n\nProcvičujte: Čím víc modelů vytvoříte, tím lépe pochopíte workflow\nExperimentujte: Zkuste různé nástroje a parametry\nDokumentujte: Pište si poznámky k modelům (Description v properties)\nPřipravte se na iterátory: Přemýšlejte, co by se dalo automatizovat\nSledujte Python kód: I když mu ještě nerozumíte, zvykejte si na syntax"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python-for-ArcGIS-CZU",
    "section": "",
    "text": "Python-for-ArcGIS-CZU\nZde naleznete materiály k předmětu Programování pro GIS a DPZ, vyučovaným na Fakultě životního prostředí ČZU v Praze. Obsahem předmětu jsou pokročilé metody ovládání funkcionality programu ArcGIS: Model Builder, ale především psaní skriptů v programovacím jazyce Python. Nepředpokládá se žádná předchozí znalost programování (i když je jistě výhodou), naopak součástí kurzu je úvod do programování v Pythonu."
  },
  {
    "objectID": "lessons/lesson_03.html",
    "href": "lessons/lesson_03.html",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "",
    "text": "Po absolvování této lekce budete umět:\n\nVysvětlit, co je Python a proč se používá v GIS\nSpustit první Python program\nPracovat se základními datovými typy (čísla, text)\nPoužívat proměnné pro ukládání dat\nKomunikovat s uživatelem pomocí print() a input()\nPracovat se seznamy (vytvoření, indexování, přidávání prvků)\n\nČasová dotace: 90 minut"
  },
  {
    "objectID": "lessons/lesson_03.html#úrovně-programovacích-jazyků",
    "href": "lessons/lesson_03.html#úrovně-programovacích-jazyků",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "2.1 Úrovně programovacích jazyků",
    "text": "2.1 Úrovně programovacích jazyků\nPočítač rozumí pouze binárním instrukcím (0 a 1). Programovací jazyky se liší tím, jak blízko jsou lidskému myšlení nebo hardwaru.\n\n2.1.1 Nízkoúrovňové jazyky (blízko hardwaru)\nStrojový kód: - Binární instrukce (01001011 10110100…) - Přímo vykonává procesor - Téměř nečitelné pro člověka\nAssembly: - Nejnižší “lidsky čitelný” jazyk - Každá instrukce = jedna operace procesoru - Zkratky: MOV, ADD, JMP\nMOV AX, 5      ; Ulož 5 do paměti\nADD AX, 3      ; Přičti 3\nKdy se používá: Ovladače hardwaru, jádro operačního systému, kritické části vyžadující maximální rychlost.\n\n\n2.1.2 Vysokoúrovňové jazyky (blízko lidskému myšlení)\nVlastnosti: - Čitelný kód (if, for, print()) - Abstrakce - nemusíte řešit detaily hardwaru - Přenositelnost - stejný kód na různých platformách - Rychlejší vývoj, méně chyb\nPříklady: Python, Java, C++, R, JavaScript\nSrovnání Assembly vs. Python:\n; Assembly\nMOV AX, 5\nADD AX, 3\n# Python\nvysledek = 5 + 3\n\n\n2.1.3 Kde je Python?\nPython patří mezi vysokoúrovňové jazyky - hodně abstraktní a čitelný. Snadno se učí, ale je pomalejší než C++.\nHierarchie:\nStrojový kód (0101...)\n       ↓\nAssembly (MOV, ADD...)\n       ↓\nC, C++\n       ↓\nPython, Java"
  },
  {
    "objectID": "lessons/lesson_03.html#interpretovaný-vs.-kompilovaný-jazyk",
    "href": "lessons/lesson_03.html#interpretovaný-vs.-kompilovaný-jazyk",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "2.2 Interpretovaný vs. kompilovaný jazyk",
    "text": "2.2 Interpretovaný vs. kompilovaný jazyk\nPython = interpretovaný jazyk - kód se překládá a vykonává řádek po řádku:\nscript.py → Python interpret → Spuštění\nKompilované jazyky (C, C++) - celý program se nejprve přeloží:\nprogram.c → Kompilátor → strojový kód (.exe) → Spuštění\nVýhody interpretace: - ✅ Napíšete kód a okamžitě ho spustíte - ✅ Snadné ladění - ✅ Přenositelnost\nNevýhody: - ❌ Pomalejší než kompilované jazyky - ❌ Vyžaduje nainstalovaný Python interpret\n\n\n\n\n\n\nTipPro GIS je rychlost dostatečná\n\n\n\nPro většinu GIS úloh je rychlost Pythonu více než dostatečná. Co ušetříte na času psaní kódu mnohonásobně převýší ztrátu rychlosti běhu."
  },
  {
    "objectID": "lessons/lesson_03.html#proč-python-pro-gis",
    "href": "lessons/lesson_03.html#proč-python-pro-gis",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "2.3 Proč Python pro GIS?",
    "text": "2.3 Proč Python pro GIS?\n\nJednoduchý - zvládne ho úplný začátečník bez zkušeností s programováním\nVýkonný - objektově orientovaný jazyk pro krátké skripty i rozsáhlé programy\nMultiplatformní - funguje stejně ve Windows, Linuxu i macOS\nPopulární - rozsáhlá dokumentace, výukové materiály, fóra, obrovské množství knihoven\nOpen source a zdarma\nBohaté GIS knihovny - vektorové a rastrové analýzy, tvorba map, publikace na webu\nVýlučný skriptovací jazyk v ArcGIS Pro pro automatizaci GIS operací"
  },
  {
    "objectID": "lessons/lesson_03.html#způsob-1-interaktivní-režim",
    "href": "lessons/lesson_03.html#způsob-1-interaktivní-režim",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "3.1 Způsob 1: Interaktivní režim",
    "text": "3.1 Způsob 1: Interaktivní režim\n\nOtevřete Command Prompt (Windows) nebo Terminal (Mac/Linux)\nNapište python a stiskněte Enter\nUvidíte něco jako:\n\nPython 3.9.11 (...)\n&gt;&gt;&gt; \n\nNapište:\n\n&gt;&gt;&gt; print(\"Hello World\")\n\nStiskněte Enter\n\nVýsledek:\nHello World\n\n\n\n\n\n\nTipInteraktivní režim\n\n\n\nTento režim je skvělý pro rychlé testování kódu. Každý příkaz se provede okamžitě po stisku Enter. Pro ukončení napište exit() nebo stiskněte Ctrl+Z (Windows) / Ctrl+D (Mac/Linux)."
  },
  {
    "objectID": "lessons/lesson_03.html#způsob-2-python-skript",
    "href": "lessons/lesson_03.html#způsob-2-python-skript",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "3.2 Způsob 2: Python skript",
    "text": "3.2 Způsob 2: Python skript\n\nOtevřete textový editor (Notepad, VS Code, Notepad++)\nNapište:\n\nprint(\"Hello World\")\n\nUložte jako hello.py (důležité je přípona .py)\nV příkazové řádce (v adresáři se souborem) spusťte:\n\npython hello.py\nVýsledek:\nHello World\n\n\n\n\n\n\nTipPython skripty\n\n\n\nSoubory s příponou .py jsou Python skripty. Výhoda oproti interaktivnímu režimu:\n\nKód můžete uložit a znovu použít\nMůžete psát delší programy\nSnadno se sdílí s kolegy\n\n\n\n\n\n\n\n\n\nNoteJupyter Notebook v ArcGIS Pro\n\n\n\nPozději v kurzu budeme používat Jupyter Notebook, který je integrovaný v ArcGIS Pro. Otevřete ho přes: Insert → New Notebook\nVýhoda: Kombinuje kód, výsledky a text v jednom dokumentu. Ideální pro analýzy a experimenty s ArcPy.\n\n\n\n\n\n\n\n\nTipVirtuální prostředí (pro pokročilé)\n\n\n\nArcGIS Pro má vlastní conda prostředí s nainstalovaným Pythonem a ArcPy. Zatím se o to nemusíte starat - vše je připravené. Pokud budete později pracovat s Pythonem mimo ArcGIS, vrátíme se k tématu virtuálních prostředí.\n\n\n\n\n\n\n\n\nImportantFunkce print()\n\n\n\nprint() je základní funkce pro výpis textu na obrazovku. Používá se pro:\n\nZobrazení výsledků\nLadění programu (debugging)\nKomunikaci s uživatelem"
  },
  {
    "objectID": "lessons/lesson_03.html#co-je-proměnná",
    "href": "lessons/lesson_03.html#co-je-proměnná",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "4.1 Co je proměnná?",
    "text": "4.1 Co je proměnná?\nProměnná je pojmenované místo v paměti, kde ukládáme data.\njmeno = \"Jan\"\nvek = 25\n\njmeno je proměnná, která obsahuje text \"Jan\"\nvek je proměnná, která obsahuje číslo 25"
  },
  {
    "objectID": "lessons/lesson_03.html#základní-datové-typy",
    "href": "lessons/lesson_03.html#základní-datové-typy",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "4.2 Základní datové typy",
    "text": "4.2 Základní datové typy\n\n4.2.1 Celá čísla (int)\nvek = 25\npocet_bodu = 150\n\n\n4.2.2 Desetinná čísla (float)\nprumerna_teplota = 15.7\nnadmorska_vyska = 234.5\n\n\n4.2.3 Text (string nebo str)\njmeno = \"Jan Novák\"\nmesto = 'Praha'  # Fungují jednoduché i dvojité uvozovky\n\n\n4.2.4 Logické hodnoty (bool)\nje_student = True\nje_zamestnanec = False\n\n\n\n\n\n\nWarningPozor na velká písmena!\n\n\n\nV Pythonu záleží na velikosti písmen:\n\nTrue a False - správně (s velkým písmenem)\ntrue a false - CHYBA!"
  },
  {
    "objectID": "lessons/lesson_03.html#pojmenování-proměnných",
    "href": "lessons/lesson_03.html#pojmenování-proměnných",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "4.3 Pojmenování proměnných",
    "text": "4.3 Pojmenování proměnných\nPravidla:\n\nZačíná písmenem nebo podtržítkem: jmeno, _temp\nMůže obsahovat písmena, čísla, podtržítka: vek_2, pocet_bodu\nNesmí obsahovat mezery: moje jmeno ❌\nNesmí začínat číslem: 2vek ❌\nJe case-sensitive: Jmeno ≠ jmeno\n\nKonvence (doporučení):\n\nPoužívejte malá písmena s podtržítky: pocet_obyvatel\nVýstižné názvy: teplota je lepší než t"
  },
  {
    "objectID": "lessons/lesson_03.html#základní-operace",
    "href": "lessons/lesson_03.html#základní-operace",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "5.1 Základní operace",
    "text": "5.1 Základní operace\n# Sčítání\n5 + 3  # 8\n\n# Odčítání\n10 - 4  # 6\n\n# Násobení\n3 * 4  # 12\n\n# Dělení (výsledek je vždy float!)\n10 / 3  # 3.3333...\n\n# Celočíselné dělení\n10 // 3  # 3\n\n# Zbytek po dělení (modulo)\n10 % 3  # 1\n\n# Mocnina\n2 ** 3  # 8 (2 na třetí)"
  },
  {
    "objectID": "lessons/lesson_03.html#příklady-s-proměnnými",
    "href": "lessons/lesson_03.html#příklady-s-proměnnými",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "5.2 Příklady s proměnnými",
    "text": "5.2 Příklady s proměnnými\nvyska = 180  # cm\nhmotnost = 75  # kg\n\n# BMI = hmotnost / (vyska v metrech)^2\nvyska_m = vyska / 100\nbmi = hmotnost / (vyska_m ** 2)\n\nprint(bmi)  # 23.148..."
  },
  {
    "objectID": "lessons/lesson_03.html#spojování-stringů",
    "href": "lessons/lesson_03.html#spojování-stringů",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "6.1 Spojování stringů",
    "text": "6.1 Spojování stringů\njmeno = \"Jan\"\nprijmeni = \"Novák\"\n\n# Spojení (concatenation)\ncele_jmeno = jmeno + \" \" + prijmeni\nprint(cele_jmeno)  # Jan Novák"
  },
  {
    "objectID": "lessons/lesson_03.html#f-stringy-doporučený-způsob",
    "href": "lessons/lesson_03.html#f-stringy-doporučený-způsob",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "6.2 f-stringy (doporučený způsob!)",
    "text": "6.2 f-stringy (doporučený způsob!)\nf-stringy jsou nejmodernější a nejčitelnější způsob práce s textem:\njmeno = \"Jan\"\nvek = 25\n\n# Starý způsob (concatenation)\nzprava = \"Jmenuji se \" + jmeno + \" a je mi \" + str(vek) + \" let.\"\n\n# f-string (moderní způsob)\nzprava = f\"Jmenuji se {jmeno} a je mi {vek} let.\"\n\nprint(zprava)\n# Výsledek: Jmenuji se Jan a je mi 25 let.\n\n\n\n\n\n\nTipProč f-stringy?\n\n\n\n\nČitelnější kód\nAutomatická konverze typů\nMůžete vkládat výrazy: f\"BMI: {hmotnost / (vyska ** 2)}\""
  },
  {
    "objectID": "lessons/lesson_03.html#převod-mezi-typy",
    "href": "lessons/lesson_03.html#převod-mezi-typy",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "6.3 Převod mezi typy",
    "text": "6.3 Převod mezi typy\nvek = 25\nvek_text = str(vek)  # \"25\"\n\ncislo_text = \"100\"\ncislo = int(cislo_text)  # 100\n\ndesetinne_cislo_text = \"3.14\"\ndesetinne_cislo = float(desetinne_cislo_text)  # 3.14"
  },
  {
    "objectID": "lessons/lesson_03.html#funkce-input",
    "href": "lessons/lesson_03.html#funkce-input",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "7.1 Funkce input()",
    "text": "7.1 Funkce input()\ninput() slouží k načtení vstupu od uživatele:\njmeno = input(\"Jak se jmenujete? \")\nprint(f\"Zdravím vás, {jmeno}!\")\nPrůběh:\nJak se jmenujete? Jan\nZdravím vás, Jan!\n\n\n\n\n\n\nWarningPozor! input() vrací vždy STRING!\n\n\n\nI když uživatel zadá číslo, input() vrací text:\nvek = input(\"Kolik je vám let? \")  # vek je STRING!\n# Musíme převést:\nvek = int(input(\"Kolik je vám let? \"))  # Teď je to INT"
  },
  {
    "objectID": "lessons/lesson_03.html#praktický-příklad",
    "href": "lessons/lesson_03.html#praktický-příklad",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "7.2 Praktický příklad",
    "text": "7.2 Praktický příklad\n# Kalkulačka BMI\njmeno = input(\"Vaše jméno: \")\nvyska = float(input(\"Výška v cm: \"))\nhmotnost = float(input(\"Hmotnost v kg: \"))\n\nvyska_m = vyska / 100\nbmi = hmotnost / (vyska_m ** 2)\n\nprint(f\"{jmeno}, vaše BMI je: {bmi:.2f}\")\nPříklad běhu:\nVaše jméno: Jan\nVýška v cm: 180\nHmotnost v kg: 75\nJan, vaše BMI je: 23.15"
  },
  {
    "objectID": "lessons/lesson_03.html#co-je-seznam",
    "href": "lessons/lesson_03.html#co-je-seznam",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "8.1 Co je seznam?",
    "text": "8.1 Co je seznam?\nSeznam je uspořádaná kolekce prvků. Může obsahovat čísla, text, nebo cokoliv jiného:\nteploty = [15, 18, 22, 19, 16]\nmesta = [\"Praha\", \"Brno\", \"Ostrava\"]\nsmiseny = [1, \"text\", 3.14, True]  # Může být i mix!"
  },
  {
    "objectID": "lessons/lesson_03.html#vytvoření-seznamu",
    "href": "lessons/lesson_03.html#vytvoření-seznamu",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "8.2 Vytvoření seznamu",
    "text": "8.2 Vytvoření seznamu\nprazdny_seznam = []\ncisla = [1, 2, 3, 4, 5]\njmena = [\"Anna\", \"Petr\", \"Jana\"]"
  },
  {
    "objectID": "lessons/lesson_03.html#indexování",
    "href": "lessons/lesson_03.html#indexování",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "8.3 Indexování",
    "text": "8.3 Indexování\nDŮLEŽITÉ: Python indexuje od 0!\nmesta = [\"Praha\", \"Brno\", \"Ostrava\", \"Plzeň\"]\n\nprint(mesta[0])   # Praha (první prvek!)\nprint(mesta[1])   # Brno (druhý prvek)\nprint(mesta[3])   # Plzeň (čtvrtý prvek)\nprint(mesta[-1])  # Plzeň (poslední prvek)\nprint(mesta[-2])  # Ostrava (předposlední)\n\n\n\n\n\n\nWarningPozor na indexování od 0!\n\n\n\nToto je častá chyba začátečníků:\ncisla = [10, 20, 30, 40, 50]\nprint(cisla[1])  # 20, NE 10!\nprint(cisla[5])  # CHYBA! Index mimo rozsah"
  },
  {
    "objectID": "lessons/lesson_03.html#délka-seznamu",
    "href": "lessons/lesson_03.html#délka-seznamu",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "8.4 Délka seznamu",
    "text": "8.4 Délka seznamu\nmesta = [\"Praha\", \"Brno\", \"Ostrava\"]\npocet = len(mesta)  # 3"
  },
  {
    "objectID": "lessons/lesson_03.html#přidávání-prvků",
    "href": "lessons/lesson_03.html#přidávání-prvků",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "8.5 Přidávání prvků",
    "text": "8.5 Přidávání prvků\ncisla = [1, 2, 3]\ncisla.append(4)  # Přidá 4 na konec\nprint(cisla)  # [1, 2, 3, 4]\n\ncisla.append(5)\nprint(cisla)  # [1, 2, 3, 4, 5]"
  },
  {
    "objectID": "lessons/lesson_03.html#praktický-příklad-1",
    "href": "lessons/lesson_03.html#praktický-příklad-1",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "8.6 Praktický příklad",
    "text": "8.6 Praktický příklad\n# Program pro sběr teplot\nteploty = []\n\nteploty.append(float(input(\"Teplota v pondělí: \")))\nteploty.append(float(input(\"Teplota v úterý: \")))\nteploty.append(float(input(\"Teplota ve středu: \")))\n\nprint(f\"Naměřené teploty: {teploty}\")\nprint(f\"První den: {teploty[0]}°C\")\nprint(f\"Poslední den: {teploty[-1]}°C\")"
  },
  {
    "objectID": "lessons/lesson_03.html#cvičení-1-kalkulačka-vzdálenosti",
    "href": "lessons/lesson_03.html#cvičení-1-kalkulačka-vzdálenosti",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "9.1 Cvičení 1: Kalkulačka vzdálenosti",
    "text": "9.1 Cvičení 1: Kalkulačka vzdálenosti\nNapište program, který:\n\nZeptá se uživatele na souřadnice dvou bodů (X1, Y1, X2, Y2)\nVypočítá vzdálenost mezi nimi pomocí Pythagorovy věty: \\(d = \\sqrt{(X_2-X_1)^2 + (Y_2-Y_1)^2}\\)\nVypíše výsledek\n\nNápověda:\n# Odmocninu získáte pomocí mocniny 0.5:\nodmocnina = cislo ** 0.5"
  },
  {
    "objectID": "lessons/lesson_03.html#cvičení-2-průměrná-teplota",
    "href": "lessons/lesson_03.html#cvičení-2-průměrná-teplota",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "9.2 Cvičení 2: Průměrná teplota",
    "text": "9.2 Cvičení 2: Průměrná teplota\nNapište program, který:\n\nVytvoří prázdný seznam\nZeptá se uživatele na teploty pro 5 dní (použijte append())\nVypočítá průměrnou teplotu: prumer = sum(seznam) / len(seznam)\nVypíše výsledek ve formátu: “Průměrná teplota byla: XX.X°C”"
  },
  {
    "objectID": "lessons/lesson_03.html#cvičení-3-seznam-měst",
    "href": "lessons/lesson_03.html#cvičení-3-seznam-měst",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "9.3 Cvičení 3: Seznam měst",
    "text": "9.3 Cvičení 3: Seznam měst\nNapište program, který:\n\nVytvoří seznam 3 českých měst\nVypíše první město\nVypíše poslední město\nPřidá 2 další města pomocí append()\nVypíše celý seznam\nVypíše počet měst v seznamu"
  },
  {
    "objectID": "lessons/lesson_03.html#co-jsme-se-naučili",
    "href": "lessons/lesson_03.html#co-jsme-se-naučili",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "10.1 Co jsme se naučili",
    "text": "10.1 Co jsme se naučili\n✅ Python je interpretovaný jazyk vhodný pro GIS\n✅ print() pro výpis, input() pro načtení vstupu\n✅ Základní datové typy: int, float, str, bool\n✅ Proměnné ukládají data\n✅ f-stringy pro práci s textem\n✅ Seznamy (list) - indexování od 0!\n✅ append() pro přidávání prvků\n✅ len() pro zjištění délky"
  },
  {
    "objectID": "lessons/lesson_03.html#co-bude-příště",
    "href": "lessons/lesson_03.html#co-bude-příště",
    "title": "Lekce 3: Úvod do Pythonu I – První program",
    "section": "10.2 Co bude příště?",
    "text": "10.2 Co bude příště?\nV další lekci se naučíme:\n\nPodmínky (if, elif, else)\nCykly (for, while)\nSložitější práce se seznamy (slicing, metody)"
  },
  {
    "objectID": "material/old_materials/04_part2.html",
    "href": "material/old_materials/04_part2.html",
    "title": "Programování pro GIS a DPZ",
    "section": "",
    "text": "Na rozdíl od textových řetězců, u seznamů lze pomocí indexů měnit jednotlivé položky:\n&gt;&gt;&gt; seznam1[2] = \"nova hodnota\"\n&gt;&gt;&gt; seznam1\n[2, -4, 'nova hodnota', 105, 0]\nŘez seznamu je seznam sestávající pouze z některých prvků původního seznamu. Vytváří se pomocí hranatých závorek, dvou indexů (začátku a konce řezu) a dvojtečky mezi nimi:\n&gt;&gt;&gt; seznam2[1:4]\n['STROM', '', 'guru']\nJak vyplývá z ukázky, prvek na pozici druhého indexu již do řezu nepatří. V řezu lze používat i záporné indexy, takže např. řez\n&gt;&gt;&gt; seznam2[0:-1]\n['ahoj', 'STROM', '']\nobsahuje všechny prvky od prvního do předposledního.\nPokud necháme některý z indexů prázdný, je příslušný řez proveden od začátku resp. do konce seznamu:\n# toto je rez od zacatku seznamu do tretiho prvku:\n&gt;&gt;&gt; seznam2[:3]\n['ahoj', 'STROM', '']\n\n# toto je rez od druheho prvku do konce seznamu:\n&gt;&gt;&gt; seznam2[1:]\n['STROM', '', 'guru']\n\n# toto je tzv. uplny rez:\n&gt;&gt;&gt; seznam2[:]\n['ahoj', 'STROM', '', 'guru']\nDalší možností, jak vytvářet řezy, je použití třetího „indexu“, lépe řečeno hodnoty, která určuje délku kroku při výběru prvků do řezu. Tímto způsobem lze např. vytvořit řez obsahující každé druhé (či třetí) číslo z určitého rozmezí:\n&gt;&gt;&gt; a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\n&gt;&gt;&gt; a[2:10:2]\n[3, 5, 7, 9]\n&gt;&gt;&gt; a[1:13:2]\n[2, 4, 6, 8, 10, 12]\n&gt;&gt;&gt; a[::3]\n[1, 4, 7, 10, 13, 16]\nPodobně jako u textových řetězců, seznamy lze sčítat a násobit přirozeným číslem (včetně nuly):\n&gt;&gt;&gt; seznam1 + seznam2\n[2, -4, 'nova hodnota', 105, 0, 'ahoj', 'STROM', '', 'guru']\n&gt;&gt;&gt; seznam1 * 2\n[2, -4, 'nova hodnota', 105, 0, 2, -4, 'nova hodnota', 105, 0]\n&gt;&gt;&gt; 0 * seznam2\n[]\nVýsledkem násobení seznamu nulou (a stejně tak i libovolným záporným celým číslem) je prázdný seznam.\nStejně jako lze pomocí indexů přepisovat jednotlivé položky seznamu, lze také přepisovat celé řezy, a to opět libovolným (tj. libovolně dlouhým) seznamem:\n&gt;&gt;&gt; a = [1,2,3,4,5]\n&gt;&gt;&gt; a[:3] = [\"jedna\",\"dva\",\"tri\",\"tri a pul\"]\n&gt;&gt;&gt; a\n['jedna', 'dva', 'tri', 'tri a pul', 4, 5]\nTímto způsobem lze také přidávat libovolné položky na konec seznamu (všimněte si, že v takovém případě lze použít index, který již je mimo rozsah původního seznamu):\n&gt;&gt;&gt; a[6:] = [6]\n&gt;&gt;&gt; a\n['jedna', 'dva', 'tri', 'tri a pul', 4, 5, 6]\nnebo na začátek seznamu:\n&gt;&gt;&gt; a[:0] = [-1,0]\n&gt;&gt;&gt; a\n[-1.0, 'jedna', 'dva', 'tri', 'tri a pul', 4, 5, 6]\npřípadně kamkoli doprostřed seznamu:\n&gt;&gt;&gt; a[3:3] = [1.5]\n&gt;&gt;&gt; a\n[-1, 0, 'jedna', 1.5, 'dva', 'tri', 'tri a pul', 4, 5, 6]\nStejně lze i vymazat část seznamu vložením prázdného seznamu:\n&gt;&gt;&gt; a[4:7] = []\n&gt;&gt;&gt; a\n[-1, 0, 'jedna', 1.5, 4, 5, 6]\nV kapitole “Proměnné” jsme si vysvětlili, že proměnná je odkazem na objekt v operační paměti. Proměnná a = [1,2,3] je tedy odkazem na příslušný objekt-seznam. To ale znamená, že pokud vytvořím proměnnou b = a, bude tato nová proměnná odkazovat na stejný objekt. Pokud nyní nyní tento objekt prostřednictvím jedné z proměnných změním, změna se pochopitelně dotkne i druhé proměnné:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; a[0] = -50\n&gt;&gt;&gt; a\n[-50, 2, 3]\n&gt;&gt;&gt; b\n[-50, 2, 3]\nPokud chceme vytvořit nezávislou kopii daného seznamu, můžeme použít úplný řez:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = a[:]\n&gt;&gt;&gt; a[0] = -50\n&gt;&gt;&gt; a\n[-50, 2, 3]\n&gt;&gt;&gt; b\n[1, 2, 3]\nVedle výše uvedených možností, jak pracovat se seznamy pomocí matematických operátorů a řezů, existují v Pythonu ještě tzv. metody seznamů, což jsou funkce, které se volají pomocí jména seznamu, tečky a jména dané funkce:\n&gt;&gt;&gt; x = [1,2,3]\n\n# Přidání nového prvku na konec seznamu metodou append\n&gt;&gt;&gt; x.append(\"ahoj\")\n&gt;&gt;&gt; x\n[1, 2, 3, 'ahoj']\n\n# Vložení prvku na danou pozici seznamu metodou insert\n&gt;&gt;&gt; x.insert(1, 1.5) # Vloží hodnotu 1.5 na druhou pozici (tj. s indexem 1)\n&gt;&gt;&gt; x\n[1, 1.5, 2, 3, 'ahoj']\n\n# Seřazení seznamu čísel nebo textových řetězců metodou sort\n&gt;&gt;&gt; x = [2,9,-13,0,50]\n&gt;&gt;&gt; x.sort()\n&gt;&gt;&gt; x\n[-13, 0, 2, 9, 50]\n&gt;&gt;&gt; x = [\"ahoj\",\"rohlik\",\"kafe\",\"zapalovac\",\"sirky\",\"snidane\"]\n&gt;&gt;&gt; x.sort()\n&gt;&gt;&gt; x\n['ahoj', 'kafe', 'rohlik', 'sirky', 'snidane', 'zapalovac']\n\n# Zjištění indexu dané hodnoty metodou index\n&gt;&gt;&gt; x.index(\"sirky\")\n4\n\n# Zjištění, kolikrát se daná hodnota v seznamu vyskytuje, metodou count\n&gt;&gt;&gt; x.count(\"sirky\")\n1\n\n# Vymazání prvního výskytu dané hodnoty metodou remove\n&gt;&gt;&gt; x.remove(\"sirky\")\n&gt;&gt;&gt; x\n['ahoj', 'rohlik', 'kafe', 'zapalovac', 'snidane']\n\n# Převrácení pořadí hodnot v seznamu metodou reverse\n&gt;&gt;&gt; x.reverse()\n&gt;&gt;&gt; x\n['snidane', 'zapalovac', 'kafe', 'rohlik', 'ahoj']\nVedle metod seznamů jsou v Pythonu k dispozici další vestavěné funkce, pomocí nichž lze se seznamy pracovat (tyto funkce lze stejně dobře použít i pro řetězce):\n&gt;&gt;&gt; a = [1,2,3]\n\n# Zjištění délky seznamu funkcí len\n&gt;&gt;&gt; len(a)\n3\n\n# Zjištění nejmenšího a největšího prvku seznamu funkcí min a max\n&gt;&gt;&gt; min(a)\n1\n&gt;&gt;&gt; max(a)\n3\n\n# Umazání části seznamu funkcí del\n&gt;&gt;&gt; a = [1,2,3,4,5]\n&gt;&gt;&gt; del(a[2])\n&gt;&gt;&gt; a\n[1, 2, 4, 5]\n&gt;&gt;&gt; del a[:2]\n&gt;&gt;&gt; a\n[4, 5]\nDo pythonovského seznamu lze vkládat i jiné seznamy (tzv. vnořené seznamy) a vytvořit tak seznam seznamů, příp. seznam seznamů seznamů atd.:\n&gt;&gt;&gt; a = [1, \"ahoj\", [1,2,3], [\"a\",\"b\"]]\n&gt;&gt;&gt; a[2]\n[1, 2, 3]\n&gt;&gt;&gt; a[3]\n['a', 'b']\n&gt;&gt;&gt; a[3][0]\n'a'\nHloubka vnoření může být značná (prakticky neomezená):\n&gt;&gt;&gt; a = [[[[[1]]]]]\n&gt;&gt;&gt; a[0]\n[[[[1]]]]\n&gt;&gt;&gt; a[0][0]\n[[[1]]]\n&gt;&gt;&gt; a[0][0][0]\n[[1]]\n&gt;&gt;&gt; a[0][0][0][0]\n[1]\n&gt;&gt;&gt; a[0][0][0][0][0]\n1"
  },
  {
    "objectID": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html",
    "href": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html",
    "title": "Lekce 3: Jak napsat a spustit program v Pythonu?",
    "section": "",
    "text": "Jazyk Python vyvinul nizozemský vývojář Guido van Rossum koncem 80. let 20. století, první verze spatřila světlo světa v roce 1991. Motivací přitom bylo vyvinout opravdu jednoduchý, efektivní, ale také zábavný jazyk. Poslední aspekt se odráží i v samotném jméně jazyka (česky “krajta”), které je reminiscencí na známou britskou komickou skupinu Monty Python.\nDůvodů, proč je Python tou správnou volbou pro pokročilou práci s geografickými informačními systémy, je hned několik:\n\nZa prvé, programovací jazyk Python je velmi jednoduchý a snadno ho zvládne i úplný začátečník bez jakýchkoli zkušeností s programováním.\nZa druhé, Python je výkonný a vyspělý objektově orientovaný jazyk, navržený pro psaní krátkých skriptů, ale snadno použitelný i pro tvorbu rozsáhlých programů.\nZa třetí, Python je nezávislý na operačním systému, tj. pracuje stejně dobře ve Windows jako v Linuxu a v jiných operačních systémech.\nZa čtvrté, Python je velmi populární, díky čemuž k němu existuje rozsáhlá dokumentace, výukové materiály, internetová fóra a především velké množství knihoven (nebo v pythonovské hantýrce „modulů“ a “balíčků”) pro řešení úloh z nejrůznějších oblastí.\nZa páté, Python je tzv. open source program, což mimo jiné znamená, že je zdarma.\nZa šesté, existuje velké množství volně přístupných pythonovských modulů pro práci s prostorovými daty, od vektorových a rastrových analýz až po tvorbu map a jejich publikaci na internetu. Díky tomu si lze pomocí Pythonu „sestavit“ vlastní GIS, a to zdarma (pro více informací viz knihu Erika Westry Python Geospatial Development).\nZa sedmé, Python je podporován jako jazyk pro psaní skriptů v programovém prostředí ArcGIS. Počínaje verzí ArcGIS Desktop 10 je dokonce výlučným skriptovacím jazykem (dřívější verze umožňovaly sice použití i jiných skriptovacích jazyků, nicméně veškerá dokumentace a příklady byly psány v Pythonu). Tato skutečnost je zvláště podstatná v rámci tohoto kurzu, neboť ten je zaměřen právě na ovládání nástrojů ArcGIS pomocí jazyka Python.\n\n\n\n\nV současné době existuje Python ve verzi 3.9. Program ArcGIS nicméně dlouhou dobu váhal s integrací Pythonu řady 3.x, neboť mezi řadou 2.x a 3.x byly provedeny v jazyku Python poměrně zásadní změny. Veškeré verze programu ArcGIS Desktop proto stále pracují s verzí Pythonu řady 2.x, u ArcGIS 10.x je to verze Python 2.7. Přechod na aktuální verzi Pythonu se v produktech Esri odehrál až s příchodem nového produktu ArcGIS Pro, který nahrazuje starší ArcGIS Desktop s jeho známou aplikací ArcMap. Jelikož v tomto kurzu budeme pracovat s programem ArcGIS Desktop, budeme vycházet z dnes již neaktuální verze Python 2.7. To by nemělo způsobovat větší problémy, neboť zejména pro začátečníka není v obou verzích jazyka zas takový rozdíl. Tam, kde rozdíl je, na to v patřičné chvíli upozorníme. Navíc není problém mít v počítači nainstalováno více verzí Pythonu, jen je pak třeba dát pozor, s jakou verzí člověk aktuálně pracuje.\nPokud máte v počítači nainstalovaný software ArcGIS, máte s největší pravděpodobností nainstalovanou i odpovídající verzi jazyka Python, neboť ta je distribuována a automaticky instalována s programem ArcGIS. To snadno zjistíte v seznamu aplikací systému Windows, kde je python buď v samostatné složce, nebo uvnitř složky ArcGIS. V případě, že sice ArcGIS nainstalovaný máte, přesto však nemůžete Python nalézt, je možné, že jste jeho instalaci při instalování programu ArcGIS (zřejmě nechtěně) odmítli. V takovém případě bude pravděpodobně nejsnažším řešením provést instalaci programu ArcGIS znovu. Jde o to, že při instalaci ArcGIS se neinstaluje jen samotný Python, ale i klíčová knihovna (balíček) ArcPy, která zprostředkovává funkcionalitu systému ArcGIS do jazyka Python.\nInstalaci samotného Pythonu lze samozřejmě provést i manuálně, např. chcete-li mít k dispozici i novější verze Pythonu. V takovém případě doporučujeme použít instalaci pomocí distribuční platformy Anaconda či Miniconda.\n\n\n\nProgramy napsané v Pythonu lze spouštět různým způsobem. Nejjednodušší podobou programu je prostý textový soubor s kódem programu, většinou uložený s koncovkou .py. Ten lze spustit:\n\nz příkazového řádku operačního systému, prostým vepsáním adresy souboru se zdrojovým kódem. V příkazovém řádku lze zároveň přímo spustit interaktivní překladač Pythonovského kódu, čímž příkazový řádek přejde do režimu Python a je možné v něm přímo psát a spouštět jednotlivé příkazy Pythonu.\nz příkazového řádku Pythonu, který je k dispozici po instalaci Pythonu jako samostatná aplikace. Je ideální pro psaní a spouštění jednotlivých příkazů.\nz interaktivního grafického rozhraní IDLE. Zde je možné na konzoli (příkazovém řádku) spouštět jednolitvé příkazy, zároveň však editovat a spouštět soubory se zdrojovým kódem. Tuto možnost budeme využívat v tomto kurzu. Program IDLE je rovněž standardní součástí základní instalace Pythonu.\nz některého pokročilejšího integrovaného vývojového prostředí (IDE, “Integrated Development Environment”). Jedná se o program, umožňující snadnou editaci zdrojového kódu a jeho interaktivní překlad, tedy “spouštění”. Zároveň různá prostředí nabízejí např. správu grafických výstupů, náhled obsahu proměnných a objektů, možnost tvorby komentovaného interaktivního kódu, integraci dalších programovacích jazyků apod. Za zmínku jistě stojí prostředí Jupyter Notebooks, umožňující kombinovat přímo spustitelné bloky kódu následované výstupem z daného výpočtu (např. grafem), s rozsáhlými komentáři v jazyce Markdown. Dále např. program Spyder, který se hodí pro datovou analýzu a v lecčems připomíná známé vývojové prostředí jazyka R RStudio.\n\nSpecifickou možností při použití Pythonu pro práci s programem ArcGIS je speciální příkazový řádek Pythonu přímo integrovaný do programu ArcMap, resp. ArcGIS Pro. Tuto možnost si v tomto kurzu rovněž vyzkoušíte. V dalším textu si představíme vývojové prostředí IDLE, které budeme používat napříč kurzem.\nProgram IDLE slouží k interaktivní interpretaci kódů napsaných v Pythonu. To znamená, že je možné v něm spouštět libovolné části kódů a příslušné příkazy jsou ihned vykonány. Existuje řada jiných interpretů či vývojových prostředí pro Python (viz výše), nicméně vzhledem k tomu, že IDLE je dodáváno spolu s Pythonem v rámci standardní instalace programu ArcGIS, omezíme se v tomto kurzu právě na ně. Je to výhodné i z toho důvodu, že práce v něm je velmi snadná. Na druhou stranu jistou nevýhodou tohoto prostředí jsou omezené možnosti ladění programů (tj. hledání chyb v kódech).\n\nIDLE vytvořil rovněž Guido van Rossum, a stejně jako samotný Python je zdarma a volně šiřitelný. Název je zkratkou pro integrované vývojové prostředí (anglicky Integrated DeveLopment Environment). Za zmínku stojí, že jelikož se běžně integrované vývojové prostředí označuje zkratkou IDE, přidané „l“ nejspíš odkazuje na jednoho z členů skupiny Monty Python, kterým je Eric Idle.\n\nProstředí IDLE lze spustit z programové nabídky systému Windows. Po spuštění programu IDLE se otevře interaktivní okno nazvané Python Shell.\n\n\n\nimage-20201004185152083\n\n\n\nÚkol 1. Popsaným způsobem otevřete program IDLE.\n\nOkno Python Shell slouží k vykonávání jednotlivých příkazů a ke spouštění skriptů. Symbol &gt;&gt;&gt; je tzv. výzva příkazového řádku, za kterou je možné psát příkaz. Po stisknutí klávesy Enter je příkaz poslán do překladače a výsledek se vypíše na další řádek:\n&gt;&gt;&gt; 1 + 2\n3\n&gt;&gt;&gt; \"Ahoj svete!\"\n'Ahoj svete!'\nJak je z uvedeného příkladu patrné, po zapsání jednoduchého (nebo i složitějšího) matematického výrazu je tento výraz vyhodnocen a vrácena hodnota výsledku. Tímto způsobem lze vlastně okno Python Shell používat jako jednoduchou kalkulačku:\n&gt;&gt;&gt; -(2 + 3)*5\n-25\nPro uchování nějaké hodnoty pro budoucí použití lze vytvořit tzv. proměnnou a hodnotu do ní uložit:\n&gt;&gt;&gt; x = 2\n&gt;&gt;&gt; moje_cislo = 3\n&gt;&gt;&gt; -(x + moje_cislo)*5\n-25\nDo proměnné lze přiřadit i jiný typ hodnoty než číslo, např. text:\n&gt;&gt;&gt; a = \"Ahoj svete!\"\n&gt;&gt;&gt; a\n'Ahoj svete!'\nOkno Python Shell nabízí řadu možností pro usnadnění psaní příkazů. Probereme zde jen některé, další možnosti lze nalézt v hlavním menu pod položkou Edit: - Historie příkazů. Po stisknutí klávesové zkratky Alt+P (z anglického „previous“) vyvoláme poslední spouštěný příkaz, při opakovaném stisknutí této zkratky procházíme historii příkazů dozadu. Obdobně stisknutím klávesové zkratky Alt+N (z anglického „next“) můžeme procházet v historii příkazů směrem dopředu. Jinou možností, jak znovu vyvolat předchozí příkaz, je umístit na něj kurzor a stisknout enter. Tím je daný příkaz automaticky vypsán na aktuální řádek a dalším stisknutím enter je spuštěn. - Ukončení překladu. Chceme-li přerušit aktuální vykonávání příkazu, stiskneme Ctrl+C. (Hodí se tehdy, trvá-li výpočet z nějakého důvodu příliš dlouho.) - Našeptávání. Po napsání libovolné posloupnosti znaků a stisknutí klávesové zkratky Ctrl+Space se otevře seznam všech dostupných funkcí, proměnných a slov jazyka začínajících danými písmeny. Z nich je možné vybírat pomocí šipek nahoru a dolu.\n\nÚkol 2. V okně Python Shell vytvořte několik proměnných a vyzkoušejte jednoduché aritmetické operace. Zkuste procházet historii příkazů.\n\n\n\n\nSkript je samostatný textový soubor s kódem, který je možné spustit najednou. Skript je možné psát v libovolném textovém editoru, je nicméně nutné jej uložit s koncovkou .py, aby překladač (např. Python Shell) rozeznal, že se jedná o kód v jazyce Python.\nV programu IDLE je možné psát skripty ve speciálně upraveném textovém editoru, který oproti běžným textovým editorům skýtá některé výhody - např. se kód vybarvuje tak, aby se v něm dalo lépe orientovat. Zároveň lze vytvořený skript ihned poslat do překladače a spustit.\n\nÚkol 3. Otevřete nový skript v programu IDLE pomocí File -&gt; New File, případně pomocí Ctrl+N. Do skriptu napište pod sebe postupně příkazy a = \"Ahoj\", b = \"Světe\" a print(a + \" \" + b). Skript uložte a pomocí klávesy F5, případně pomocí Run -&gt; Run Module jej spusťte.\n\nProgram IDLE lze spouštět i pomocí uloženého skriptu.\n\nÚkol 4. Zavřete program IDLE. V prohlížeči souborů vyhledejte vytvořený skript, klikněte na něj pravým tlačítkem myši a zvolte Edit with IDLE.\n\n\n\n\nPython je integrovaný do programu ArcMap několika způsoby. Jedním z nich je i interaktivní okno Python Window, jakási obdoba překladače Python Shell. V tomto okně můžeme volat (téměř) libovolné příkazy Pythonu, zároveň však (jak uvidíme později) umožňuje integrovat do příkazů vrstvy v dané chvíli nahrané v Table Of Contents. Zároveň se výstupní geodata z analýz, provedených v Python Window, automaticky vkládají jako vrstvy do Table Of Contents.\n\nÚkol 5. V programu ArcMap otevřete Python Window a vyzkoušejte si spustit jednoduché příkazy, které jste spouštěli v okně Python Shell.\n\n\n\n\nV této lekci jste se seznámili s prostředím programu IDLE, zkusili si napsat a spustit jednoduché příkazy v okně Python Shell a napsat a spustit jednoduchý skript. Zároveň jste se seznámili s oknem Python Window v programu ArcMap."
  },
  {
    "objectID": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#proč-python",
    "href": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#proč-python",
    "title": "Lekce 3: Jak napsat a spustit program v Pythonu?",
    "section": "",
    "text": "Jazyk Python vyvinul nizozemský vývojář Guido van Rossum koncem 80. let 20. století, první verze spatřila světlo světa v roce 1991. Motivací přitom bylo vyvinout opravdu jednoduchý, efektivní, ale také zábavný jazyk. Poslední aspekt se odráží i v samotném jméně jazyka (česky “krajta”), které je reminiscencí na známou britskou komickou skupinu Monty Python.\nDůvodů, proč je Python tou správnou volbou pro pokročilou práci s geografickými informačními systémy, je hned několik:\n\nZa prvé, programovací jazyk Python je velmi jednoduchý a snadno ho zvládne i úplný začátečník bez jakýchkoli zkušeností s programováním.\nZa druhé, Python je výkonný a vyspělý objektově orientovaný jazyk, navržený pro psaní krátkých skriptů, ale snadno použitelný i pro tvorbu rozsáhlých programů.\nZa třetí, Python je nezávislý na operačním systému, tj. pracuje stejně dobře ve Windows jako v Linuxu a v jiných operačních systémech.\nZa čtvrté, Python je velmi populární, díky čemuž k němu existuje rozsáhlá dokumentace, výukové materiály, internetová fóra a především velké množství knihoven (nebo v pythonovské hantýrce „modulů“ a “balíčků”) pro řešení úloh z nejrůznějších oblastí.\nZa páté, Python je tzv. open source program, což mimo jiné znamená, že je zdarma.\nZa šesté, existuje velké množství volně přístupných pythonovských modulů pro práci s prostorovými daty, od vektorových a rastrových analýz až po tvorbu map a jejich publikaci na internetu. Díky tomu si lze pomocí Pythonu „sestavit“ vlastní GIS, a to zdarma (pro více informací viz knihu Erika Westry Python Geospatial Development).\nZa sedmé, Python je podporován jako jazyk pro psaní skriptů v programovém prostředí ArcGIS. Počínaje verzí ArcGIS Desktop 10 je dokonce výlučným skriptovacím jazykem (dřívější verze umožňovaly sice použití i jiných skriptovacích jazyků, nicméně veškerá dokumentace a příklady byly psány v Pythonu). Tato skutečnost je zvláště podstatná v rámci tohoto kurzu, neboť ten je zaměřen právě na ovládání nástrojů ArcGIS pomocí jazyka Python."
  },
  {
    "objectID": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#instalace-a-verze-pythonu",
    "href": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#instalace-a-verze-pythonu",
    "title": "Lekce 3: Jak napsat a spustit program v Pythonu?",
    "section": "",
    "text": "V současné době existuje Python ve verzi 3.9. Program ArcGIS nicméně dlouhou dobu váhal s integrací Pythonu řady 3.x, neboť mezi řadou 2.x a 3.x byly provedeny v jazyku Python poměrně zásadní změny. Veškeré verze programu ArcGIS Desktop proto stále pracují s verzí Pythonu řady 2.x, u ArcGIS 10.x je to verze Python 2.7. Přechod na aktuální verzi Pythonu se v produktech Esri odehrál až s příchodem nového produktu ArcGIS Pro, který nahrazuje starší ArcGIS Desktop s jeho známou aplikací ArcMap. Jelikož v tomto kurzu budeme pracovat s programem ArcGIS Desktop, budeme vycházet z dnes již neaktuální verze Python 2.7. To by nemělo způsobovat větší problémy, neboť zejména pro začátečníka není v obou verzích jazyka zas takový rozdíl. Tam, kde rozdíl je, na to v patřičné chvíli upozorníme. Navíc není problém mít v počítači nainstalováno více verzí Pythonu, jen je pak třeba dát pozor, s jakou verzí člověk aktuálně pracuje.\nPokud máte v počítači nainstalovaný software ArcGIS, máte s největší pravděpodobností nainstalovanou i odpovídající verzi jazyka Python, neboť ta je distribuována a automaticky instalována s programem ArcGIS. To snadno zjistíte v seznamu aplikací systému Windows, kde je python buď v samostatné složce, nebo uvnitř složky ArcGIS. V případě, že sice ArcGIS nainstalovaný máte, přesto však nemůžete Python nalézt, je možné, že jste jeho instalaci při instalování programu ArcGIS (zřejmě nechtěně) odmítli. V takovém případě bude pravděpodobně nejsnažším řešením provést instalaci programu ArcGIS znovu. Jde o to, že při instalaci ArcGIS se neinstaluje jen samotný Python, ale i klíčová knihovna (balíček) ArcPy, která zprostředkovává funkcionalitu systému ArcGIS do jazyka Python.\nInstalaci samotného Pythonu lze samozřejmě provést i manuálně, např. chcete-li mít k dispozici i novější verze Pythonu. V takovém případě doporučujeme použít instalaci pomocí distribuční platformy Anaconda či Miniconda."
  },
  {
    "objectID": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#prostředí-idle-a-python-shell",
    "href": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#prostředí-idle-a-python-shell",
    "title": "Lekce 3: Jak napsat a spustit program v Pythonu?",
    "section": "",
    "text": "Programy napsané v Pythonu lze spouštět různým způsobem. Nejjednodušší podobou programu je prostý textový soubor s kódem programu, většinou uložený s koncovkou .py. Ten lze spustit:\n\nz příkazového řádku operačního systému, prostým vepsáním adresy souboru se zdrojovým kódem. V příkazovém řádku lze zároveň přímo spustit interaktivní překladač Pythonovského kódu, čímž příkazový řádek přejde do režimu Python a je možné v něm přímo psát a spouštět jednotlivé příkazy Pythonu.\nz příkazového řádku Pythonu, který je k dispozici po instalaci Pythonu jako samostatná aplikace. Je ideální pro psaní a spouštění jednotlivých příkazů.\nz interaktivního grafického rozhraní IDLE. Zde je možné na konzoli (příkazovém řádku) spouštět jednolitvé příkazy, zároveň však editovat a spouštět soubory se zdrojovým kódem. Tuto možnost budeme využívat v tomto kurzu. Program IDLE je rovněž standardní součástí základní instalace Pythonu.\nz některého pokročilejšího integrovaného vývojového prostředí (IDE, “Integrated Development Environment”). Jedná se o program, umožňující snadnou editaci zdrojového kódu a jeho interaktivní překlad, tedy “spouštění”. Zároveň různá prostředí nabízejí např. správu grafických výstupů, náhled obsahu proměnných a objektů, možnost tvorby komentovaného interaktivního kódu, integraci dalších programovacích jazyků apod. Za zmínku jistě stojí prostředí Jupyter Notebooks, umožňující kombinovat přímo spustitelné bloky kódu následované výstupem z daného výpočtu (např. grafem), s rozsáhlými komentáři v jazyce Markdown. Dále např. program Spyder, který se hodí pro datovou analýzu a v lecčems připomíná známé vývojové prostředí jazyka R RStudio.\n\nSpecifickou možností při použití Pythonu pro práci s programem ArcGIS je speciální příkazový řádek Pythonu přímo integrovaný do programu ArcMap, resp. ArcGIS Pro. Tuto možnost si v tomto kurzu rovněž vyzkoušíte. V dalším textu si představíme vývojové prostředí IDLE, které budeme používat napříč kurzem.\nProgram IDLE slouží k interaktivní interpretaci kódů napsaných v Pythonu. To znamená, že je možné v něm spouštět libovolné části kódů a příslušné příkazy jsou ihned vykonány. Existuje řada jiných interpretů či vývojových prostředí pro Python (viz výše), nicméně vzhledem k tomu, že IDLE je dodáváno spolu s Pythonem v rámci standardní instalace programu ArcGIS, omezíme se v tomto kurzu právě na ně. Je to výhodné i z toho důvodu, že práce v něm je velmi snadná. Na druhou stranu jistou nevýhodou tohoto prostředí jsou omezené možnosti ladění programů (tj. hledání chyb v kódech).\n\nIDLE vytvořil rovněž Guido van Rossum, a stejně jako samotný Python je zdarma a volně šiřitelný. Název je zkratkou pro integrované vývojové prostředí (anglicky Integrated DeveLopment Environment). Za zmínku stojí, že jelikož se běžně integrované vývojové prostředí označuje zkratkou IDE, přidané „l“ nejspíš odkazuje na jednoho z členů skupiny Monty Python, kterým je Eric Idle.\n\nProstředí IDLE lze spustit z programové nabídky systému Windows. Po spuštění programu IDLE se otevře interaktivní okno nazvané Python Shell.\n\n\n\nimage-20201004185152083\n\n\n\nÚkol 1. Popsaným způsobem otevřete program IDLE.\n\nOkno Python Shell slouží k vykonávání jednotlivých příkazů a ke spouštění skriptů. Symbol &gt;&gt;&gt; je tzv. výzva příkazového řádku, za kterou je možné psát příkaz. Po stisknutí klávesy Enter je příkaz poslán do překladače a výsledek se vypíše na další řádek:\n&gt;&gt;&gt; 1 + 2\n3\n&gt;&gt;&gt; \"Ahoj svete!\"\n'Ahoj svete!'\nJak je z uvedeného příkladu patrné, po zapsání jednoduchého (nebo i složitějšího) matematického výrazu je tento výraz vyhodnocen a vrácena hodnota výsledku. Tímto způsobem lze vlastně okno Python Shell používat jako jednoduchou kalkulačku:\n&gt;&gt;&gt; -(2 + 3)*5\n-25\nPro uchování nějaké hodnoty pro budoucí použití lze vytvořit tzv. proměnnou a hodnotu do ní uložit:\n&gt;&gt;&gt; x = 2\n&gt;&gt;&gt; moje_cislo = 3\n&gt;&gt;&gt; -(x + moje_cislo)*5\n-25\nDo proměnné lze přiřadit i jiný typ hodnoty než číslo, např. text:\n&gt;&gt;&gt; a = \"Ahoj svete!\"\n&gt;&gt;&gt; a\n'Ahoj svete!'\nOkno Python Shell nabízí řadu možností pro usnadnění psaní příkazů. Probereme zde jen některé, další možnosti lze nalézt v hlavním menu pod položkou Edit: - Historie příkazů. Po stisknutí klávesové zkratky Alt+P (z anglického „previous“) vyvoláme poslední spouštěný příkaz, při opakovaném stisknutí této zkratky procházíme historii příkazů dozadu. Obdobně stisknutím klávesové zkratky Alt+N (z anglického „next“) můžeme procházet v historii příkazů směrem dopředu. Jinou možností, jak znovu vyvolat předchozí příkaz, je umístit na něj kurzor a stisknout enter. Tím je daný příkaz automaticky vypsán na aktuální řádek a dalším stisknutím enter je spuštěn. - Ukončení překladu. Chceme-li přerušit aktuální vykonávání příkazu, stiskneme Ctrl+C. (Hodí se tehdy, trvá-li výpočet z nějakého důvodu příliš dlouho.) - Našeptávání. Po napsání libovolné posloupnosti znaků a stisknutí klávesové zkratky Ctrl+Space se otevře seznam všech dostupných funkcí, proměnných a slov jazyka začínajících danými písmeny. Z nich je možné vybírat pomocí šipek nahoru a dolu.\n\nÚkol 2. V okně Python Shell vytvořte několik proměnných a vyzkoušejte jednoduché aritmetické operace. Zkuste procházet historii příkazů."
  },
  {
    "objectID": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#psaní-a-spouštění-skriptů",
    "href": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#psaní-a-spouštění-skriptů",
    "title": "Lekce 3: Jak napsat a spustit program v Pythonu?",
    "section": "",
    "text": "Skript je samostatný textový soubor s kódem, který je možné spustit najednou. Skript je možné psát v libovolném textovém editoru, je nicméně nutné jej uložit s koncovkou .py, aby překladač (např. Python Shell) rozeznal, že se jedná o kód v jazyce Python.\nV programu IDLE je možné psát skripty ve speciálně upraveném textovém editoru, který oproti běžným textovým editorům skýtá některé výhody - např. se kód vybarvuje tak, aby se v něm dalo lépe orientovat. Zároveň lze vytvořený skript ihned poslat do překladače a spustit.\n\nÚkol 3. Otevřete nový skript v programu IDLE pomocí File -&gt; New File, případně pomocí Ctrl+N. Do skriptu napište pod sebe postupně příkazy a = \"Ahoj\", b = \"Světe\" a print(a + \" \" + b). Skript uložte a pomocí klávesy F5, případně pomocí Run -&gt; Run Module jej spusťte.\n\nProgram IDLE lze spouštět i pomocí uloženého skriptu.\n\nÚkol 4. Zavřete program IDLE. V prohlížeči souborů vyhledejte vytvořený skript, klikněte na něj pravým tlačítkem myši a zvolte Edit with IDLE."
  },
  {
    "objectID": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#python-konzole-v-arcmap",
    "href": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#python-konzole-v-arcmap",
    "title": "Lekce 3: Jak napsat a spustit program v Pythonu?",
    "section": "",
    "text": "Python je integrovaný do programu ArcMap několika způsoby. Jedním z nich je i interaktivní okno Python Window, jakási obdoba překladače Python Shell. V tomto okně můžeme volat (téměř) libovolné příkazy Pythonu, zároveň však (jak uvidíme později) umožňuje integrovat do příkazů vrstvy v dané chvíli nahrané v Table Of Contents. Zároveň se výstupní geodata z analýz, provedených v Python Window, automaticky vkládají jako vrstvy do Table Of Contents.\n\nÚkol 5. V programu ArcMap otevřete Python Window a vyzkoušejte si spustit jednoduché příkazy, které jste spouštěli v okně Python Shell."
  },
  {
    "objectID": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#shrnutí",
    "href": "material/old_materials/Lekce 3 Jak a kde napsat a spustit program v Pythonu.html#shrnutí",
    "title": "Lekce 3: Jak napsat a spustit program v Pythonu?",
    "section": "",
    "text": "V této lekci jste se seznámili s prostředím programu IDLE, zkusili si napsat a spustit jednoduché příkazy v okně Python Shell a napsat a spustit jednoduchý skript. Zároveň jste se seznámili s oknem Python Window v programu ArcMap."
  },
  {
    "objectID": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html",
    "href": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html",
    "title": "Lekce 5: Řídící struktury programu - cykly a podmínky",
    "section": "",
    "text": "Řídícími strukturami programu (též struktury řízení chodu programu) se rozumí syntaktické struktury jazyka, umožňující podmíněné a opakované provádění posloupnosti příkazů.\n\n\nLogický výraz (jinak též pravdivostní výrok) je jakýkoli výrok, kterému lze jednoznačně přisoudit pravdivostní hodnotu, tj. určit, zda je pravdivý či nepravdivý. Přisouzení pravdivostní hodnoty danému výrazu se označuje jako jeho vyhodnocení. Logické výrazy se v programování používají všude tam, kde je třeba provézt nějaký příkaz (či sérii příkazů) pouze tehdy, je-li splněna nějaká podmínka (takovým příkazům se říká podmíněné příkazy). Podmínka pak má podobu logického výrazu, přičemž její splnění/nesplnění je dáno pravdivostní hodnotou tohoto výrazu.\nPorovnáním dvou hodnot lze vytvořit jednoduchý logický výraz, jehož pravdivostní hodnota je dána pravdivostí příslušného tvrzení:\n&gt;&gt;&gt; 3 &lt; 5\nTrue\n&gt;&gt;&gt; 3 &gt; 5\nFalse\nPorovnávat lze i textové řetězce. Porovnání je pak založeno na abecedním pořadí (tj. na tzv. lexikografickém uspořádání), přičemž velká písmena mají přednost před malými:\n&gt;&gt;&gt; \"ahoj\" &lt; \"svete\"\nTrue\n&gt;&gt;&gt; \"Ahoj\" &lt; \"AHOJ\"\nFalse\nRovnost se testuje operátorem == (pozor, nezaměňovat s operací =, která přiřazuje hodnotu proměnné!):\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; a == 5\nTrue\nNerovnost se testuje buď operátorem != nebo &lt;&gt;:\n&gt;&gt;&gt; a != 5\nFalse\n&gt;&gt;&gt; a &lt;&gt; 3\nTrue\nPoněkud složitější je porovnávací operátor is. U čísel a řetězců testuje rovnost stejně jako ==, ale u složitějších objektů, jako jsou seznamy, testuje totožnost objektů (tj. zda se jedná o tentýž objekt se shodnou adresou v paměti):\n&gt;&gt;&gt; a = 3\n&gt;&gt;&gt; b = 3\n&gt;&gt;&gt; a is b\nTrue\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = [1,2,3]\n&gt;&gt;&gt; a is b\nFalse\n&gt;&gt;&gt; a = b\n&gt;&gt;&gt; a is b\nTrue\nOpakem is je operátor is not.\nOperátor in testuje, zda je určitý prvek v daném seznamu, případně určitý znak v daném řetězci:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; 2 in a\nTrue\n&gt;&gt;&gt; \"a\" in \"ahoj\"\nTrue\nJeho opakem je not in:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; 4 not in a\nTrue\n&gt;&gt;&gt; \"z\" not in \"ahoj\"\nTrue\nSložené logické výroky lze z jednoduchých vytvářet pomocí tzv. logických operátorů and, or a not (mluvíme pak o tzv. logických operacích s logickými výrazy). Význam těchto operátorů je všeobecně známý z logiky, proto výklad omezíme jen na malou ukázku. Např. pokud chceme otestovat, zda je hodnota nějaké číselné proměnné obsažena v určitém seznamu a zároveň zda je větší než 3, lze to provést pomocí operátoru and:\n&gt;&gt;&gt; seznam = [1,2,3,4]\n&gt;&gt;&gt; a = 4\n&gt;&gt;&gt; a in seznam and a &gt; 3\nTrue\nStruktura složeného výrazu může být libovolně složitá, obsahující libovolné množství dílčích jednoduchých i složitých výrazů. Pokud jsou dílčí výrazy rovněž složené, je často nutné zajistit požadovaný význam výrazu použitím závorek:\n&gt;&gt;&gt; a in seznam and (a &gt; 3 or a &lt; -3)\nTrue\nUmístění závorek se řídí známou prioritou operací: nejprve se vždy vyhodnocuje not, pak and, posléze or. Pokud bychom v posledně uvedeném příkladu závorky vynechali, význam by se změnil (zodpovězte si: jak?).\n\nÚkol 1. Zadejte následující příkaz: s = [1, 4, -10, 6, 13, -2]. O následujících výrazech předem rozhodněte, zda jsou pravdivé či nepravdivé. Následně ověřte:\ns[1] &lt; s[3] or 3 in s and len(s) == s[3]\ns[1] &lt; s[3] or (3 in s and len(s) == s[3])\n(s[1] &lt; s[3] or 3 in s) and len(s) == s[3]\ns[1] &gt; s[3] and 3 not in s or len(s) == s[3]\ns[1] &gt; s[3] and (3 not in s or len(s) == s[3])\n(s[1] &gt; s[3] and 3 not in s) or len(s) == s[3]\ns[1] &gt; s[3] and not (3 not in s or len(s) == s[3])\nnot (s[1] &gt; s[3] and 3 not in s) or len(s) == s[3]\ns\n\n\n\n\nPříkaz se nazývá podmíněný, je-li jeho provedení vázáno splněním nějaké podmínky. Podmínkou přitom může být jakýkoli logický výraz, přičemž splnění podmínky je dáno jeho pravdivostní hodnotou. Syntaxe podmíněných příkazů v Pythonu je značně intuitivní, neboť kopíruje syntaxi běžného jazyka: pokud (anglicky if) platí podmínka, proveď následující příkaz(y):\nif podmínka: příkaz\nV případě více příkazů:\nif podmínka:\n    příkaz 1\n    příkaz 2\n    příkaz 3\n    ...\nVidíme zde blokovou strukturu kódu, založenou na povinném odsazování. Příkazy vázané na splnění podmínky jsou vůči řádku s klíčovým slovem if odsazené o jednu úroveň (= čtyři mezery) doprava. Jakýkoli příkaz odsazený na úroveň slova if již nebude s podmínkou nijak souviset, tj. provede se bez ohledu na její splnění či nesplnění.\nUveďme příklad:\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; b = 6\n&gt;&gt;&gt; if a &lt; 6: print a\n    \n5\n&gt;&gt;&gt; if b &lt; 6: print b\n    \n&gt;&gt;&gt; if a &lt; b:\n    print a\n    print b\n    print a,\"je mensi nez\",b\n\n5\n6\n5 je mensi nez 6\n\nPokud zapisujeme podmíněný příkaz do okna Python Shell, je po ukončení zápisu třeba stisknout klávesu Enter hned dvakrát. Druhým stisknutím klávesy Enter dáváme interpretu najevo, že jsme již skončili se zápisem a celý blok může být interpretován (tj. proveden). To je důvod, proč za posledním řádkem zápisu je vždy jeden prázdný řádek.\n\nVedle specifikace, co se má provézt za příkazy v případě splnění nějaké podmínky, lze také programu říct, co má provézt za příkazy, pokud naopak podmínka splněna není. Syntaxe je opět intuitivní: pokud (if) platí podmínka, proveď následující příkaz(y), jinak (anglicky else) proveď alternativní příkaz(y):\nif podmínka:\n    příkaz 1\n    příkaz 2\nelse:\n    příkaz 3\n    příkaz 4\nKonkrétní příklad tentokrát zapíšeme pomocí skriptu:\na = 5\nb = 6\nif a == b:\n    print(str(a) + \" se rovna \" + str(b))\nelse:\n    print(str(a) + \" se nerovna \" + str(b))\nPo spuštění skriptu se v okně Python Shell vypíše:\n5 se nerovna 6\nČasto také nastává případ, že potřebujeme postupně otestovat více různých podmínek, při jejichž splnění se vždy má provést odpovídající příkazy. Struktura zápisu je: pokud platí podmínka 1, proveď příkaz(y) 1, jinak pokud platí podmínka 2, proveď příkaz(y) 2, jinak proveď příkaz(y) 3. Podmínek je přitom možné za sebe zřetězit libovolné množství a celý zápis může, ale nemusí být ukončen závěrečnou částí else, za níž následují příkazy provedené v případě, kdy není splněna žádná z předchozích podmínek.\nJednou možností, jak výše popsané schéma realizovat, je následující:\na = 5\nb = 6\nif a == b:\n    print a,\"se rovna\",b\nelse:\n    if a &lt; b:\n        print a,\"je mensi nez\",b\n    else:\n        print a,\"je vetsi nez\",b\nJak je vidět, tímto způsobem dochází při zřetězení podmínek k postupnému zanořování dalších a dalších podmíněných příkazů do stále hlubší úrovně, což by při větším množství testovaných podmínek nebylo příliš přehledné. Z toho důvodu existuje v Pythonu alternativní způsob zápisu, spočívající v použití klíčového slova elif, které je vlastně zkráceninou else if. Způsob použití je patrný z ukázky (opět platí, že sekvence if-elif-elif-…-elif může a nemusí být ukončena částí else):\na = 5\nb = 6\nif a == b:\n    print a,\"se rovna\",b\nelif a &lt; b:\n    print a,\"je mensi nez\",b\nelse:\n    print a,\"je vetsi nez\",b\n\nÚkol 2. Napište skript, který pro zadaná dvě čísla rozhodne, zda je větší z nich dělitelné menším.\n\n\n\n\nNěkdy potřebujeme provádět nějaký příkaz či sérii příkazů opakovaně, dokud nenastane (či naopak neskončí) platnost nějaké podmínky. K tomu slouží cyklus while. V Pythonu je jeho syntaxe následující:\nwhile podminka:\n    příkaz 1\n    příkaz 2\n    ...\n    příkaz n\nDokud podmínka platí, bude se neustále provádět posloupnost příkazů 1, 2, … , n. Je důležité, aby v rámci těchto příkazů dříve či později došlo k tomu, že podmínka již neplatí. V opačném případě by vznikl tzv. nekonečný cyklus. Program bychom pak museli „násilně“ přerušit klávesovou zkratkou Ctrl+C, příp. v krajním případě pomocí Správce úloh systému Windows.\nPříkladem použití cyklu while může být výpočet faktoriálu daného přirozeného čísla, třeba 20:\nn = 20\nfakt = 1\ni = 2\nwhile i &lt;= n:\n    fakt = fakt * i\n    i = i + 1\nprint(fakt)\nPodmínkou pro pokračování cyklu je zde platnost výroku i &lt;= n. Tento výrok zcela jistě jednou platit přestane, neboť v každém kroku je hodnota proměnné i o jednotku zvětšena, takže jednou určitě překročí hodnotu n. Jakmile se tak stane, cyklus se již provádět nebude a program bude pokračovat prováděním příkazů (případně) uvedených za cyklem, tj. odsazených na úroveň slova while. V našem případě vytiskne výsledek do okna Python Shell:\n2432902008176640000\nPro různé hodnoty proměnné n budeme samozřejmě dostávat různé výsledky faktoriálu.\nCyklus while se dá vlastně považovat za zvláštní druh podmíněného příkazu, neboť určuje, co má program provést v případě splnění nějaké podmínky. Dokonce ho lze zkombinovat s klauzulí else, za níž následuje posloupnost příkazů, která se má provést, pakliže již podmínka splněna není (tj. po konci celého cyklu):\nwhile podmínka:\n    příkazy 1 až n\nelse:\n    příkazy n+1 až m\nLze namítnout, že stejně se bude program chovat, pokud namísto části else napíšeme příkazy n+1 až m za cyklus na úroveň slova while. To je pravda a použití else u cyklu while je skutečně velmi řídké. Přesto však není tato možnost zcela bez účelu, jak uvidíme v kapitole o příkazech break a continue.\n\nÚkol 3. Vytvořte seznam s Fibonacciho posloupností délky 100 pomocí cyklu while.\n\n\n\n\nCyklus for použijeme všude tam, kde chceme procházet nějaký seznam a s každou jeho položkou něco vykonat. Syntax je následující:\nfor polozka in seznam:\n    příkaz 1 (ve kterém se může použít proměnná položka)\n    příkaz 2 (ve kterém se může použít proměnná položka)\n    ...\nNapř. můžeme jednotlivé položky seznamu jednoduše vytisknout:\nseznam = [0,\"jedna\",2,\"tri\",4,\"pet\"]\nfor i in seznam: \n    print(i)\nVýsledkem bude výpis\n0\njedna\n2\ntri\n4\npet\nStejnou úlohu by šlo vyřešit i pomocí cyklu while:\ni = 0\nwhile i &lt; len(seznam):\n    print seznam[i]\n    i = i + 1\nCyklus for lze využít všude tam, kdy dopředu víme, jak dlouhý náš cyklus bude. V případě, že např. chceme nějakou posloupnost příkazů opakovat 20krát, stačí si vyrobit seznam dané délky a ten cyklem for projít. Položky procházeného seznamu přitom vůbec nemusíme v jednotlivých příkazech použít:\nfor i in [1]*20:\n    print(\"Nebudu rušit při hodině hlasitým krkáním.\")\nPo spuštění se vypíše\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nČasto se hodí procházet seznam čísel od jedné do n (třeba do dvaceti). K tomu může dobře posloužit funkce range:\n&gt;&gt;&gt; range(20) # Vrátí seznam délky 20, začíná se nulou\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n\n&gt;&gt;&gt; range(5, 10) # Vrátí seznam od 5 do 9\n[5, 6, 7, 8, 9]\n\n&gt;&gt;&gt; range(5, 50, 3) # Vrátí seznam od 5 do 49 s krokem 3\n[5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47]\n\n&gt;&gt;&gt; range(50, 5, -3) # Vrátí seznam od 50 do 6 s krokem -3\n[50, 47, 44, 41, 38, 35, 32, 29, 26, 23, 20, 17, 14, 11, 8]\nVýše uvedený výpočet faktoriálu by tedy mohl vypadat i takto:\nn = 20\nfakt = 1\nfor i in range(1, n+1):\n    fakt = fakt * i\nprint(fakt)\nCyklus for je možné i vnořit do hranatých závorek a vytvořit tak seznam. Následující kód vytváří seznam druhých mocnin čísel od 1 do 10:\n&gt;&gt;&gt; a = [x**2 for x in range(1,11)]\n&gt;&gt;&gt; a\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nSamozřejmě bychom stejný seznam mohli vytvořit i méně stručně:\n&gt;&gt;&gt; a = []\n&gt;&gt;&gt; for x in range(1,11): a.append(x**2)\n&gt;&gt;&gt; a\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nPrvní způsob je zjevně elegantnější a u zkušenějších programátorů se s ním setkáte častěji.\n\nÚkol 4. Vytvořte seznam s Fibonacciho posloupností délky 100 pomocí cyklu for.\n\n\n\n\nPříkazy break (anglicky přeruš) a continue (anglicky pokračuj) slouží k přerušení cyklu, nastane-li pro to nějaký důvod. Typicky se proto používají jako součást podmíněného příkazu, jak je vidět z následujícího schematického znázornění syntaxe příkazu break (uvádíme verzi s cyklem while i verzi s cyklem for):\n# Verze s cyklem while:\nwhile podmínka1:\n    první série příkazů\n    if podmínka2:\n        druhá série příkazů\n        break\n    else:\n        třetí série příkazů\nelse:\n    čtvrtá série příkazů\npátá série příkazů\n\n# Verze s cyklem for:\nfor položka in seznam:\n    první série příkazů\n    if podmínka2:\n        druhá série příkazů\n        break\n    else:\n        třetí série příkazů\nelse:\n    čtvrtá série příkazů\npátá série příkazů\n(První else se vztahuje k if, zatímco druhé else k cyklu while resp. for.)\nPříkaz break způsobí okamžité přerušení cyklu, přičemž pokud existuje (což nemusí!) i část else vztahující se k cyklu, pokračuje program až za ní. V naší schematické ukázce to znamená, že jakmile v nějakém kroku (iteraci) cyklu platí podmínka u if, tj. narazí se na příkaz break, program automaticky cyklus přeruší a pokračuje prováděním páté série příkazů.\nUkázkou použití příkazu break u cyklu for může být např. skript hledající nějakou konkrétní položku (např. číslo 20) v nějakém seznamu:\nfor cislo in seznam:\n    if cislo == 20:\n        print(\"Prave jsem nasel cislo 20!\")\n        break\nelse: print(\"Cislo 20 v seznamu neni!\")\nPříkaz continue způsobí, že je přerušen pouze právě probíhající běh cyklu a program pokračuje dalším krokem (iterací) cyklu. Bývá používán méně často než příkaz break, neboť většinou lze jeho použití nahradit vhodně zvoleným podmíněným příkazem. Z tohoto důvodu nebudeme uvádět ukázku.\n\n\n\n\n\n\n\nZ posloupnosti vzniklé řešením úkolu 3 resp. 4 vytvořte seznam obsahující pouze členy dělitelné třemi a zjistěte jeho délku.\nNapište skript, který pro zadané dva seznamy délky m a n, kde m &gt; n, vytvoří nový seznam, jehož prvních n prvků bude tvořeno prvky kratšího z obou seznamů, zbytek seznamu bude doplněn prvky delšího z obou seznamů. Řešení vytvořte tak, aby program fungoval při zadání libovolných dvou seznamů v libovolném pořadí.\nNapište skript pro porovnání dvou číselných seznamů “položku po položce”. Vstupem do programu budou dva libovolné seznamy a typ porovnání (“větší než”, “menší než” nebo “rovná se”). Výstupem bude seznam délky kratšího z obou seznamů, který na indexu i bude obsahovat výsledek porovnání (True/False) příslušných položek vstupních seznamů. Např. pro seznamy a = [1,2,3] a b = [1,-2,4,5] bude výsledkem porovnání “větší než” seznam [False, True, False].\nNapište skript, který pro zadaná dvě čísla rozhodne, zda jsou soudělná."
  },
  {
    "objectID": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#logické-výrazy",
    "href": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#logické-výrazy",
    "title": "Lekce 5: Řídící struktury programu - cykly a podmínky",
    "section": "",
    "text": "Logický výraz (jinak též pravdivostní výrok) je jakýkoli výrok, kterému lze jednoznačně přisoudit pravdivostní hodnotu, tj. určit, zda je pravdivý či nepravdivý. Přisouzení pravdivostní hodnoty danému výrazu se označuje jako jeho vyhodnocení. Logické výrazy se v programování používají všude tam, kde je třeba provézt nějaký příkaz (či sérii příkazů) pouze tehdy, je-li splněna nějaká podmínka (takovým příkazům se říká podmíněné příkazy). Podmínka pak má podobu logického výrazu, přičemž její splnění/nesplnění je dáno pravdivostní hodnotou tohoto výrazu.\nPorovnáním dvou hodnot lze vytvořit jednoduchý logický výraz, jehož pravdivostní hodnota je dána pravdivostí příslušného tvrzení:\n&gt;&gt;&gt; 3 &lt; 5\nTrue\n&gt;&gt;&gt; 3 &gt; 5\nFalse\nPorovnávat lze i textové řetězce. Porovnání je pak založeno na abecedním pořadí (tj. na tzv. lexikografickém uspořádání), přičemž velká písmena mají přednost před malými:\n&gt;&gt;&gt; \"ahoj\" &lt; \"svete\"\nTrue\n&gt;&gt;&gt; \"Ahoj\" &lt; \"AHOJ\"\nFalse\nRovnost se testuje operátorem == (pozor, nezaměňovat s operací =, která přiřazuje hodnotu proměnné!):\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; a == 5\nTrue\nNerovnost se testuje buď operátorem != nebo &lt;&gt;:\n&gt;&gt;&gt; a != 5\nFalse\n&gt;&gt;&gt; a &lt;&gt; 3\nTrue\nPoněkud složitější je porovnávací operátor is. U čísel a řetězců testuje rovnost stejně jako ==, ale u složitějších objektů, jako jsou seznamy, testuje totožnost objektů (tj. zda se jedná o tentýž objekt se shodnou adresou v paměti):\n&gt;&gt;&gt; a = 3\n&gt;&gt;&gt; b = 3\n&gt;&gt;&gt; a is b\nTrue\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; b = [1,2,3]\n&gt;&gt;&gt; a is b\nFalse\n&gt;&gt;&gt; a = b\n&gt;&gt;&gt; a is b\nTrue\nOpakem is je operátor is not.\nOperátor in testuje, zda je určitý prvek v daném seznamu, případně určitý znak v daném řetězci:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; 2 in a\nTrue\n&gt;&gt;&gt; \"a\" in \"ahoj\"\nTrue\nJeho opakem je not in:\n&gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; 4 not in a\nTrue\n&gt;&gt;&gt; \"z\" not in \"ahoj\"\nTrue\nSložené logické výroky lze z jednoduchých vytvářet pomocí tzv. logických operátorů and, or a not (mluvíme pak o tzv. logických operacích s logickými výrazy). Význam těchto operátorů je všeobecně známý z logiky, proto výklad omezíme jen na malou ukázku. Např. pokud chceme otestovat, zda je hodnota nějaké číselné proměnné obsažena v určitém seznamu a zároveň zda je větší než 3, lze to provést pomocí operátoru and:\n&gt;&gt;&gt; seznam = [1,2,3,4]\n&gt;&gt;&gt; a = 4\n&gt;&gt;&gt; a in seznam and a &gt; 3\nTrue\nStruktura složeného výrazu může být libovolně složitá, obsahující libovolné množství dílčích jednoduchých i složitých výrazů. Pokud jsou dílčí výrazy rovněž složené, je často nutné zajistit požadovaný význam výrazu použitím závorek:\n&gt;&gt;&gt; a in seznam and (a &gt; 3 or a &lt; -3)\nTrue\nUmístění závorek se řídí známou prioritou operací: nejprve se vždy vyhodnocuje not, pak and, posléze or. Pokud bychom v posledně uvedeném příkladu závorky vynechali, význam by se změnil (zodpovězte si: jak?).\n\nÚkol 1. Zadejte následující příkaz: s = [1, 4, -10, 6, 13, -2]. O následujících výrazech předem rozhodněte, zda jsou pravdivé či nepravdivé. Následně ověřte:\ns[1] &lt; s[3] or 3 in s and len(s) == s[3]\ns[1] &lt; s[3] or (3 in s and len(s) == s[3])\n(s[1] &lt; s[3] or 3 in s) and len(s) == s[3]\ns[1] &gt; s[3] and 3 not in s or len(s) == s[3]\ns[1] &gt; s[3] and (3 not in s or len(s) == s[3])\n(s[1] &gt; s[3] and 3 not in s) or len(s) == s[3]\ns[1] &gt; s[3] and not (3 not in s or len(s) == s[3])\nnot (s[1] &gt; s[3] and 3 not in s) or len(s) == s[3]\ns"
  },
  {
    "objectID": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#podmíněné-příkazy",
    "href": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#podmíněné-příkazy",
    "title": "Lekce 5: Řídící struktury programu - cykly a podmínky",
    "section": "",
    "text": "Příkaz se nazývá podmíněný, je-li jeho provedení vázáno splněním nějaké podmínky. Podmínkou přitom může být jakýkoli logický výraz, přičemž splnění podmínky je dáno jeho pravdivostní hodnotou. Syntaxe podmíněných příkazů v Pythonu je značně intuitivní, neboť kopíruje syntaxi běžného jazyka: pokud (anglicky if) platí podmínka, proveď následující příkaz(y):\nif podmínka: příkaz\nV případě více příkazů:\nif podmínka:\n    příkaz 1\n    příkaz 2\n    příkaz 3\n    ...\nVidíme zde blokovou strukturu kódu, založenou na povinném odsazování. Příkazy vázané na splnění podmínky jsou vůči řádku s klíčovým slovem if odsazené o jednu úroveň (= čtyři mezery) doprava. Jakýkoli příkaz odsazený na úroveň slova if již nebude s podmínkou nijak souviset, tj. provede se bez ohledu na její splnění či nesplnění.\nUveďme příklad:\n&gt;&gt;&gt; a = 5\n&gt;&gt;&gt; b = 6\n&gt;&gt;&gt; if a &lt; 6: print a\n    \n5\n&gt;&gt;&gt; if b &lt; 6: print b\n    \n&gt;&gt;&gt; if a &lt; b:\n    print a\n    print b\n    print a,\"je mensi nez\",b\n\n5\n6\n5 je mensi nez 6\n\nPokud zapisujeme podmíněný příkaz do okna Python Shell, je po ukončení zápisu třeba stisknout klávesu Enter hned dvakrát. Druhým stisknutím klávesy Enter dáváme interpretu najevo, že jsme již skončili se zápisem a celý blok může být interpretován (tj. proveden). To je důvod, proč za posledním řádkem zápisu je vždy jeden prázdný řádek.\n\nVedle specifikace, co se má provézt za příkazy v případě splnění nějaké podmínky, lze také programu říct, co má provézt za příkazy, pokud naopak podmínka splněna není. Syntaxe je opět intuitivní: pokud (if) platí podmínka, proveď následující příkaz(y), jinak (anglicky else) proveď alternativní příkaz(y):\nif podmínka:\n    příkaz 1\n    příkaz 2\nelse:\n    příkaz 3\n    příkaz 4\nKonkrétní příklad tentokrát zapíšeme pomocí skriptu:\na = 5\nb = 6\nif a == b:\n    print(str(a) + \" se rovna \" + str(b))\nelse:\n    print(str(a) + \" se nerovna \" + str(b))\nPo spuštění skriptu se v okně Python Shell vypíše:\n5 se nerovna 6\nČasto také nastává případ, že potřebujeme postupně otestovat více různých podmínek, při jejichž splnění se vždy má provést odpovídající příkazy. Struktura zápisu je: pokud platí podmínka 1, proveď příkaz(y) 1, jinak pokud platí podmínka 2, proveď příkaz(y) 2, jinak proveď příkaz(y) 3. Podmínek je přitom možné za sebe zřetězit libovolné množství a celý zápis může, ale nemusí být ukončen závěrečnou částí else, za níž následují příkazy provedené v případě, kdy není splněna žádná z předchozích podmínek.\nJednou možností, jak výše popsané schéma realizovat, je následující:\na = 5\nb = 6\nif a == b:\n    print a,\"se rovna\",b\nelse:\n    if a &lt; b:\n        print a,\"je mensi nez\",b\n    else:\n        print a,\"je vetsi nez\",b\nJak je vidět, tímto způsobem dochází při zřetězení podmínek k postupnému zanořování dalších a dalších podmíněných příkazů do stále hlubší úrovně, což by při větším množství testovaných podmínek nebylo příliš přehledné. Z toho důvodu existuje v Pythonu alternativní způsob zápisu, spočívající v použití klíčového slova elif, které je vlastně zkráceninou else if. Způsob použití je patrný z ukázky (opět platí, že sekvence if-elif-elif-…-elif může a nemusí být ukončena částí else):\na = 5\nb = 6\nif a == b:\n    print a,\"se rovna\",b\nelif a &lt; b:\n    print a,\"je mensi nez\",b\nelse:\n    print a,\"je vetsi nez\",b\n\nÚkol 2. Napište skript, který pro zadaná dvě čísla rozhodne, zda je větší z nich dělitelné menším."
  },
  {
    "objectID": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#cyklus-while",
    "href": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#cyklus-while",
    "title": "Lekce 5: Řídící struktury programu - cykly a podmínky",
    "section": "",
    "text": "Někdy potřebujeme provádět nějaký příkaz či sérii příkazů opakovaně, dokud nenastane (či naopak neskončí) platnost nějaké podmínky. K tomu slouží cyklus while. V Pythonu je jeho syntaxe následující:\nwhile podminka:\n    příkaz 1\n    příkaz 2\n    ...\n    příkaz n\nDokud podmínka platí, bude se neustále provádět posloupnost příkazů 1, 2, … , n. Je důležité, aby v rámci těchto příkazů dříve či později došlo k tomu, že podmínka již neplatí. V opačném případě by vznikl tzv. nekonečný cyklus. Program bychom pak museli „násilně“ přerušit klávesovou zkratkou Ctrl+C, příp. v krajním případě pomocí Správce úloh systému Windows.\nPříkladem použití cyklu while může být výpočet faktoriálu daného přirozeného čísla, třeba 20:\nn = 20\nfakt = 1\ni = 2\nwhile i &lt;= n:\n    fakt = fakt * i\n    i = i + 1\nprint(fakt)\nPodmínkou pro pokračování cyklu je zde platnost výroku i &lt;= n. Tento výrok zcela jistě jednou platit přestane, neboť v každém kroku je hodnota proměnné i o jednotku zvětšena, takže jednou určitě překročí hodnotu n. Jakmile se tak stane, cyklus se již provádět nebude a program bude pokračovat prováděním příkazů (případně) uvedených za cyklem, tj. odsazených na úroveň slova while. V našem případě vytiskne výsledek do okna Python Shell:\n2432902008176640000\nPro různé hodnoty proměnné n budeme samozřejmě dostávat různé výsledky faktoriálu.\nCyklus while se dá vlastně považovat za zvláštní druh podmíněného příkazu, neboť určuje, co má program provést v případě splnění nějaké podmínky. Dokonce ho lze zkombinovat s klauzulí else, za níž následuje posloupnost příkazů, která se má provést, pakliže již podmínka splněna není (tj. po konci celého cyklu):\nwhile podmínka:\n    příkazy 1 až n\nelse:\n    příkazy n+1 až m\nLze namítnout, že stejně se bude program chovat, pokud namísto části else napíšeme příkazy n+1 až m za cyklus na úroveň slova while. To je pravda a použití else u cyklu while je skutečně velmi řídké. Přesto však není tato možnost zcela bez účelu, jak uvidíme v kapitole o příkazech break a continue.\n\nÚkol 3. Vytvořte seznam s Fibonacciho posloupností délky 100 pomocí cyklu while."
  },
  {
    "objectID": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#cyklus-for",
    "href": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#cyklus-for",
    "title": "Lekce 5: Řídící struktury programu - cykly a podmínky",
    "section": "",
    "text": "Cyklus for použijeme všude tam, kde chceme procházet nějaký seznam a s každou jeho položkou něco vykonat. Syntax je následující:\nfor polozka in seznam:\n    příkaz 1 (ve kterém se může použít proměnná položka)\n    příkaz 2 (ve kterém se může použít proměnná položka)\n    ...\nNapř. můžeme jednotlivé položky seznamu jednoduše vytisknout:\nseznam = [0,\"jedna\",2,\"tri\",4,\"pet\"]\nfor i in seznam: \n    print(i)\nVýsledkem bude výpis\n0\njedna\n2\ntri\n4\npet\nStejnou úlohu by šlo vyřešit i pomocí cyklu while:\ni = 0\nwhile i &lt; len(seznam):\n    print seznam[i]\n    i = i + 1\nCyklus for lze využít všude tam, kdy dopředu víme, jak dlouhý náš cyklus bude. V případě, že např. chceme nějakou posloupnost příkazů opakovat 20krát, stačí si vyrobit seznam dané délky a ten cyklem for projít. Položky procházeného seznamu přitom vůbec nemusíme v jednotlivých příkazech použít:\nfor i in [1]*20:\n    print(\"Nebudu rušit při hodině hlasitým krkáním.\")\nPo spuštění se vypíše\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nNebudu rušit při hodině hlasitým krkáním.\nČasto se hodí procházet seznam čísel od jedné do n (třeba do dvaceti). K tomu může dobře posloužit funkce range:\n&gt;&gt;&gt; range(20) # Vrátí seznam délky 20, začíná se nulou\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n\n&gt;&gt;&gt; range(5, 10) # Vrátí seznam od 5 do 9\n[5, 6, 7, 8, 9]\n\n&gt;&gt;&gt; range(5, 50, 3) # Vrátí seznam od 5 do 49 s krokem 3\n[5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47]\n\n&gt;&gt;&gt; range(50, 5, -3) # Vrátí seznam od 50 do 6 s krokem -3\n[50, 47, 44, 41, 38, 35, 32, 29, 26, 23, 20, 17, 14, 11, 8]\nVýše uvedený výpočet faktoriálu by tedy mohl vypadat i takto:\nn = 20\nfakt = 1\nfor i in range(1, n+1):\n    fakt = fakt * i\nprint(fakt)\nCyklus for je možné i vnořit do hranatých závorek a vytvořit tak seznam. Následující kód vytváří seznam druhých mocnin čísel od 1 do 10:\n&gt;&gt;&gt; a = [x**2 for x in range(1,11)]\n&gt;&gt;&gt; a\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nSamozřejmě bychom stejný seznam mohli vytvořit i méně stručně:\n&gt;&gt;&gt; a = []\n&gt;&gt;&gt; for x in range(1,11): a.append(x**2)\n&gt;&gt;&gt; a\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nPrvní způsob je zjevně elegantnější a u zkušenějších programátorů se s ním setkáte častěji.\n\nÚkol 4. Vytvořte seznam s Fibonacciho posloupností délky 100 pomocí cyklu for."
  },
  {
    "objectID": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#příkazy-break-a-continue",
    "href": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#příkazy-break-a-continue",
    "title": "Lekce 5: Řídící struktury programu - cykly a podmínky",
    "section": "",
    "text": "Příkazy break (anglicky přeruš) a continue (anglicky pokračuj) slouží k přerušení cyklu, nastane-li pro to nějaký důvod. Typicky se proto používají jako součást podmíněného příkazu, jak je vidět z následujícího schematického znázornění syntaxe příkazu break (uvádíme verzi s cyklem while i verzi s cyklem for):\n# Verze s cyklem while:\nwhile podmínka1:\n    první série příkazů\n    if podmínka2:\n        druhá série příkazů\n        break\n    else:\n        třetí série příkazů\nelse:\n    čtvrtá série příkazů\npátá série příkazů\n\n# Verze s cyklem for:\nfor položka in seznam:\n    první série příkazů\n    if podmínka2:\n        druhá série příkazů\n        break\n    else:\n        třetí série příkazů\nelse:\n    čtvrtá série příkazů\npátá série příkazů\n(První else se vztahuje k if, zatímco druhé else k cyklu while resp. for.)\nPříkaz break způsobí okamžité přerušení cyklu, přičemž pokud existuje (což nemusí!) i část else vztahující se k cyklu, pokračuje program až za ní. V naší schematické ukázce to znamená, že jakmile v nějakém kroku (iteraci) cyklu platí podmínka u if, tj. narazí se na příkaz break, program automaticky cyklus přeruší a pokračuje prováděním páté série příkazů.\nUkázkou použití příkazu break u cyklu for může být např. skript hledající nějakou konkrétní položku (např. číslo 20) v nějakém seznamu:\nfor cislo in seznam:\n    if cislo == 20:\n        print(\"Prave jsem nasel cislo 20!\")\n        break\nelse: print(\"Cislo 20 v seznamu neni!\")\nPříkaz continue způsobí, že je přerušen pouze právě probíhající běh cyklu a program pokračuje dalším krokem (iterací) cyklu. Bývá používán méně často než příkaz break, neboť většinou lze jeho použití nahradit vhodně zvoleným podmíněným příkazem. Z tohoto důvodu nebudeme uvádět ukázku."
  },
  {
    "objectID": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#úlohy",
    "href": "material/old_materials/Lekce 5 Řídící struktury programu - cykly a podmínky.html#úlohy",
    "title": "Lekce 5: Řídící struktury programu - cykly a podmínky",
    "section": "",
    "text": "Z posloupnosti vzniklé řešením úkolu 3 resp. 4 vytvořte seznam obsahující pouze členy dělitelné třemi a zjistěte jeho délku.\nNapište skript, který pro zadané dva seznamy délky m a n, kde m &gt; n, vytvoří nový seznam, jehož prvních n prvků bude tvořeno prvky kratšího z obou seznamů, zbytek seznamu bude doplněn prvky delšího z obou seznamů. Řešení vytvořte tak, aby program fungoval při zadání libovolných dvou seznamů v libovolném pořadí.\nNapište skript pro porovnání dvou číselných seznamů “položku po položce”. Vstupem do programu budou dva libovolné seznamy a typ porovnání (“větší než”, “menší než” nebo “rovná se”). Výstupem bude seznam délky kratšího z obou seznamů, který na indexu i bude obsahovat výsledek porovnání (True/False) příslušných položek vstupních seznamů. Např. pro seznamy a = [1,2,3] a b = [1,-2,4,5] bude výsledkem porovnání “větší než” seznam [False, True, False].\nNapište skript, který pro zadaná dvě čísla rozhodne, zda jsou soudělná."
  },
  {
    "objectID": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html",
    "href": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html",
    "title": "Lekce 7: Práce s adresářovou strukturou a s textovými soubory",
    "section": "",
    "text": "V této lekci si probereme, jak se v Pythonu dá zacházet s adresářovou strukturou počítače (nastavování pracovního adresáře, tvorba adresářových cest, tvorba a mazání adresářů apod.) a jak lze číst a zapisovat textové soubory. Přitom si zároveň rozšíříme možnosti práce s textovými řetězci.\n\n\nV Pythonu je výchozím způsobem, jak zapsat adresářovou cestu, klasický styl se zpětnými lomítky, např. C:\\Moje_slozka\\muj_soubor.txt. Problém je, že zpětné lomítko, jak víme, má v textových řetězcích speciální význam (uvozuje escape sekvenci). To lze obejít třemi způsoby:\n\nV zápisu cest použijeme dopředná lomítka: \"C:/Moje_slozka/muj_soubor.txt\". S tím si Python poradí.\nPoužijeme escape sekvenci \\\\, tj. dvojitá zpětná lomítka: \"C:\\\\Moje_slozka\\\\muj_soubor.txt\". Oba popsané způsoby jsou jistě výhodné tehdy, chceme-li cesty vypisovat ručně. Často ale využíváme např. toho, že si cestu zkopírujeme z nějakého prohlížeče a následně vložíme do kódu. Takové cesty mívají zpětná lomítka a jejich následná editace (záměna za dopředná či dvojitá zpětná lomítka) je zdlouhavá a nepraktická. Z takovém případě se hodí třetí způsob:\nPřed textový řetězec napíšeme r, čímž z něj vytvoříme “surový” (angl. “raw”) řetězec, jehož všechny znaky se interpretují tak, jak jsou (tj. řetězec neobsahuje žádné escape sekvence): r\"C:\\Moje_slozka\\muj_soubor.txt\".\n\nPřehled všech tří metod:\n# Dopředná lomítka\npath = \"C:/Moje_slozka/muj_soubor.txt\"\n\n# Dvojitá zpětná lomítka\npath = \"C:\\\\Moje_slozka\\\\muj_soubor.txt\"\n\n# Surový řetězec\npath = r\"C:\\Moje_slozka\\muj_soubor.txt\"\n\n\n\nJméno modulu je zkratkou slov operační systém (anglicky “operating system”). Modul je určen pro správu adresářů a procesů. Z mnoha funkcí modulu budou pro nás užitečné zvláště některé pro správu adresářů. Parametr path (anglicky “cesta”) má ve všech ukázkách význam textového řetězce s adresou složky nebo souboru.\nModul načteme standardním způsobem:\nimport os\nPři operacích s adresářovou strukturou je výhodné mít správně nastaven tzv. pracovní adresář (angl. “workspace direcory”). Je-li nastaven, nemusíme např. při zadávání vstupních souborů do nějakého výpočtu zadávat celou cestu k souboru - pokud je vstupní soubor v pracovním adresáři, interpret Pythonu jej bude hledat tam. Rovněž jakékoli výstupní soubory, pokud neurčíme celou cestu, kam mají být uloženy, se budou ukládat do pracovního adresáře. Výchozí nastavení pracovního adresáře závisí na tom, jak jsme program IDLE spustili:\n\nPři otevření programu IDLE standardním způsobem z nabídky programů je pracovní adresář nastaven na výchozí pozici, typicky třeba 'C:\\\\WINDOWS\\\\system32'. (Pokud budeme nyní chtít např. otevřít nějaký skript stisknutím kláves Ctrl+O, vyhledávací okno se otevře právě v tomto umístění.)\nPři otevření programu IDLE “ze skriptu”, tj. tím, že skript otevřeme pro editaci v programu IDLE, je pracovní adresář automaticky nastaven na složku s tímto skriptem.\n\nPro zjištění aktuálního pracovního adresáře slouží funkce getcwd() (z angl. “current workspace directory”):\n&gt;&gt;&gt; os.getcwd()\n'C:\\\\Documents and Settings\\\\Muj_pocitac'\nPokud chceme naopak pracovní adresář změnit, použijeme funkci chdir(path) (z angl. “change directory”). Pozor: příslušné umístění path musí existovat!\n&gt;&gt;&gt; os.chdir(\"C:/Moje_slozka\")\n&gt;&gt;&gt; os.getcwd()\n'C:\\\\Moje_slozka'\nČasto chceme nějaký výpočet provést v cyklu pro všechny soubory v nějaké složce, případně pro všechny složky v nějaké nadřazené složce. Abychom získali seznam položek uvnitř nějaké složky, použijeme funkci listdir(path). Výstupní seznam je seznamem názvů (tj. řetězců) položek, včetně koncovek:\n&gt;&gt;&gt; os.listdir(\"C:/Moje_slozka\")\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Prvni_soubor.doc']\nČasto se potřebujeme v podobných funkcích odkázat na aktuální pracovní adresář (např. vypsat jeho obsah). To je možné pomocí již zmíněné funkce getcwd:\n&gt;&gt;&gt; os.listdir(getcwd())\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Prvni_soubor.doc']\nExistuje však i jednodušší způsob. V Pythonu se totiž lze odkazovat na pracovní adresář zkratkou \".\":\n&gt;&gt;&gt; os.listdir(\".\")\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Prvni_soubor.doc']\n\nÚkol 1. Změňte svůj pracovní adresář na nějakou složku, ve které máte větší množství souborů různých typů. Následně vypište její obsah na konzoli.\n\nDalší dvě funkce, které si ukážeme, slouží k vytváření nových adresářů. První, funkce mkdir(path), vytvoří na dané adrese novou složku. Podmínkou je, že celá cesta kromě koncové vytvářené složky existuje. TUto podmínku obchází druhá funkce, makedirs(path), která vytvoří na dané adrese novou složku, včetně všech případných neexistujících nadřazených složek.\n&gt;&gt;&gt; os.mkdir(\"C:/nova_slozka\")\n&gt;&gt;&gt; os.makedirs(\"C:/nejaka_nadslozka/nova_slozka\")\nPokud naopak chceme nějakou složku či soubor smazat, máme k dispozici následující funkce:\n# Smazání souboru\n&gt;&gt;&gt; os.remove(\"C:/Moje_slozka/muj_soubor.doc\")\n\n# Smazání (prázdné!) složky\n&gt;&gt;&gt; os.rmdir(\"C:/nova_slozka\")\n\n# Smazání (prázdné!) složky včetně všech (prázdných!) nadsložek\n&gt;&gt;&gt; os.removedirs(\"C:/ nejaka_nadslozka/nova_slozka\")\nUžitečné jsou rovněž funkce rename(old, new) a renames(old_path, new_path), pomocí kterých lze přejmenovávat cesty k souborů, a tím nejen měnit jejich název, ale i soubory přesouvat na nová umístění. První z nich, rename, přejmenuje cílový soubor ze staré cesty na novou, složka nového umístění souboru však již musí existovat. Druhá funkce, renames, toto nepožaduje a potřebné neexistující složky v nové cestě nejprve vytvoří (a zároveň odstraní již nepotřebné složky původní cesty).\n# Přejmenování souboru\nos.listdir(\"C:/nova_slozka\")\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Prvni_soubor.doc']\nos.rename(\"C:/nova_slozka/Prvni_soubor.doc\", \"C:/nova_slozka/Treti_soubor.doc\")\nos.listdir(\"C:/nova_slozka\")\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Treti_soubor.doc']\n\n# Přesunutí souboru\nos.renames(\"C:/nova_slozka/Prvni_soubor.doc\", \"C:/uplne/jina/cesta/Treti_soubor.doc\")\n\nÚkol 2. Uložte všechny textové soubory (nebo soubory jiného určitého typu) z vašeho pracovního adresáře do nově vytvořené podsložky “textove_soubory”. Použijte cyklus a podmínku if.\n\n\n\n\nModul os.path je podmodul modulu os, obsahující funkce pro práci se samotnými adresářovými cestami. Po načtení modulu os jsou funkce podmodulu přístupné přes os.path.nejaka_funkce(), podmodul lze však také načíst samostatně (pak ovšem ostatní funkce z modulu os přístupné nebudou):\nimport os.path\npřípadně:\nfrom os import path\nVe druhém případě budou funkce podmodulu dostupné přes path.nejaka_funkce().\nZ obsahu podmodulu os.path vybíráme pouze některé, pro nás potenciálně užitečné funkce.\nFunkce basename(path) vrací poslední položku názvu cesty path, tj. v případě, že jde o adresu souboru, vrací jméno souboru, v případě, že jde o složku, vrací jméno složky:\n&gt;&gt;&gt; os.path.basename(\"C:/Moje_slozka/Dalsi_soubor.xls\")\n'Dalsi_soubor.xls'\n&gt;&gt;&gt; os.path.basename(\"C:/Moje_slozka\")\n'Moje_slozka'\nFunkce dirname(path) vrací nadřazenou složku poslední položky cesty:\n&gt;&gt;&gt; os.path.dirname(\"C:/Moje_slozka/Dalsi_soubor.xls\")\n'C:/Moje_slozka'\n&gt;&gt;&gt; os.path.dirname(\"C:/Moje_slozka\")\n'C:/'\nČasto potřebuju spojit adresu nějakého umístění z jednotlivých částí, např. C:\\hlavni_slozka, dalsi_slozka a nazev_souboru.xls, které máme uložené samostatně v nějakých proměnných. To můžeme udělat buď ručně:\na = \"C:/hlavni_slozka\"\nb = \"dalsi_slozka\"\nc = \"nazev_souboru.xls\"\npath = a + \"/\" + b + \"/\" + c\npath\n\"C:/hlavni_slozka/dalsi_slozka/nazev_souboru.xls\"\nnebo trochu stručnějším a bezpečnějším způsobem pomocí funkce join:\npath = os.path.join(a, b, c)\npath\n\"C:\\\\hlavni_slozka\\\\dalsi_slozka\\\\nazev_souboru.xls\"\nChceme-li ověřit, že dané umístění (soubor či složka) existuje, použijeme funkci exists:\n&gt;&gt;&gt; os.path.exists(\"C:/Moje_slozka/Dalsi_soubor.xls\")\nTrue\n&gt;&gt;&gt; os.path.exists(\"C:/Moje_slozka/Dalsi_soubor.txt\")\nFalse\nNěkdy se také hodí zjistit, zda je dané existující umístění adresou složky či souboru:\n# Ověří, zda je daná cesta cestou k souboru\n&gt;&gt;&gt; os.path.isfile(\"C:/Moje_slozka/Dalsi_soubor.xls\")\nTrue\n&gt;&gt;&gt; os.path.isfile(\"C:/Moje_slozka\")\nFalse\n\n# Ověří, zda je daná cesta cestou ke složce\n&gt;&gt;&gt; os.path.isdir(\"C:/Moje_slozka/Dalsi_soubor.xls\")\nFalse\n&gt;&gt;&gt; os.path.isdir(\"C:/Moje_slozka\")\nTrue\n\nÚkol 3. Modifikujte řešení úkolu 2 tak, abyste použili funkci os.path.join.\n\n\n\n\nPro další část této lekce bude výhodné seznámit se s jednou technikou práce s textovými řetězci, která nebyla probrána v lekci o datových typech. Je jí rozdělení řetězce daným znakem či sérií znaků metodou split, což je funkce, která se volá přímo na daném řetězci či na proměnné obsahující řetězec:\n&gt;&gt;&gt; \"anakonda\".split(\"a\")\n['', 'n', 'kond', '']\n\n&gt;&gt;&gt; a = \"okolo potoka\"\n&gt;&gt;&gt; b = a.split(\"o\")\n&gt;&gt;&gt; b\n['', 'k', 'l', ' p', 't', 'ka']\nVidíme, že funkce split vrací seznam jednotlivých částí původního řetězce, rozděleného zadaným znakem. Pokud je tento znak na začátku či na konci řetězce, obsahuje výsledný seznam na začátku resp. na konci prázdný řetězec.\nPokud použijeme funkci split bez argumentu, tj. bez zadání řetězce, kterým se má vstupní řetězec rodělit, rozdělí se všemi tzn. prázdnými znaky, tj. mezerou, tabulátorem (znak \\t) či znakem nového řádku (znak \\n). V případě, že text obsahuje posloupnost jakýchkoli prázdných znaků za sebou, interpretuje se tato posloupnost, jako by šlo o jeden prázdný znak (tj. řetězec se v tomto místě rozdělí jen jednou):\n&gt;&gt;&gt; zprava = \"Ahoj lasko\\tje to    jiz dlouho\\nco jsme\\t\\t\\tse nevideli\"\n&gt;&gt;&gt; print(zprava)\nAhoj lasko  je to    jiz dlouho\nco jsme         se nevideli\n\n&gt;&gt;&gt; zprava.split()\n['Ahoj', 'lasko', 'je', 'to', 'jiz', 'dlouho', 'co', 'jsme', 'se', 'nevideli']\nTímto způsobem lze snadno nějaký text rozdělit na jednotlivá slova.\n\n\n\nPro ilustraci si představme textový soubor obsahující následující text:\nDavno, davno jiz tomu, co jsem posledne se divala do te mile mirne tvare, co jsem zulibala to blede lice, plne vrasku, nahlizela do modreho oka, v nemz se jevilo tolik dobroty a lasky; davno tomu, co mne posledne zehnaly stare jeji ruce! - Neni vice dobre starenky! Davno jiz odpociva v chladne zemi!\nMne ale neumrela! - Obraz jeji odtisknut v dusi me s veskerou svoji barvitosti, a dokud zdrava zustane, dotud bude zit v ni! - Kdybych stetcem mistrne vladnout znala, oslavila bych te, mila babicko, jinak; ale nastin tento, perem kresleny - nevim, nevim, jak se komu zalibi!\nTy jsi ale vzdy rikala: \"Neni na svete clovek ten, aby se zachoval lidem vsem.\" Dost na tom, kdyz se najde jen nekolik ctenaru, kteri o tobe s takovou oblibou cisti budou, s jakou ja o tobe pisu.\nDejme tomu, že je soubor s tímto textem uložen na adrese C:\\Documents and Settings\\user\\Dokumenty\\babicka.txt.\nK otevření souboru pro čtení slouží vestavěná funkce open:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\babicka.txt\", \"r\")\nHodnota druhého parametru \"r“ je odvozena z anglického „read“ a udává, že bude soubor otevřen pro čtení.\nPokud chceme ze souboru přečíst naráz vše, co obsahuje, použijeme funkci read(). Výsledkem je jediný textový řetězec obsahující celý text:\n&gt;&gt;&gt; a = soubor.read()\n&gt;&gt;&gt; print(a)\nDavno, davno jiz tomu, co jsem posledne se divala do te mile mirne tvare, co jsem zulibala to blede lice, plne vrasku, nahlizela do modreho oka, v nemz se jevilo tolik dobroty a lasky; davno tomu, co mne posledne zehnaly stare jeji ruce! - Neni vice dobre starenky! Davno jiz odpociva v chladne zemi!\nMne ale neumrela! - Obraz jeji odtisknut v dusi me s veskerou svoji barvitosti, a dokud zdrava zustane, dotud bude zit v ni! - Kdybych stetcem mistrne vladnout znala, oslavila bych te, mila babicko, jinak; ale nastin tento, perem kresleny - nevim, nevim, jak se komu zalibi!\nTy jsi ale vzdy rikala: \"Neni na svete clovek ten, aby se zachoval lidem vsem.\" Dost na tom, kdyz se najde jen nekolik ctenaru, kteri o tobe s takovou oblibou cisti budou, s jakou ja o tobe pisu.\nDůležité je po každé ukončené akci se souborem daný soubor uzavřít:\n&gt;&gt;&gt; soubor.close()\nJinou možností je číst pouze jeden řádek pomocí funkce readline() (pozor: v našem textu je celý odstavec jediným řádkem!). Opakované volání této funkce čte postupně jednotlivé řádky:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\babicka.txt\",\"r\")\n&gt;&gt;&gt; a = soubor.readline()\n&gt;&gt;&gt; b = soubor.readline()\n&gt;&gt;&gt; print(a)\nDavno, davno jiz tomu, co jsem posledne se divala do te mile mirne tvare, co jsem zulibala to blede lice, plne vrasku, nahlizela do modreho oka, v nemz se jevilo tolik dobroty a lasky; davno tomu, co mne posledne zehnaly stare jeji ruce! - Neni vice dobre starenky! Davno jiz odpociva v chladne zemi!\n&gt;&gt;&gt; print(b)\nMne ale neumrela! - Obraz jeji odtisknut v dusi me s veskerou svoji barvitosti, a dokud zdrava zustane, dotud bude zit v ni! - Kdybych stetcem mistrne vladnout znala, oslavila bych te, mila babicko, jinak; ale nastin tento, perem kresleny - nevim, nevim, jak se komu zalibi!\n&gt;&gt;&gt; soubor.close()\nKonečně poslední možností je číst celý text po řádcích pomocí funkce readlines(). V takovém případě je výsledkem seznam textových řetězců obsahujících jednotlivé řádky (všimněte si znaků \\n na konci každého řádku):\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\babicka.txt\",\"r\")\n&gt;&gt;&gt; a = soubor.readlines()\n&gt;&gt;&gt; print(a)\n['Davno, davno jiz tomu, co jsem posledne se divala do te mile mirne tvare, co jsem zulibala to blede lice, plne vrasku, nahlizela do modreho oka, v nemz se jevilo tolik dobroty a lasky; davno tomu, co mne posledne zehnaly stare jeji ruce! - Neni vice dobre starenky! Davno jiz odpociva v chladne zemi!\\n', 'Mne ale neumrela! - Obraz jeji odtisknut v dusi me s veskerou svoji barvitosti, a dokud zdrava zustane, dotud bude zit v ni! Kdybych stetcem mistrne vladnout znala, oslavila bych te, mila babicko, jinak; ale nastin tento, perem kresleny - nevim, nevim, jak se komu zalibi!\\n', 'Ty jsi ale vzdy rikala: \"Neni na svete clovek ten, aby se zachoval lidem vsem.\" Dost na tom, kdyz se najde jen nekolik ctenaru, kteri o tobe s takovou oblibou cisti budou, s jakou ja o tobe pisu. \\n']\n&gt;&gt;&gt; soubor.close()\n\nÚkol 4. Uložte si (“manuálně”, např. pomocí Poznámkového bloku) uvedený text do textového souboru. Následně soubor v Pythonu otevřte a zjistěte počet řádků, počet slov a počet znaků v textu.\n\nV aplikacích často chceme procházet text přečtený z nějakého souboru “řádek po řádku”. Např. se může jednat o datovou tabulku ve formátu .csv (“comma-separated values”, hodnoty oddělené čárkou), což je jednoduchý textový soubor s tabulkovými daty, který lze nicméně přímo otevírat např. v aplikaci MS Excel. Procházení “řádek po řádku” pak znamená procházení jednotlivých řádků tabulky. Lze k němu využít již zmíněné funkce readlines, která vrací seznam řádků - ten lze samozřejmě následně procházet cyklem:\nf = open(\"tabulka.csv\", \"r\")\nlines = f.readlines()\nf.close()\nfor l in lines:\n    # Tady bude nějaká akce s proměnnou l\nObjekt, který vrací funkce open, je nicméně v Pythonu udělán tak, že lze v cyklu procházet přímo jej, chová se tedy sám jako seznam řádků:\nf = open(\"tabulka.csv\", \"r\")\nfor l in f:\n    # Tady bude nějaká akce s proměnnou l\nf.close()\nV tomto případě se ovšem procházení děje pomocí tzv. kurzoru, což se mimo jiné projeví tím, že projdeme-li celý soubor až do konce, je kurzor na konci souboru a další procházení již nic nevrací:\n&gt;&gt;&gt; f = open(\"text.txt\", \"r\")\n&gt;&gt;&gt; for l in f: print(l)\n\nprvni radek\ndruhy radek\n...\nposledni radek\n&gt;&gt;&gt; for l in f: print(l)\n\n&gt;&gt;&gt; f.close()\nAbychom soubor mohli procházet znovu, museli bychom soubor znovu načíst.\nZpůsob pomocí načtení seznamu řádků metodou readlines má navíc tu výhodu, že lze procházet jen vybrané řádky, např. při čtení tabulky vynechat první řádek, jímž bývá hlavička tabulky:\nf = open(\"tabulka.csv\", \"r\")\nlines = f.readlines()\nf.close()\nfor l in lines[1:]:\n    # Tady bude nějaká akce s proměnnou l\nZávěrem si ještě ukážeme způsob, jak soubory otevírat, aniž byste museli myslet na jejich následné zavření. Je to možné pomocí klauzule with, která vytváří odsazený blok kódu. Jakmile blok kódu skončí tím, že odsadíme na původní úroveň, otevřený soubor se sám automaticky zavře. Syntax je následující:\nwith open(\"soubor.txt\") as f:\n    f.readlines()\n    ...\n# Tady pokračuje kód a soubor již je uzavřen\n\nÚkol 5. Otevřte si tabulku precipitation_2014.csv v aplikaci MS Excel a prozkoumejte, co obsahuje. Pak ji zavřete a otevřete ji v programu Poznámkový blok: čím jsou odděleny jednotlivé sloupce? Napište program, který tabulku otevřte a spočítá průměrný srážkový úhrn v srpnu daného roku. (Poznámka: data pocházejí z ČHMÚ.)\n\n\n\n\nChceme-li naopak do textového souboru zapisovat, je nutné jej otevřít s parametrem \"w\" (z anglického „write“):\nsoubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\dedecek.txt\",\"w\")\nSoubor, který tímto způsobem otvíráme, nemusí ve skutečnosti vůbec existovat a je tímto příkazem vytvořen (musí však existovat příslušná složka). Pokud soubor již existuje, je uvedeným způsobem otevření veškerý jeho obsah vymazán a při následném zapisování nahrazen obsahem novým.\nZápis se provádí pomocí funkce write(text). Pokud chceme zapsat text na více řádků, je třeba použít znak pro konec řádku \\n. Opět je třeba nezapomenout na konečné uzavření souboru.\n&gt;&gt;&gt; soubor.write(\"Ahoj dedo.\\n\")\n&gt;&gt;&gt; soubor.write(\"Nevis,\\nco je s babickou?\")\n&gt;&gt;&gt; soubor.close()\nPřečteme-li výsledný soubor, obdržíme:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\dedecek.txt\",\"r\")\n&gt;&gt;&gt; print(soubor.read()\nAhoj dedo.\nNevis,\nco je s babickou?\n&gt;&gt;&gt; soubor.close()\nZbývá vyřešit, jak zapisovat do existujícího souboru, aniž bychom jej při otvírání celý přepsali. To lze provést jeho otevřením s parametrem \"a\" (z anglického „append“). Následný zápis funkcí write(text) pak způsobí zapsání daného textu na konec za již existující text:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\dedecek.txt\",\"a\")\n&gt;&gt;&gt; soubor.write(\"\\nJo, hochu, to vazne nevim.\")\n&gt;&gt;&gt; soubor.close()\nVýsledek vypadá následovně:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\dedecek.txt\",\"r\")\n&gt;&gt;&gt; print(soubor.read())\nAhoj dedo.\nNevis,\nco je s babickou?\nJo, hochu, to vazne nevim.\n&gt;&gt;&gt; soubor.close()\n\nÚkol 6. Napiště program, který v tabulce precipitation_2014.csv změní desetinné tečky na desetinné čárky.\n\n\n\n\n\n\n\n\nNapište program, který vyrobí obrácenou kopii daného textového souboru (tj. text ve výstupním souboru bude zrcadlově obrácen).\nNapište program, který spočítá četnost výskytu daného písmene v zadaném vstupním textovém souboru. Řešte nejdříve s použitím metody count seznamů, následně bez této metody.\nVe složce data_teplota najdete textové soubory, v nichž jsou údaje o měření teploty (v desetinách stupně Celsia) na jednotlivých evropských stanicích (každé stanici odpovídá jeden soubor). Napište program, který z těchto textových souborů vyextrahuje hodnoty teplot pro květen 1998, spočítá pro každou stanici z těchto hodnot průměr a výsledek uloží do nové textové tabulky ve formátu .csv (oddělovačem sloupců bude středník). Výstupní tabulka bude obsahovat dva sloupce: “STAID” s identifikátorem stanice a “T” s průměrnou teplotou v květnu 1998."
  },
  {
    "objectID": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#zápis-adresářových-cest",
    "href": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#zápis-adresářových-cest",
    "title": "Lekce 7: Práce s adresářovou strukturou a s textovými soubory",
    "section": "",
    "text": "V Pythonu je výchozím způsobem, jak zapsat adresářovou cestu, klasický styl se zpětnými lomítky, např. C:\\Moje_slozka\\muj_soubor.txt. Problém je, že zpětné lomítko, jak víme, má v textových řetězcích speciální význam (uvozuje escape sekvenci). To lze obejít třemi způsoby:\n\nV zápisu cest použijeme dopředná lomítka: \"C:/Moje_slozka/muj_soubor.txt\". S tím si Python poradí.\nPoužijeme escape sekvenci \\\\, tj. dvojitá zpětná lomítka: \"C:\\\\Moje_slozka\\\\muj_soubor.txt\". Oba popsané způsoby jsou jistě výhodné tehdy, chceme-li cesty vypisovat ručně. Často ale využíváme např. toho, že si cestu zkopírujeme z nějakého prohlížeče a následně vložíme do kódu. Takové cesty mívají zpětná lomítka a jejich následná editace (záměna za dopředná či dvojitá zpětná lomítka) je zdlouhavá a nepraktická. Z takovém případě se hodí třetí způsob:\nPřed textový řetězec napíšeme r, čímž z něj vytvoříme “surový” (angl. “raw”) řetězec, jehož všechny znaky se interpretují tak, jak jsou (tj. řetězec neobsahuje žádné escape sekvence): r\"C:\\Moje_slozka\\muj_soubor.txt\".\n\nPřehled všech tří metod:\n# Dopředná lomítka\npath = \"C:/Moje_slozka/muj_soubor.txt\"\n\n# Dvojitá zpětná lomítka\npath = \"C:\\\\Moje_slozka\\\\muj_soubor.txt\"\n\n# Surový řetězec\npath = r\"C:\\Moje_slozka\\muj_soubor.txt\""
  },
  {
    "objectID": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#modul-os",
    "href": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#modul-os",
    "title": "Lekce 7: Práce s adresářovou strukturou a s textovými soubory",
    "section": "",
    "text": "Jméno modulu je zkratkou slov operační systém (anglicky “operating system”). Modul je určen pro správu adresářů a procesů. Z mnoha funkcí modulu budou pro nás užitečné zvláště některé pro správu adresářů. Parametr path (anglicky “cesta”) má ve všech ukázkách význam textového řetězce s adresou složky nebo souboru.\nModul načteme standardním způsobem:\nimport os\nPři operacích s adresářovou strukturou je výhodné mít správně nastaven tzv. pracovní adresář (angl. “workspace direcory”). Je-li nastaven, nemusíme např. při zadávání vstupních souborů do nějakého výpočtu zadávat celou cestu k souboru - pokud je vstupní soubor v pracovním adresáři, interpret Pythonu jej bude hledat tam. Rovněž jakékoli výstupní soubory, pokud neurčíme celou cestu, kam mají být uloženy, se budou ukládat do pracovního adresáře. Výchozí nastavení pracovního adresáře závisí na tom, jak jsme program IDLE spustili:\n\nPři otevření programu IDLE standardním způsobem z nabídky programů je pracovní adresář nastaven na výchozí pozici, typicky třeba 'C:\\\\WINDOWS\\\\system32'. (Pokud budeme nyní chtít např. otevřít nějaký skript stisknutím kláves Ctrl+O, vyhledávací okno se otevře právě v tomto umístění.)\nPři otevření programu IDLE “ze skriptu”, tj. tím, že skript otevřeme pro editaci v programu IDLE, je pracovní adresář automaticky nastaven na složku s tímto skriptem.\n\nPro zjištění aktuálního pracovního adresáře slouží funkce getcwd() (z angl. “current workspace directory”):\n&gt;&gt;&gt; os.getcwd()\n'C:\\\\Documents and Settings\\\\Muj_pocitac'\nPokud chceme naopak pracovní adresář změnit, použijeme funkci chdir(path) (z angl. “change directory”). Pozor: příslušné umístění path musí existovat!\n&gt;&gt;&gt; os.chdir(\"C:/Moje_slozka\")\n&gt;&gt;&gt; os.getcwd()\n'C:\\\\Moje_slozka'\nČasto chceme nějaký výpočet provést v cyklu pro všechny soubory v nějaké složce, případně pro všechny složky v nějaké nadřazené složce. Abychom získali seznam položek uvnitř nějaké složky, použijeme funkci listdir(path). Výstupní seznam je seznamem názvů (tj. řetězců) položek, včetně koncovek:\n&gt;&gt;&gt; os.listdir(\"C:/Moje_slozka\")\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Prvni_soubor.doc']\nČasto se potřebujeme v podobných funkcích odkázat na aktuální pracovní adresář (např. vypsat jeho obsah). To je možné pomocí již zmíněné funkce getcwd:\n&gt;&gt;&gt; os.listdir(getcwd())\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Prvni_soubor.doc']\nExistuje však i jednodušší způsob. V Pythonu se totiž lze odkazovat na pracovní adresář zkratkou \".\":\n&gt;&gt;&gt; os.listdir(\".\")\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Prvni_soubor.doc']\n\nÚkol 1. Změňte svůj pracovní adresář na nějakou složku, ve které máte větší množství souborů různých typů. Následně vypište její obsah na konzoli.\n\nDalší dvě funkce, které si ukážeme, slouží k vytváření nových adresářů. První, funkce mkdir(path), vytvoří na dané adrese novou složku. Podmínkou je, že celá cesta kromě koncové vytvářené složky existuje. TUto podmínku obchází druhá funkce, makedirs(path), která vytvoří na dané adrese novou složku, včetně všech případných neexistujících nadřazených složek.\n&gt;&gt;&gt; os.mkdir(\"C:/nova_slozka\")\n&gt;&gt;&gt; os.makedirs(\"C:/nejaka_nadslozka/nova_slozka\")\nPokud naopak chceme nějakou složku či soubor smazat, máme k dispozici následující funkce:\n# Smazání souboru\n&gt;&gt;&gt; os.remove(\"C:/Moje_slozka/muj_soubor.doc\")\n\n# Smazání (prázdné!) složky\n&gt;&gt;&gt; os.rmdir(\"C:/nova_slozka\")\n\n# Smazání (prázdné!) složky včetně všech (prázdných!) nadsložek\n&gt;&gt;&gt; os.removedirs(\"C:/ nejaka_nadslozka/nova_slozka\")\nUžitečné jsou rovněž funkce rename(old, new) a renames(old_path, new_path), pomocí kterých lze přejmenovávat cesty k souborů, a tím nejen měnit jejich název, ale i soubory přesouvat na nová umístění. První z nich, rename, přejmenuje cílový soubor ze staré cesty na novou, složka nového umístění souboru však již musí existovat. Druhá funkce, renames, toto nepožaduje a potřebné neexistující složky v nové cestě nejprve vytvoří (a zároveň odstraní již nepotřebné složky původní cesty).\n# Přejmenování souboru\nos.listdir(\"C:/nova_slozka\")\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Prvni_soubor.doc']\nos.rename(\"C:/nova_slozka/Prvni_soubor.doc\", \"C:/nova_slozka/Treti_soubor.doc\")\nos.listdir(\"C:/nova_slozka\")\n['Dalsi_soubor.xls', 'Druhy_soubor.txt', 'Treti_soubor.doc']\n\n# Přesunutí souboru\nos.renames(\"C:/nova_slozka/Prvni_soubor.doc\", \"C:/uplne/jina/cesta/Treti_soubor.doc\")\n\nÚkol 2. Uložte všechny textové soubory (nebo soubory jiného určitého typu) z vašeho pracovního adresáře do nově vytvořené podsložky “textove_soubory”. Použijte cyklus a podmínku if."
  },
  {
    "objectID": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#modul-os.path",
    "href": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#modul-os.path",
    "title": "Lekce 7: Práce s adresářovou strukturou a s textovými soubory",
    "section": "",
    "text": "Modul os.path je podmodul modulu os, obsahující funkce pro práci se samotnými adresářovými cestami. Po načtení modulu os jsou funkce podmodulu přístupné přes os.path.nejaka_funkce(), podmodul lze však také načíst samostatně (pak ovšem ostatní funkce z modulu os přístupné nebudou):\nimport os.path\npřípadně:\nfrom os import path\nVe druhém případě budou funkce podmodulu dostupné přes path.nejaka_funkce().\nZ obsahu podmodulu os.path vybíráme pouze některé, pro nás potenciálně užitečné funkce.\nFunkce basename(path) vrací poslední položku názvu cesty path, tj. v případě, že jde o adresu souboru, vrací jméno souboru, v případě, že jde o složku, vrací jméno složky:\n&gt;&gt;&gt; os.path.basename(\"C:/Moje_slozka/Dalsi_soubor.xls\")\n'Dalsi_soubor.xls'\n&gt;&gt;&gt; os.path.basename(\"C:/Moje_slozka\")\n'Moje_slozka'\nFunkce dirname(path) vrací nadřazenou složku poslední položky cesty:\n&gt;&gt;&gt; os.path.dirname(\"C:/Moje_slozka/Dalsi_soubor.xls\")\n'C:/Moje_slozka'\n&gt;&gt;&gt; os.path.dirname(\"C:/Moje_slozka\")\n'C:/'\nČasto potřebuju spojit adresu nějakého umístění z jednotlivých částí, např. C:\\hlavni_slozka, dalsi_slozka a nazev_souboru.xls, které máme uložené samostatně v nějakých proměnných. To můžeme udělat buď ručně:\na = \"C:/hlavni_slozka\"\nb = \"dalsi_slozka\"\nc = \"nazev_souboru.xls\"\npath = a + \"/\" + b + \"/\" + c\npath\n\"C:/hlavni_slozka/dalsi_slozka/nazev_souboru.xls\"\nnebo trochu stručnějším a bezpečnějším způsobem pomocí funkce join:\npath = os.path.join(a, b, c)\npath\n\"C:\\\\hlavni_slozka\\\\dalsi_slozka\\\\nazev_souboru.xls\"\nChceme-li ověřit, že dané umístění (soubor či složka) existuje, použijeme funkci exists:\n&gt;&gt;&gt; os.path.exists(\"C:/Moje_slozka/Dalsi_soubor.xls\")\nTrue\n&gt;&gt;&gt; os.path.exists(\"C:/Moje_slozka/Dalsi_soubor.txt\")\nFalse\nNěkdy se také hodí zjistit, zda je dané existující umístění adresou složky či souboru:\n# Ověří, zda je daná cesta cestou k souboru\n&gt;&gt;&gt; os.path.isfile(\"C:/Moje_slozka/Dalsi_soubor.xls\")\nTrue\n&gt;&gt;&gt; os.path.isfile(\"C:/Moje_slozka\")\nFalse\n\n# Ověří, zda je daná cesta cestou ke složce\n&gt;&gt;&gt; os.path.isdir(\"C:/Moje_slozka/Dalsi_soubor.xls\")\nFalse\n&gt;&gt;&gt; os.path.isdir(\"C:/Moje_slozka\")\nTrue\n\nÚkol 3. Modifikujte řešení úkolu 2 tak, abyste použili funkci os.path.join."
  },
  {
    "objectID": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#rozdělení-řetězce-znakem",
    "href": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#rozdělení-řetězce-znakem",
    "title": "Lekce 7: Práce s adresářovou strukturou a s textovými soubory",
    "section": "",
    "text": "Pro další část této lekce bude výhodné seznámit se s jednou technikou práce s textovými řetězci, která nebyla probrána v lekci o datových typech. Je jí rozdělení řetězce daným znakem či sérií znaků metodou split, což je funkce, která se volá přímo na daném řetězci či na proměnné obsahující řetězec:\n&gt;&gt;&gt; \"anakonda\".split(\"a\")\n['', 'n', 'kond', '']\n\n&gt;&gt;&gt; a = \"okolo potoka\"\n&gt;&gt;&gt; b = a.split(\"o\")\n&gt;&gt;&gt; b\n['', 'k', 'l', ' p', 't', 'ka']\nVidíme, že funkce split vrací seznam jednotlivých částí původního řetězce, rozděleného zadaným znakem. Pokud je tento znak na začátku či na konci řetězce, obsahuje výsledný seznam na začátku resp. na konci prázdný řetězec.\nPokud použijeme funkci split bez argumentu, tj. bez zadání řetězce, kterým se má vstupní řetězec rodělit, rozdělí se všemi tzn. prázdnými znaky, tj. mezerou, tabulátorem (znak \\t) či znakem nového řádku (znak \\n). V případě, že text obsahuje posloupnost jakýchkoli prázdných znaků za sebou, interpretuje se tato posloupnost, jako by šlo o jeden prázdný znak (tj. řetězec se v tomto místě rozdělí jen jednou):\n&gt;&gt;&gt; zprava = \"Ahoj lasko\\tje to    jiz dlouho\\nco jsme\\t\\t\\tse nevideli\"\n&gt;&gt;&gt; print(zprava)\nAhoj lasko  je to    jiz dlouho\nco jsme         se nevideli\n\n&gt;&gt;&gt; zprava.split()\n['Ahoj', 'lasko', 'je', 'to', 'jiz', 'dlouho', 'co', 'jsme', 'se', 'nevideli']\nTímto způsobem lze snadno nějaký text rozdělit na jednotlivá slova."
  },
  {
    "objectID": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#čtení-textových-souborů",
    "href": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#čtení-textových-souborů",
    "title": "Lekce 7: Práce s adresářovou strukturou a s textovými soubory",
    "section": "",
    "text": "Pro ilustraci si představme textový soubor obsahující následující text:\nDavno, davno jiz tomu, co jsem posledne se divala do te mile mirne tvare, co jsem zulibala to blede lice, plne vrasku, nahlizela do modreho oka, v nemz se jevilo tolik dobroty a lasky; davno tomu, co mne posledne zehnaly stare jeji ruce! - Neni vice dobre starenky! Davno jiz odpociva v chladne zemi!\nMne ale neumrela! - Obraz jeji odtisknut v dusi me s veskerou svoji barvitosti, a dokud zdrava zustane, dotud bude zit v ni! - Kdybych stetcem mistrne vladnout znala, oslavila bych te, mila babicko, jinak; ale nastin tento, perem kresleny - nevim, nevim, jak se komu zalibi!\nTy jsi ale vzdy rikala: \"Neni na svete clovek ten, aby se zachoval lidem vsem.\" Dost na tom, kdyz se najde jen nekolik ctenaru, kteri o tobe s takovou oblibou cisti budou, s jakou ja o tobe pisu.\nDejme tomu, že je soubor s tímto textem uložen na adrese C:\\Documents and Settings\\user\\Dokumenty\\babicka.txt.\nK otevření souboru pro čtení slouží vestavěná funkce open:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\babicka.txt\", \"r\")\nHodnota druhého parametru \"r“ je odvozena z anglického „read“ a udává, že bude soubor otevřen pro čtení.\nPokud chceme ze souboru přečíst naráz vše, co obsahuje, použijeme funkci read(). Výsledkem je jediný textový řetězec obsahující celý text:\n&gt;&gt;&gt; a = soubor.read()\n&gt;&gt;&gt; print(a)\nDavno, davno jiz tomu, co jsem posledne se divala do te mile mirne tvare, co jsem zulibala to blede lice, plne vrasku, nahlizela do modreho oka, v nemz se jevilo tolik dobroty a lasky; davno tomu, co mne posledne zehnaly stare jeji ruce! - Neni vice dobre starenky! Davno jiz odpociva v chladne zemi!\nMne ale neumrela! - Obraz jeji odtisknut v dusi me s veskerou svoji barvitosti, a dokud zdrava zustane, dotud bude zit v ni! - Kdybych stetcem mistrne vladnout znala, oslavila bych te, mila babicko, jinak; ale nastin tento, perem kresleny - nevim, nevim, jak se komu zalibi!\nTy jsi ale vzdy rikala: \"Neni na svete clovek ten, aby se zachoval lidem vsem.\" Dost na tom, kdyz se najde jen nekolik ctenaru, kteri o tobe s takovou oblibou cisti budou, s jakou ja o tobe pisu.\nDůležité je po každé ukončené akci se souborem daný soubor uzavřít:\n&gt;&gt;&gt; soubor.close()\nJinou možností je číst pouze jeden řádek pomocí funkce readline() (pozor: v našem textu je celý odstavec jediným řádkem!). Opakované volání této funkce čte postupně jednotlivé řádky:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\babicka.txt\",\"r\")\n&gt;&gt;&gt; a = soubor.readline()\n&gt;&gt;&gt; b = soubor.readline()\n&gt;&gt;&gt; print(a)\nDavno, davno jiz tomu, co jsem posledne se divala do te mile mirne tvare, co jsem zulibala to blede lice, plne vrasku, nahlizela do modreho oka, v nemz se jevilo tolik dobroty a lasky; davno tomu, co mne posledne zehnaly stare jeji ruce! - Neni vice dobre starenky! Davno jiz odpociva v chladne zemi!\n&gt;&gt;&gt; print(b)\nMne ale neumrela! - Obraz jeji odtisknut v dusi me s veskerou svoji barvitosti, a dokud zdrava zustane, dotud bude zit v ni! - Kdybych stetcem mistrne vladnout znala, oslavila bych te, mila babicko, jinak; ale nastin tento, perem kresleny - nevim, nevim, jak se komu zalibi!\n&gt;&gt;&gt; soubor.close()\nKonečně poslední možností je číst celý text po řádcích pomocí funkce readlines(). V takovém případě je výsledkem seznam textových řetězců obsahujících jednotlivé řádky (všimněte si znaků \\n na konci každého řádku):\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\babicka.txt\",\"r\")\n&gt;&gt;&gt; a = soubor.readlines()\n&gt;&gt;&gt; print(a)\n['Davno, davno jiz tomu, co jsem posledne se divala do te mile mirne tvare, co jsem zulibala to blede lice, plne vrasku, nahlizela do modreho oka, v nemz se jevilo tolik dobroty a lasky; davno tomu, co mne posledne zehnaly stare jeji ruce! - Neni vice dobre starenky! Davno jiz odpociva v chladne zemi!\\n', 'Mne ale neumrela! - Obraz jeji odtisknut v dusi me s veskerou svoji barvitosti, a dokud zdrava zustane, dotud bude zit v ni! Kdybych stetcem mistrne vladnout znala, oslavila bych te, mila babicko, jinak; ale nastin tento, perem kresleny - nevim, nevim, jak se komu zalibi!\\n', 'Ty jsi ale vzdy rikala: \"Neni na svete clovek ten, aby se zachoval lidem vsem.\" Dost na tom, kdyz se najde jen nekolik ctenaru, kteri o tobe s takovou oblibou cisti budou, s jakou ja o tobe pisu. \\n']\n&gt;&gt;&gt; soubor.close()\n\nÚkol 4. Uložte si (“manuálně”, např. pomocí Poznámkového bloku) uvedený text do textového souboru. Následně soubor v Pythonu otevřte a zjistěte počet řádků, počet slov a počet znaků v textu.\n\nV aplikacích často chceme procházet text přečtený z nějakého souboru “řádek po řádku”. Např. se může jednat o datovou tabulku ve formátu .csv (“comma-separated values”, hodnoty oddělené čárkou), což je jednoduchý textový soubor s tabulkovými daty, který lze nicméně přímo otevírat např. v aplikaci MS Excel. Procházení “řádek po řádku” pak znamená procházení jednotlivých řádků tabulky. Lze k němu využít již zmíněné funkce readlines, která vrací seznam řádků - ten lze samozřejmě následně procházet cyklem:\nf = open(\"tabulka.csv\", \"r\")\nlines = f.readlines()\nf.close()\nfor l in lines:\n    # Tady bude nějaká akce s proměnnou l\nObjekt, který vrací funkce open, je nicméně v Pythonu udělán tak, že lze v cyklu procházet přímo jej, chová se tedy sám jako seznam řádků:\nf = open(\"tabulka.csv\", \"r\")\nfor l in f:\n    # Tady bude nějaká akce s proměnnou l\nf.close()\nV tomto případě se ovšem procházení děje pomocí tzv. kurzoru, což se mimo jiné projeví tím, že projdeme-li celý soubor až do konce, je kurzor na konci souboru a další procházení již nic nevrací:\n&gt;&gt;&gt; f = open(\"text.txt\", \"r\")\n&gt;&gt;&gt; for l in f: print(l)\n\nprvni radek\ndruhy radek\n...\nposledni radek\n&gt;&gt;&gt; for l in f: print(l)\n\n&gt;&gt;&gt; f.close()\nAbychom soubor mohli procházet znovu, museli bychom soubor znovu načíst.\nZpůsob pomocí načtení seznamu řádků metodou readlines má navíc tu výhodu, že lze procházet jen vybrané řádky, např. při čtení tabulky vynechat první řádek, jímž bývá hlavička tabulky:\nf = open(\"tabulka.csv\", \"r\")\nlines = f.readlines()\nf.close()\nfor l in lines[1:]:\n    # Tady bude nějaká akce s proměnnou l\nZávěrem si ještě ukážeme způsob, jak soubory otevírat, aniž byste museli myslet na jejich následné zavření. Je to možné pomocí klauzule with, která vytváří odsazený blok kódu. Jakmile blok kódu skončí tím, že odsadíme na původní úroveň, otevřený soubor se sám automaticky zavře. Syntax je následující:\nwith open(\"soubor.txt\") as f:\n    f.readlines()\n    ...\n# Tady pokračuje kód a soubor již je uzavřen\n\nÚkol 5. Otevřte si tabulku precipitation_2014.csv v aplikaci MS Excel a prozkoumejte, co obsahuje. Pak ji zavřete a otevřete ji v programu Poznámkový blok: čím jsou odděleny jednotlivé sloupce? Napište program, který tabulku otevřte a spočítá průměrný srážkový úhrn v srpnu daného roku. (Poznámka: data pocházejí z ČHMÚ.)"
  },
  {
    "objectID": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#zápis-textových-souborů",
    "href": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#zápis-textových-souborů",
    "title": "Lekce 7: Práce s adresářovou strukturou a s textovými soubory",
    "section": "",
    "text": "Chceme-li naopak do textového souboru zapisovat, je nutné jej otevřít s parametrem \"w\" (z anglického „write“):\nsoubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\dedecek.txt\",\"w\")\nSoubor, který tímto způsobem otvíráme, nemusí ve skutečnosti vůbec existovat a je tímto příkazem vytvořen (musí však existovat příslušná složka). Pokud soubor již existuje, je uvedeným způsobem otevření veškerý jeho obsah vymazán a při následném zapisování nahrazen obsahem novým.\nZápis se provádí pomocí funkce write(text). Pokud chceme zapsat text na více řádků, je třeba použít znak pro konec řádku \\n. Opět je třeba nezapomenout na konečné uzavření souboru.\n&gt;&gt;&gt; soubor.write(\"Ahoj dedo.\\n\")\n&gt;&gt;&gt; soubor.write(\"Nevis,\\nco je s babickou?\")\n&gt;&gt;&gt; soubor.close()\nPřečteme-li výsledný soubor, obdržíme:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\dedecek.txt\",\"r\")\n&gt;&gt;&gt; print(soubor.read()\nAhoj dedo.\nNevis,\nco je s babickou?\n&gt;&gt;&gt; soubor.close()\nZbývá vyřešit, jak zapisovat do existujícího souboru, aniž bychom jej při otvírání celý přepsali. To lze provést jeho otevřením s parametrem \"a\" (z anglického „append“). Následný zápis funkcí write(text) pak způsobí zapsání daného textu na konec za již existující text:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\dedecek.txt\",\"a\")\n&gt;&gt;&gt; soubor.write(\"\\nJo, hochu, to vazne nevim.\")\n&gt;&gt;&gt; soubor.close()\nVýsledek vypadá následovně:\n&gt;&gt;&gt; soubor = open(r\"C:\\Documents and Settings\\user\\Dokumenty\\dedecek.txt\",\"r\")\n&gt;&gt;&gt; print(soubor.read())\nAhoj dedo.\nNevis,\nco je s babickou?\nJo, hochu, to vazne nevim.\n&gt;&gt;&gt; soubor.close()\n\nÚkol 6. Napiště program, který v tabulce precipitation_2014.csv změní desetinné tečky na desetinné čárky."
  },
  {
    "objectID": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#úlohy",
    "href": "material/old_materials/Lekce 7 Práce s adresářovou strukturou a s textovými soubory.html#úlohy",
    "title": "Lekce 7: Práce s adresářovou strukturou a s textovými soubory",
    "section": "",
    "text": "Napište program, který vyrobí obrácenou kopii daného textového souboru (tj. text ve výstupním souboru bude zrcadlově obrácen).\nNapište program, který spočítá četnost výskytu daného písmene v zadaném vstupním textovém souboru. Řešte nejdříve s použitím metody count seznamů, následně bez této metody.\nVe složce data_teplota najdete textové soubory, v nichž jsou údaje o měření teploty (v desetinách stupně Celsia) na jednotlivých evropských stanicích (každé stanici odpovídá jeden soubor). Napište program, který z těchto textových souborů vyextrahuje hodnoty teplot pro květen 1998, spočítá pro každou stanici z těchto hodnot průměr a výsledek uloží do nové textové tabulky ve formátu .csv (oddělovačem sloupců bude středník). Výstupní tabulka bude obsahovat dva sloupce: “STAID” s identifikátorem stanice a “T” s průměrnou teplotou v květnu 1998."
  },
  {
    "objectID": "material/old_materials/Lekce 9 Třídy a objekty.html",
    "href": "material/old_materials/Lekce 9 Třídy a objekty.html",
    "title": "Lekce 9: Třídy a objekty",
    "section": "",
    "text": "Třídy a objekty jsou základem většiny moderních programovacích jazyků. Snad každý už někdy slyšel o “objektovém programování” či o “objektově orientovaných jazycích”. V této kapitole si vysvětlíme a na malé ukázce předvedeme, o co jde. Nepůjde nám přitom o zvládnutí samotného objektového programování, to by přesahovalo časové možnosti tohoto kurzu. Půjde spíš o to pochopit základní strikturu objektů a tříd tak, abyste byli schopni pracovat s objekty a třídami, které již někdo naprogramoval před vámi. Jak uvidíte v další části kurzu, při práci s funkcionalitou ArcGIS pomocí Pythonu jsou objekty všudypřítomné.\nTřídu si lze představit jako jakýsi složitý datový typ. Objekt je pak konkrétní realizace (tzv. instance) této třídy, podobně jako konkrétní seznam je instancí obecného datového typu list. Příkladem může být třída “Pes”. V rámci definice této třídy můžeme určit, co bude každý konkrétní objekt této třídy, neboli každý konkrétní “pes”, obsahovat. Každá třída může obsahovat:\n\nvlastnosti, neboli proměnné. Stejně jako každá jiná proměnná, i každá vlastnost je určitého datového typu. V případě naší třídy “Pes” to může být: věk (číslo), jméno (text) apod.\nmetody, neboli funkce. V rámci třídy můžeme definovat funkce, které bude mít každá konkrétní instance této třídy k dispozici. Metody objektu často něco dělají s jeho vlastnostmi. Např. naše třída “Pes” by mohla obsahovat metodu “štěkni”, která by po zavolání vypsala na konzoli text “Haf”, případně “Haf haf, já jsem …”, kde místo tří teček by bylo jméno daného psa, uložené v té chvíli ve vlastnosti “jméno”. Dále by mohla obsahovat metodu “zestárni”, která by zvýšila hodnotu vlastnosti “věk” o jedna.\n\n\n\nPojďme si třídu pes vytvořit. Definice třídy začíná klíčovým slovem class, následuje tělo třídy odsazené o jednu úroveň doprava:\nclass Dog:\n\n    def __init__(self, name):\n        self.name = name\n        self.age = 0\n\n    def woof(self):\n        print(\"Woof woof, I'm \" + self.name)\n\n    def get_older(self):\n        self.age = self.age + 1\nVidíme, že tělo třídy obsahuje postupně definice třech funkcí. První z nich je tzv. konstruktor třídy a budeme se mu věnuvat níže. Druhé dvě funkce, tedy woof a get_older, jsou metody, které bude mít každá instance této třídy k dispozici. Jediným parametrem obou funkcí je parametr self, pomocí kterého se lze uvnitř funkcí odkazovat na vlastnosti daného objektu (self.name a self.age). Parametr self je u všech metod povinný, vedle něj mohou metody obsahovat i další parametry.\nVidíme, že metoda woof pouze vytiskne text, ve kterém se použije jméno daného psa, na němž se bude metoda volat (toto jméno bude totiž uloženo ve vlastnosti self.name). Metoda get_older zvýší hodnotu vlastnosti self.age o jedna.\nKonstruktor třídy se jmenuje vždy stejně, a to __init__ (před a po slově init jsou dvě podtržítka za sebou). Je to funkce, která se automaticky volá při vytváření každé nové instance (tj. objektu) třídy. V této funkci jsou také definovány vlastnosti, které bude každý pes mít k dispozici. Jsou to proměnné self.name a self.age. Slovo self zde vždy odkazuje k budoucí instanci třídy a je povinným (prvním) parametrem každé metody.\nCo tedy bude dělat konstruktor třídy Dog? Nastaví hodnotu vlastnosti self.name na hodnotu parametru name a hodnotu vlastnosti self.age na hodnotu 0. Parametr name konstruktoru bude muset uživatel při vytváření objektu zadat (nebude tedy možné vytvořit bezejmenného psa).\n\nÚkol 1. Napište shora uvedenou definici třídy Dog do skriptu a skript spusťte.\n\nVytvoření konkrétního objektu třídy se provádí voláním funkce, která má stejný název jako daná třída. Ve skutečnosti se tím volá konstruktor třídy. Při volání této funkce je třeba určit hodnoty parametrů v tom pořadí, jak jsou definovány v konstruktoru (ovšem s vynecháním parametru self). Funkce vrací objekt dané třídy, který je zpravidla žádoucí uložit do nějaké proměnné.\nV našem případě se bude tedy funkce jmenovat Dog a jejím jediným parametrem bude name:\n&gt;&gt;&gt; alik = Dog(\"Alik\")\nProměnná Alik teď obsahuje objekt (neboli instanci) třídy Dog (objekty jsou ve výpisech na konzoli vždy poznatelné podle špičatých závorek):\n&gt;&gt;&gt; alik\n&lt;__main__.Dog instance at 0x02EBE8F0&gt;\nK vlastnostem a metodám objektu lze přistupovat pomocí názvu objektu a tečky (metody se od vlastností rozeznají tím, že mají za sebou kulaté závorky: jsou to totiž funkce):\n&gt;&gt;&gt; alik.name\n'Alik'\n&gt;&gt;&gt; alik.woof()\nWoof woof, I'm Alik\n&gt;&gt;&gt; alik.age\n0\n&gt;&gt;&gt; alik.get_older()\n&gt;&gt;&gt; alik.age\n1\nObjektů určité třídy lze vytvářet prakticky neomezené množství, každý bude mít přitom své vlastní instance všech vlastností a metod, tak jak jsou v dané třídě definovány:\n&gt;&gt;&gt; zeryk = Dog(\"Zeryk\")\n&gt;&gt;&gt; zeryk.woof()\nWoof woof, I'm Zeryk\n&gt;&gt;&gt; zeryk.age\n0\n&gt;&gt;&gt; zeryk.get_older()\n&gt;&gt;&gt; zeryk.get_older()\n&gt;&gt;&gt; zeryk.age\n2\n&gt;&gt;&gt; alik.age\n1\nV Pythonu jsou všechno objekty.."
  },
  {
    "objectID": "material/old_materials/Lekce 9 Třídy a objekty.html#definice-třídy",
    "href": "material/old_materials/Lekce 9 Třídy a objekty.html#definice-třídy",
    "title": "Lekce 9: Třídy a objekty",
    "section": "",
    "text": "Pojďme si třídu pes vytvořit. Definice třídy začíná klíčovým slovem class, následuje tělo třídy odsazené o jednu úroveň doprava:\nclass Dog:\n\n    def __init__(self, name):\n        self.name = name\n        self.age = 0\n\n    def woof(self):\n        print(\"Woof woof, I'm \" + self.name)\n\n    def get_older(self):\n        self.age = self.age + 1\nVidíme, že tělo třídy obsahuje postupně definice třech funkcí. První z nich je tzv. konstruktor třídy a budeme se mu věnuvat níže. Druhé dvě funkce, tedy woof a get_older, jsou metody, které bude mít každá instance této třídy k dispozici. Jediným parametrem obou funkcí je parametr self, pomocí kterého se lze uvnitř funkcí odkazovat na vlastnosti daného objektu (self.name a self.age). Parametr self je u všech metod povinný, vedle něj mohou metody obsahovat i další parametry.\nVidíme, že metoda woof pouze vytiskne text, ve kterém se použije jméno daného psa, na němž se bude metoda volat (toto jméno bude totiž uloženo ve vlastnosti self.name). Metoda get_older zvýší hodnotu vlastnosti self.age o jedna.\nKonstruktor třídy se jmenuje vždy stejně, a to __init__ (před a po slově init jsou dvě podtržítka za sebou). Je to funkce, která se automaticky volá při vytváření každé nové instance (tj. objektu) třídy. V této funkci jsou také definovány vlastnosti, které bude každý pes mít k dispozici. Jsou to proměnné self.name a self.age. Slovo self zde vždy odkazuje k budoucí instanci třídy a je povinným (prvním) parametrem každé metody.\nCo tedy bude dělat konstruktor třídy Dog? Nastaví hodnotu vlastnosti self.name na hodnotu parametru name a hodnotu vlastnosti self.age na hodnotu 0. Parametr name konstruktoru bude muset uživatel při vytváření objektu zadat (nebude tedy možné vytvořit bezejmenného psa).\n\nÚkol 1. Napište shora uvedenou definici třídy Dog do skriptu a skript spusťte.\n\nVytvoření konkrétního objektu třídy se provádí voláním funkce, která má stejný název jako daná třída. Ve skutečnosti se tím volá konstruktor třídy. Při volání této funkce je třeba určit hodnoty parametrů v tom pořadí, jak jsou definovány v konstruktoru (ovšem s vynecháním parametru self). Funkce vrací objekt dané třídy, který je zpravidla žádoucí uložit do nějaké proměnné.\nV našem případě se bude tedy funkce jmenovat Dog a jejím jediným parametrem bude name:\n&gt;&gt;&gt; alik = Dog(\"Alik\")\nProměnná Alik teď obsahuje objekt (neboli instanci) třídy Dog (objekty jsou ve výpisech na konzoli vždy poznatelné podle špičatých závorek):\n&gt;&gt;&gt; alik\n&lt;__main__.Dog instance at 0x02EBE8F0&gt;\nK vlastnostem a metodám objektu lze přistupovat pomocí názvu objektu a tečky (metody se od vlastností rozeznají tím, že mají za sebou kulaté závorky: jsou to totiž funkce):\n&gt;&gt;&gt; alik.name\n'Alik'\n&gt;&gt;&gt; alik.woof()\nWoof woof, I'm Alik\n&gt;&gt;&gt; alik.age\n0\n&gt;&gt;&gt; alik.get_older()\n&gt;&gt;&gt; alik.age\n1\nObjektů určité třídy lze vytvářet prakticky neomezené množství, každý bude mít přitom své vlastní instance všech vlastností a metod, tak jak jsou v dané třídě definovány:\n&gt;&gt;&gt; zeryk = Dog(\"Zeryk\")\n&gt;&gt;&gt; zeryk.woof()\nWoof woof, I'm Zeryk\n&gt;&gt;&gt; zeryk.age\n0\n&gt;&gt;&gt; zeryk.get_older()\n&gt;&gt;&gt; zeryk.get_older()\n&gt;&gt;&gt; zeryk.age\n2\n&gt;&gt;&gt; alik.age\n1\nV Pythonu jsou všechno objekty.."
  }
]